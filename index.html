<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Zones - fight, loot, survive.</title>
<style>
  :root{
    color-scheme: dark;

    /* CORE TERMINAL PALETTE */
    --bg:#020202;
    --ink:#b8ffcf;
    --muted:#5cff8b;

    --green:#39ff14;
    --green-d:#0b5f1e;
    --red:#ff0033;
    --red-d:#5a0014;

    --amber:#ffb000;
    --orange:#ff6a00;
    --blue:#00b7ff;

    /* SURFACES */
    --panel:rgba(0, 0, 0, 0.78);
    --panel-2:rgba(8, 10, 8, 0.88);
    --panel-3:rgba(0, 0, 0, 0.55);

    --border:rgba(57,255,20,0.22);
    --border-strong:rgba(57,255,20,0.48);
    --border-red:rgba(255,0,51,0.45);

    --shadow:0 18px 60px rgba(0,0,0,.62);
    --inner:inset 0 0 0 1px rgba(57,255,20,0.08);

    --glow:0 0 18px rgba(57,255,20,.25), 0 0 48px rgba(57,255,20,.08);
    --glow-strong:0 0 10px rgba(57,255,20,.55), 0 0 28px rgba(57,255,20,.25), 0 0 80px rgba(57,255,20,.08);
    --glow-red:0 0 10px rgba(255,0,51,.55), 0 0 28px rgba(255,0,51,.25), 0 0 90px rgba(255,0,51,.10);

    --radius:12px;

    /* CRT FX */
    --scanlineA:rgba(0,0,0,0.32);
    --scanlineB:rgba(0,0,0,0.06);
    --noiseA:rgba(255,255,255,0.06);
    --vignette:rgba(0,0,0,0.72);

    /* TYPE */
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }

  *{box-sizing:border-box;}
  ::selection{background:rgba(255,0,51,0.28); color:#fff;}

  html, body{height:100%;}
  body{
    margin:0;
    min-height:100vh;
    padding:12px;
    color:var(--ink);
    font-family:var(--mono);
    letter-spacing:0.2px;
    line-height:1.45;

    /* HELLGRID BACKDROP */
    background:
      radial-gradient(circle at 20% 20%, rgba(57,255,20,.10), transparent 40%),
      radial-gradient(circle at 80% 10%, rgba(255,0,51,.09), transparent 38%),
      radial-gradient(circle at 40% 90%, rgba(0,183,255,.06), transparent 45%),
      radial-gradient(circle at 10% 80%, rgba(255,176,0,.04), transparent 50%),
      repeating-linear-gradient(0deg, rgba(57,255,20,.04) 0, rgba(57,255,20,.04) 1px, transparent 1px, transparent 28px),
      repeating-linear-gradient(90deg, rgba(57,255,20,.03) 0, rgba(57,255,20,.03) 1px, transparent 1px, transparent 34px),
      var(--bg);

    text-shadow: 0 0 10px rgba(57,255,20,0.08);

    /* subtle CRT warp + flicker */
    animation: crtFlicker 6.5s infinite steps(1, end);
  }

  /* CRT overlays: scanlines + noise + vignette + chroma */
  body::before{
    content:"";
    position:fixed;
    inset:0;
    pointer-events:none;
    z-index:9999;
    background:
      /* scanlines */
      repeating-linear-gradient(
        180deg,
        var(--scanlineA) 0px,
        var(--scanlineA) 1px,
        var(--scanlineB) 2px,
        transparent 4px
      ),
      /* faint vertical mask */
      repeating-linear-gradient(
        90deg,
        rgba(0,0,0,0.18) 0px,
        rgba(0,0,0,0.18) 1px,
        transparent 3px,
        transparent 7px
      ),
      /* vignette */
      radial-gradient(circle at 50% 55%, rgba(0,0,0,0.05) 0%, var(--vignette) 70%, rgba(0,0,0,0.92) 100%);
    mix-blend-mode: multiply;
    opacity:0.95;
  }
  body::after{
    content:"";
    position:fixed;
    inset:-20%;
    pointer-events:none;
    z-index:9998;
    background:
      /* noise grain */
      repeating-radial-gradient(circle at 20% 30%, rgba(255,255,255,0.05) 0 1px, transparent 2px 6px),
      repeating-radial-gradient(circle at 70% 60%, rgba(255,255,255,0.03) 0 1px, transparent 2px 7px),
      linear-gradient(90deg, rgba(255,0,51,0.03), rgba(0,183,255,0.02), rgba(57,255,20,0.03));
    opacity:0.18;
    filter: blur(0.2px);
    animation: noiseDrift 2.2s infinite linear;
  }

  .modal{
    position:fixed;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:24px;
    background:rgba(0,0,0,0.72);
    z-index:10000;
  }

  .modal.hidden{
    display:none;
  }

  .modal-card{
    width:min(520px, 92vw);
    padding:20px 22px;
    border-radius:var(--radius);
    border:1px solid var(--border-strong);
    background:var(--panel);
    box-shadow:var(--shadow), var(--inner), var(--glow);
  }

  .modal-actions{
    display:flex;
    flex-wrap:wrap;
    gap:12px;
    margin-top:16px;
  }

  /* app wrapper */
  #app{
    max-width:1200px;
    margin:auto;
    display:flex;
    flex-direction:column;
    gap:12px;
    position:relative;
  }

  /* HEADER = main terminal bar */
  header{
    display:flex;
    flex-wrap:wrap;
    gap:10px;
    align-items:center;
    justify-content:space-between;
    padding:14px 16px;

    background:
      linear-gradient(180deg, rgba(10,12,10,0.92), rgba(0,0,0,0.78)),
      radial-gradient(circle at 20% 50%, rgba(57,255,20,0.08), transparent 55%),
      radial-gradient(circle at 85% 40%, rgba(255,0,51,0.06), transparent 60%);

    border:1px solid var(--border-strong);
    border-radius: var(--radius);
    box-shadow: var(--shadow), var(--inner), var(--glow);
    position:sticky;
    top:0;
    z-index:3;

    backdrop-filter: blur(6px);
    overflow:hidden;
  }
  header::before{
    content:"";
    position:absolute;
    inset:-2px;
    background:
      repeating-linear-gradient(135deg,
        rgba(255,0,51,0.12) 0 8px,
        rgba(255,0,51,0.00) 8px 16px);
    opacity:0.12;
    pointer-events:none;
    mix-blend-mode: screen;
  }
  header::after{
    content:"";
    position:absolute;
    left:-40%;
    top:0;
    width:50%;
    height:100%;
    background:linear-gradient(90deg, transparent, rgba(57,255,20,0.12), transparent);
    transform:skewX(-18deg);
    animation: sweep 4.8s infinite linear;
    opacity:0.35;
    pointer-events:none;
  }

  .title{
    font-size:18px;
    font-weight:800;
    letter-spacing:1.3px;
    display:flex;
    align-items:center;
    gap:10px;
    color:#dbffe8;
    text-transform:uppercase;
    text-shadow: 0 0 12px rgba(57,255,20,0.18), 0 0 2px rgba(255,255,255,0.10);
  }
  .title::before{
    content:"▮";
    color:var(--green);
    text-shadow: var(--glow-strong);
    animation: cursorBlink 0.9s infinite steps(1,end);
  }
  .tagline{
    font-size:12px;
    color:rgba(184,255,207,0.75);
    letter-spacing:0.6px;
  }

  .pill{
    border:1px solid var(--border);
    border-radius:999px;
    padding:6px 10px;
    font-size:11px;
    color:rgba(184,255,207,0.76);
    background:
      linear-gradient(180deg, rgba(12,16,12,0.65), rgba(0,0,0,0.55));
    box-shadow: var(--inner);
    text-transform:uppercase;
    letter-spacing:0.8px;
  }
  .pill::before{
    content:"●";
    margin-right:8px;
    color:var(--amber);
    text-shadow: 0 0 10px rgba(255,176,0,0.45);
  }

  /* PANELS = terminal windows */
  .panel{
    background:
      linear-gradient(180deg, rgba(8,10,8,0.90), rgba(0,0,0,0.72)),
      radial-gradient(circle at 15% 30%, rgba(57,255,20,0.08), transparent 55%),
      radial-gradient(circle at 85% 20%, rgba(255,0,51,0.07), transparent 60%);
    border:1px solid var(--border);
    border-radius: var(--radius);
    padding:14px 16px;
    box-shadow: var(--shadow), var(--inner);
    position:relative;
    overflow:hidden;
  }
  .panel::before{
    content:"";
    position:absolute;
    inset:0;
    background:
      repeating-linear-gradient(0deg, rgba(57,255,20,0.04) 0 1px, transparent 1px 10px);
    opacity:0.30;
    pointer-events:none;
  }
  .panel::after{
    content:"";
    position:absolute;
    inset:-2px;
    border-radius: var(--radius);
    box-shadow:
      inset 0 0 0 1px rgba(57,255,20,0.12),
      inset 0 0 0 2px rgba(255,0,51,0.06);
    pointer-events:none;
  }

  .panel h3{
    margin:0 0 8px;
    font-size:14px;
    letter-spacing:1.2px;
    text-transform:uppercase;
    color:#e9fff2;
    text-shadow: 0 0 10px rgba(57,255,20,0.12);
  }
  .panel h3::after{
    content:" //";
    color:rgba(57,255,20,0.55);
  }

  .grid-two{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:10px;}
  .two-col{display:grid;grid-template-columns:1.1fr 1fr;gap:12px;}

  /* STATLINES */
  .statline{
    display:grid;
    grid-template-columns:110px 1fr 68px;
    align-items:center;
    font-size:12px;
    gap:10px;
    padding:7px 0;
    border-bottom:1px solid rgba(57,255,20,0.06);
  }
  .bar{
    height:10px;
    background:rgba(0,0,0,0.65);
    border-radius:999px;
    overflow:hidden;
    border:1px solid rgba(57,255,20,0.15);
    box-shadow: inset 0 0 10px rgba(0,0,0,0.65);
    position:relative;
  }
  .bar::after{
    content:"";
    position:absolute;
    inset:0;
    background:linear-gradient(90deg, rgba(255,255,255,0.08), transparent 35%, rgba(255,255,255,0.06));
    opacity:0.25;
    pointer-events:none;
  }
  .bar span{
    display:block;height:100%;
    border-radius:999px;
    filter: saturate(1.15) contrast(1.05);
    box-shadow: 0 0 14px rgba(57,255,20,0.18);
  }

  .bar.hp span{background:linear-gradient(90deg, var(--red), var(--orange)); box-shadow: var(--glow-red);}
  .bar.stamina span{background:linear-gradient(90deg, var(--green), rgba(0,183,255,0.55));}
  .bar.morale span{background:linear-gradient(90deg, var(--amber), rgba(57,255,20,0.55));}
  .bar.rads span{background:linear-gradient(90deg, rgba(57,255,20,0.8), var(--amber), var(--red));}
  .bar.hunger span{background:linear-gradient(90deg, var(--orange), var(--red));}
  .bar.thirst span{background:linear-gradient(90deg, var(--blue), rgba(57,255,20,0.6));}
  .bar.temp span{background:linear-gradient(90deg, var(--green), var(--blue));}

  /* META CHIPS */
  .meta{color:rgba(184,255,207,0.72);font-size:12px;display:flex;flex-wrap:wrap;gap:10px;}
  .meta b{color:#eafff0;margin-right:6px;}
  .pill-inline{
    display:inline-flex;align-items:center;gap:8px;
    padding:4px 10px;
    border-radius:999px;
    border:1px solid rgba(57,255,20,0.18);
    background:linear-gradient(180deg, rgba(10,12,10,0.6), rgba(0,0,0,0.55));
    font-size:11px;
    color:rgba(184,255,207,0.78);
    box-shadow: var(--inner);
    text-transform:uppercase;
    letter-spacing:0.6px;
  }
  .pill-inline::before{
    content:"▸";
    color:var(--green);
    text-shadow: var(--glow);
  }

  .rows{display:flex;flex-direction:column;gap:10px;}

  .muted-box{
    padding:14px 16px;
    border-radius:10px;
    border:1px dashed rgba(57,255,20,0.18);
    color:rgba(184,255,207,0.70);
    background:
      linear-gradient(180deg, rgba(0,0,0,0.62), rgba(0,0,0,0.46));
    box-shadow: inset 0 0 0 1px rgba(255,0,51,0.05);
    position:relative;
  }
  .muted-box::after{
    content:"⚠";
    position:absolute;
    right:10px;
    top:10px;
    color:rgba(255,176,0,0.65);
    text-shadow: 0 0 12px rgba(255,176,0,0.25);
    font-size:12px;
  }

  /* BUTTONS = chunky terminal keys */
  button{
    appearance:none;
    border:1px solid rgba(57,255,20,0.28);
    background:
      linear-gradient(180deg, rgba(10,14,10,0.92), rgba(0,0,0,0.78));
    color:#eafff0;
    border-radius:10px;
    padding:10px 12px;
    font-size:13px;
    text-align:left;
    cursor:pointer;
    transition:transform .06s ease, border .15s ease, filter .15s ease, box-shadow .15s ease;
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:8px;
    min-height:46px;

    box-shadow:
      0 10px 22px rgba(0,0,0,0.55),
      inset 0 0 0 1px rgba(57,255,20,0.08),
      0 0 0 1px rgba(0,0,0,0.5);
    letter-spacing:0.7px;
    text-transform:uppercase;
    position:relative;
    overflow:hidden;
  }
  button::before{
    content:"";
    position:absolute;
    inset:0;
    background:
      linear-gradient(90deg, transparent, rgba(57,255,20,0.10), transparent);
    transform:translateX(-120%);
    transition:transform .25s ease;
    pointer-events:none;
  }
  button::after{
    content:"";
    position:absolute;
    left:10px;
    top:50%;
    width:6px;height:6px;
    border-radius:50%;
    transform:translateY(-50%);
    background:rgba(255,176,0,0.85);
    box-shadow:
      0 0 10px rgba(255,176,0,0.45),
      0 0 18px rgba(255,106,0,0.20);
    pointer-events:none;
  }
  button:hover{
    transform:translateY(-1px);
    border-color:rgba(57,255,20,0.62);
    box-shadow: var(--shadow), var(--inner), var(--glow-strong);
    filter:saturate(1.15);
  }
  button:hover::before{transform:translateX(120%);}
  button:active{transform:translateY(0); filter:saturate(1.05) contrast(1.02);}

  button:disabled{
    opacity:0.35;
    cursor:not-allowed;
    border-style:dashed;
    box-shadow:none;
  }

  .btn-secondary{
    border-color:rgba(0,183,255,0.22);
    background:linear-gradient(180deg, rgba(8,10,14,0.92), rgba(0,0,0,0.78));
  }
  .btn-secondary::after{
    background:rgba(0,183,255,0.92);
    box-shadow:0 0 10px rgba(0,183,255,0.45), 0 0 18px rgba(0,183,255,0.20);
  }
  .danger{
    border-color:rgba(255,0,51,0.48);
    color:#ffd6de;
  }
  .danger:hover{
    border-color:rgba(255,0,51,0.75);
    box-shadow: var(--shadow), var(--inner), var(--glow-red);
  }
  .danger::after{
    background:rgba(255,0,51,0.95);
    box-shadow:0 0 10px rgba(255,0,51,0.55), 0 0 22px rgba(255,0,51,0.25);
  }

  /* TABS */
  .tabs{
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:var(--radius);
    box-shadow:var(--shadow), var(--inner);
    overflow:hidden;
  }
  .tab-buttons{
    display:flex;
    gap:8px;
    padding:10px 12px;
    border-bottom:1px solid rgba(57,255,20,0.14);
    flex-wrap:wrap;
    background:
      linear-gradient(180deg, rgba(10,12,10,0.70), rgba(0,0,0,0.60));
  }
  .tab-buttons button{
    flex:1 1 120px;
    text-align:center;
    justify-content:center;
    border-radius:10px;
    padding:10px 12px;
    min-height:40px;
  }
  .tab-buttons button.active{
    border-color:rgba(57,255,20,0.75);
    background:
      linear-gradient(180deg, rgba(57,255,20,0.14), rgba(0,0,0,0.70));
    box-shadow: var(--glow-strong);
  }

  .tab-content{display:none;padding:12px;}
  .tab-content.active{display:block;}

  /* BADGES + SCENE */
  .badge{
    font-size:11px;
    border-radius:8px;
    padding:3px 10px;
    background:linear-gradient(180deg, rgba(57,255,20,0.10), rgba(0,0,0,0.72));
    border:1px solid rgba(57,255,20,0.45);
    color:rgba(184,255,207,0.92);
    display:inline-flex;
    gap:8px;
    align-items:center;
    text-transform:uppercase;
    letter-spacing:0.8px;
    box-shadow: var(--inner), var(--glow);
    position:relative;
  }
  .badge::before{
    content:"";
    width:8px;height:8px;border-radius:50%;
    background:rgba(57,255,20,0.95);
    box-shadow:0 0 10px rgba(57,255,20,0.55), 0 0 18px rgba(57,255,20,0.22);
  }
  .scene-title{font-size:15px;margin:0;color:#eafff0;text-transform:uppercase;letter-spacing:1px;}
  .scene-desc{margin:6px 0 10px;color:rgba(184,255,207,0.78);font-size:13px;}

  .inline{display:flex;flex-wrap:wrap;gap:8px;align-items:center;}
  .stack{display:flex;flex-direction:column;gap:12px;}

  /* LOG/TERMINAL BOX */
  .log{
    white-space:pre-wrap;
    font-size:12px;
    color:#d6ffe6;
    line-height:1.35;
    max-height:320px;
    overflow:auto;
    padding:12px;

    background:
      radial-gradient(circle at 10% 10%, rgba(57,255,20,0.08), transparent 55%),
      linear-gradient(180deg, rgba(0,0,0,0.85), rgba(0,0,0,0.65));
    border:1px solid rgba(57,255,20,0.20);
    border-radius:12px;
    box-shadow: inset 0 0 0 1px rgba(57,255,20,0.07), inset 0 0 30px rgba(0,0,0,0.75);
    text-shadow: 0 0 10px rgba(57,255,20,0.10);
    position:relative;
  }
  .log::after{
    content:"SIG//NOISE";
    position:absolute;
    right:10px; bottom:10px;
    font-size:10px;
    color:rgba(0,183,255,0.55);
    text-shadow:0 0 10px rgba(0,183,255,0.25);
    letter-spacing:1px;
  }

  .small{font-size:11px;color:rgba(184,255,207,0.70);}

  /* SPINNER */
  .spinner{
    width:18px;height:18px;border-radius:999px;
    border:2px solid rgba(57,255,20,0.15);
    border-top-color:rgba(57,255,20,0.95);
    animation:spin 0.8s linear infinite;
    box-shadow: var(--glow);
  }

  /* PROGRESS */
  .progress{
    height:10px;border-radius:999px;
    background:rgba(0,0,0,0.70);
    border:1px solid rgba(57,255,20,0.18);
    overflow:hidden;
    box-shadow: inset 0 0 18px rgba(0,0,0,0.75);
  }
  .progress span{
    display:block;height:100%;
    background:linear-gradient(90deg, rgba(57,255,20,0.95), rgba(0,183,255,0.55), rgba(255,176,0,0.35));
    border-radius:999px;
    transition:width .2s ease;
    box-shadow: var(--glow-strong);
  }

  /* INVENTORY TILES */
  .item-grid{display:flex;flex-direction:column;gap:10px;}
  .inventory-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(96px,1fr));gap:8px;}
  .icon-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(96px,1fr));gap:8px;}
  .grid-span{grid-column:1 / -1;}

  .icon-tile{
    align-items:flex-start;
    justify-content:space-between;
    flex-direction:column;
    gap:6px;
    aspect-ratio:1;
    padding:8px 10px;
    min-height:0;
    text-align:left;

    border:1px solid rgba(57,255,20,0.18);
    background:
      linear-gradient(180deg, rgba(10,12,10,0.72), rgba(0,0,0,0.70));
    box-shadow: inset 0 0 0 1px rgba(57,255,20,0.06);
  }
  .icon-tile .icon-name{font-weight:800;font-size:11px;line-height:1.25; text-transform:uppercase; letter-spacing:0.7px;}
  .icon-tile .icon-meta{font-size:10px;color:rgba(184,255,207,0.68);}
  .icon-tile .icon-count{font-size:11px;color:rgba(184,255,207,0.72);}
  .icon-tile.selected{
    border-color:rgba(57,255,20,0.75);
    box-shadow: 0 0 0 1px rgba(57,255,20,0.35), var(--glow-strong);
    animation: selectPulse 1.4s infinite ease-in-out;
  }
  .icon-tile.empty{opacity:0.45;cursor:default;}
  .icon-tile.empty:hover{border-color:rgba(57,255,20,0.18);transform:none;box-shadow:none;}

  /* CHIPS */
  .chip{
    border:1px solid rgba(57,255,20,0.18);
    border-radius:999px;
    padding:2px 8px;
    font-size:10px;
    color:rgba(184,255,207,0.72);
    text-transform:uppercase;
    letter-spacing:0.7px;
  }
  .chip.common{color:rgba(184,255,207,0.75);}
  .chip.uncommon{color:rgba(57,255,20,0.95); text-shadow:0 0 10px rgba(57,255,20,0.18);}
  .chip.rare{color:rgba(0,183,255,0.95); text-shadow:0 0 12px rgba(0,183,255,0.18);}
  .chip.epic{color:rgba(255,176,0,0.95); text-shadow:0 0 12px rgba(255,176,0,0.18);}
  .chip.legendary{color:rgba(255,0,51,0.95); text-shadow:0 0 14px rgba(255,0,51,0.22); border-color:rgba(255,0,51,0.28);}

  /* COMMAND / HUD CARDS */
  .command-card, .op-card{
    border:1px solid rgba(57,255,20,0.18);
    border-radius:12px;
    padding:12px;
    background:
      linear-gradient(180deg, rgba(10,12,10,0.70), rgba(0,0,0,0.68));
    box-shadow: inset 0 0 0 1px rgba(57,255,20,0.06);
    display:flex;
    flex-direction:column;
    gap:10px;
    position:relative;
    overflow:hidden;
  }
  .command-card::before, .op-card::before{
    content:"";
    position:absolute; inset:0;
    background:radial-gradient(circle at 80% 0%, rgba(255,0,51,0.06), transparent 55%);
    pointer-events:none;
  }
  .command-title{font-size:13px;font-weight:900;letter-spacing:1.1px;text-transform:uppercase;}
  .command-hint{font-size:11px;color:rgba(184,255,207,0.68);}

  .combat-hud{
    border:1px solid rgba(255,0,51,0.22);
    border-radius:12px;
    padding:10px;
    background:linear-gradient(180deg, rgba(16,0,4,0.65), rgba(0,0,0,0.72));
    box-shadow: inset 0 0 0 1px rgba(255,0,51,0.08), var(--glow-red);
    display:flex;
    flex-direction:column;
    gap:8px;
  }
  .combat-hud .combat-title{
    font-weight:900;
    font-size:13px;
    letter-spacing:1px;
    text-transform:uppercase;
  }
  .combat-stats{
    display:grid;
    grid-template-columns:repeat(auto-fit,minmax(140px,1fr));
    gap:6px;
    font-size:12px;
    color:rgba(255,210,220,0.78);
  }
  .combat-stats b{color:#fff;}

  /* NAV / SCREENS */
  .screen-nav{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px;}
  .screen{display:none;flex-direction:column;gap:12px;}
  .screen.active{display:flex;}
  .tab-buttons button:disabled{opacity:0.35;cursor:not-allowed;border-style:dashed;}

  /* PAGER */
  .pager, .icon-pager{
    display:flex;flex-wrap:wrap;gap:8px;
    align-items:center;
    justify-content:space-between;
    margin-top:10px;
  }
  .pager .page-info, .icon-pager .page-info{
    font-size:11px;color:rgba(184,255,207,0.70);
    text-transform:uppercase;letter-spacing:0.7px;
  }
  .pager button, .icon-pager button{
    min-height:36px;
    padding:6px 10px;
    justify-content:center;
    text-align:center;
    flex:0 0 auto;
  }

  /* SCROLLBARS */
  *::-webkit-scrollbar{width:10px;height:10px;}
  *::-webkit-scrollbar-thumb{
    background:linear-gradient(180deg, rgba(57,255,20,0.35), rgba(255,0,51,0.18));
    border:1px solid rgba(57,255,20,0.18);
    border-radius:999px;
  }
  *::-webkit-scrollbar-track{background:rgba(0,0,0,0.65);}

  /* RESPONSIVE */
  @media(max-width:900px){
    header{position:static;}
    .two-col{grid-template-columns:1fr;}
    .tab-buttons button{flex:1 1 100%;}
    .inventory-layout{grid-template-columns:1fr;}
    #tab-field .inventory-layout{display:flex;flex-direction:column;}
    #tab-field #stashColumn{display:contents;}
    #tab-field #stashMarket.active{display:contents;}
    #tab-field #marketSubtitle{order:0;}
    #tab-field #marketBackpack{order:1;}
    #tab-field #stashCommandCard{order:2;}
    #tab-field #stashMarket .market-section{order:3;}
    #tab-field #stashActions{order:4;}
  }

  /* ANIMS */
  @keyframes spin{to{transform:rotate(360deg);}}
  @keyframes cursorBlink{50%{opacity:0;}}
  @keyframes sweep{
    0%{transform:translateX(-120%) skewX(-18deg);}
    100%{transform:translateX(320%) skewX(-18deg);}
  }
  @keyframes noiseDrift{
    0%{transform:translate3d(0,0,0);}
    25%{transform:translate3d(-1.2%,0.6%,0);}
    50%{transform:translate3d(0.8%,-0.9%,0);}
    75%{transform:translate3d(1.6%,0.2%,0);}
    100%{transform:translate3d(0,0,0);}
  }
  @keyframes crtFlicker{
    0%{filter:brightness(1) contrast(1.05) saturate(1.1);}
    1%{filter:brightness(1.06) contrast(1.08) saturate(1.15);}
    2%{filter:brightness(0.98) contrast(1.06) saturate(1.10);}
    3%{filter:brightness(1.02) contrast(1.05) saturate(1.12);}
    5%{filter:brightness(1) contrast(1.05) saturate(1.1);}
    30%{filter:brightness(1.01) contrast(1.06) saturate(1.12);}
    31%{filter:brightness(0.97) contrast(1.08) saturate(1.14);}
    32%{filter:brightness(1.03) contrast(1.06) saturate(1.11);}
    100%{filter:brightness(1) contrast(1.05) saturate(1.1);}
  }
  @keyframes selectPulse{
    0%{transform:translateY(0); filter:saturate(1.0);}
    50%{transform:translateY(-1px); filter:saturate(1.25);}
    100%{transform:translateY(0); filter:saturate(1.0);}
  }
</style>

</head>
<body>
  <div id="introModal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-card">
      <div class="command-title" id="introTitle">Welcome to Zero Lux</div>
      <div class="small" id="introMessage"></div>
      <div class="modal-actions" id="introActions"></div>
    </div>
  </div>
  <div id="app">
    <header>
      <div>
        <div class="title">Zones - fight, loot, survive. <span class="pill">inventory / looter / idle</span></div>
        <div class="tagline">Pick zones, run salvage loops, and sort rewards into gear, stash, or scrap.</div>
      </div>
      <div class="pill">Build #: 0.2b — inventory-focused loop</div>
    </header>

    <section class="panel">
      <div class="two-col">
        <div>
          <h3>Status Board</h3>
          <div id="stats"></div>
          <div class="meta" id="meta"></div>
        </div>
        <div class="rows">
          <div class="excursion-status" id="excursionStatus"></div>
          <div class="muted-box" id="tempoHint"></div>
        </div>
      </div>
    </section>

    <div class="tabs">
      <div class="tab-buttons">
        <button data-tab="hub" class="active">Operations</button>
        <button data-tab="inventory">Backpack</button>
        <button data-tab="field">Stash</button>
      </div>
      <div id="tab-hub" class="tab-content active">
        <div class="stack">
          <div class="screen-nav" id="screenNav">
            <button data-screen="main" class="active">Main Hub</button>
            <button data-screen="locations">Locations Hub</button>
          </div>
          <div id="screen-main" class="screen active">
            <section class="panel">
              <h3>Main Hub Deck</h3>
              <div class="rows">
                <div class="inline" style="justify-content:space-between;align-items:center;">
                  <div>
                    <p class="scene-title">Zero Lux Command Deck</p>
                    <p class="scene-desc">Synchronize with the field grid, then step into the locations hub to launch a raid.</p>
                  </div>
                  <span class="badge">Hub secure</span>
                </div>
                <div id="hubLock" class="muted-box"></div>
                <button id="enterLocations">Enter locations hub</button>
              </div>
            </section>
            <section class="panel">
              <h3>Idle Operations</h3>
              <div id="idleOps"></div>
            </section>
          </div>
          <div id="screen-locations" class="screen">
            <section class="panel">
              <h3>Transit Console</h3>
              <div class="spin-row" id="travelStatus"></div>
              <button class="btn-secondary" id="returnMain">Return to main hub</button>
            </section>
            <section class="panel">
              <h3>Zone Gates</h3>
              <div id="doors"></div>
              <div class="small" id="doorsHint">Loading expansions…</div>
            </section>
            <section class="panel">
              <div class="inline" style="justify-content:space-between;align-items:center;">
                <div>
                  <p class="scene-title" id="zoneTitle">Drift Yard</p>
                  <p class="scene-desc" id="zoneDesc">Low-risk salvage corridor. Ideal for stocking up on scrap and common gear.</p>
                </div>
                <span class="badge" id="zoneBadge">Low risk</span>
              </div>
              <div id="raidActions"></div>
            </section>
          </div>
          <div id="screen-mission" class="screen">
            <section class="panel">
              <h3>Mission Feed</h3>
              <div class="mission-card">
                <div class="mission-title" id="missionTitle">No mission active.</div>
                <div class="mission-meta" id="missionMeta"></div>
                <div class="progress" id="missionProgress"><span style="width:0%;"></span></div>
                <div class="small" id="missionLog"></div>
              <div class="mission-actions" id="missionActions"></div>
            </div>
            <div class="command-card" id="missionRewardsCard">
              <div class="command-title">Mission rewards</div>
              <div id="missionRewardHint" class="command-hint">Complete a mission to review rewards.</div>
              <div id="missionRewardList" class="item-grid"></div>
            </div>
          </section>
        </div>
        </div>
      </div>
      <div id="tab-inventory" class="tab-content">
        <section class="panel">
          <h3>Backpack & Loadout</h3>
          <div class="subtabs" id="inventoryNav">
            <button data-inv-screen="backpack" class="active">Backpack</button>
            <button data-inv-screen="loadout">Loadout</button>
            <button data-inv-screen="crafting">Crafting</button>
          </div>
          <div class="inventory-layout">
            <div>
              <div id="inventoryBackpack" class="subscreen active">
                <h4>Backpack Contents <span class="small" id="backpackCount"></span></h4>
                <div class="item-grid inventory-grid" id="inventory"></div>
              </div>
              <div id="inventoryLoadout" class="subscreen">
                <h4>Equipped Loadout <span class="small" id="loadoutCount"></span></h4>
                <div class="item-grid inventory-grid" id="equipment"></div>
              </div>
              <div id="inventoryCrafting" class="subscreen">
                <h4>Field Crafting</h4>
                <div class="command-hint">Combine junk stacks into quick survival tools.</div>
                <div id="crafting"></div>
              </div>
            </div>
            <div class="command-card">
              <div class="command-title">Selected item</div>
              <div id="itemDetail" class="command-hint">Select gear to view stats, uses, and actions.</div>
              <div class="action-grid" id="itemActions"></div>
            </div>
          </div>
          <div class="small" id="codex"></div>
        </section>
      </div>
      <div id="tab-field" class="tab-content">
        <section class="panel">
          <h3 id="stashTitle">Stash Vault</h3>
          <div class="subtabs" id="stashNav">
            <button data-stash-screen="vault" class="active">Vault</button>
            <button data-stash-screen="market">Shop</button>
          </div>
          <div class="inventory-layout">
            <div id="stashColumn">
              <div id="stashVault" class="subscreen active">
                <h4 id="stashSubtitle">Vault Inventory <span class="small" id="stashCount"></span></h4>
                <div id="stash"></div>
              </div>
              <div id="stashMarket" class="subscreen">
                <h4 id="marketSubtitle">Backpack Inventory <span class="small" id="marketBackpackCount"></span></h4>
                <div id="marketBackpack"></div>
                <div class="market-section" id="marketSection">
                  <h4>Vendor stock</h4>
                  <div class="command-hint" id="marketHint">Visit a shop in your current location to access vendors.</div>
                  <div id="marketInventory" class="market-grid"></div>
                </div>
              </div>
            </div>
            <div class="command-card" id="stashCommandCard">
              <div class="command-title" id="stashCommandTitle">Vault Command Card</div>
              <div id="stashDetail" class="command-hint">Select stash items to transfer, break down, or sell.</div>
              <div class="action-grid" id="stashItemActions"></div>
            </div>
            <div id="stashActions" class="stack"></div>
          </div>
          <p class="small">Move rewards into long-term storage, or liquidate overflow for credits.</p>
        </section>
      </div>
    </div>
  </div>

  <script>
    /* ================= STATE & CONSTANTS ================= */
    const SAVE_KEY='zeroLuxSave';
    const SAVE_VERSION=1;
    const createDefaultState=()=>({
      hp:92,maxHp:100,
      stamina:90,maxStamina:100,
      morale:62,maxMorale:100,
      hunger:15,maxHunger:100,
      thirst:20,maxThirst:100,
      energy:72,maxEnergy:100,
      rads:0,
      radShield:0,
      radShieldUntil:null,
      bodyTemp:98,maxBodyTemp:104,
      scrap:6,
      credits:50,
      keys:1,
      level:1,xp:0,nextLevelXp:80,
      day:1,timeMinutes:6*60,
      backpackLimit:0,
      stashLimit:40,
      stashUpgradeLevel:0,
      craftingPage:0,
      inventoryPage:0,
      stashPage:0,
      loadoutPage:0,
      marketPage:0,
      inventory:["rusty flashlight","ration bar","scrap wiring"],
      equipped:['basic backpack'],
      codex:["Hub online. Reward bays clear."],
      stash:{name:'Vault Stash',items:[]},
      marketAccess:{active:false,zoneId:null},
      idleOps:{active:false,id:null,startedAt:null,durationMs:0,etaMinutes:0,completed:false,statusMessage:'',rewards:[]},
      flags:new Set(),
      zone:{id:'drift-yard',name:'Drift Yard',risk:'low',desc:'Low-risk salvage corridor. Ideal for stocking up on scrap and common gear.',sceneId:null},
      screen:'main',
      travel:{active:false,endsAt:null,target:null},
      mission:{active:false,type:null,raid:null,startedAt:null,endsAt:null,completed:false,success:null,summary:'',rewards:[],statusMessage:'',location:null,fleeing:false,fleeEndsAt:null,pendingResolution:null,xpReward:0,rewardEffects:{success:'',fail:''},questMeta:null,combat:null,sceneTarget:null},
      inventoryScreen:'backpack',
      stashScreen:'vault',
      selected:{source:null,item:null}
    });
    const hydrateState=(saved)=>{
      const base=createDefaultState();
      if(!saved || typeof saved!=='object') return base;
      const merged={...base,...saved};
      merged.flags=new Set(saved.flags || []);
      merged.stash={...base.stash,...(saved.stash||{})};
      merged.marketAccess={...base.marketAccess,...(saved.marketAccess||{})};
      merged.idleOps={...base.idleOps,...(saved.idleOps||{})};
      merged.zone={...base.zone,...(saved.zone||{})};
      merged.travel={...base.travel,...(saved.travel||{})};
      merged.mission={...base.mission,...(saved.mission||{})};
      merged.selected={...base.selected,...(saved.selected||{})};
      const travelEndsAt=Number(merged.travel.endsAt);
      merged.travel.endsAt=Number.isFinite(travelEndsAt) ? travelEndsAt : null;
      const missionStartedAt=Number(merged.mission.startedAt);
      const missionEndsAt=Number(merged.mission.endsAt);
      merged.mission.startedAt=Number.isFinite(missionStartedAt) ? missionStartedAt : null;
      merged.mission.endsAt=Number.isFinite(missionEndsAt) ? missionEndsAt : null;
      const idleStartedAt=Number(merged.idleOps.startedAt);
      const idleDurationMs=Number(merged.idleOps.durationMs);
      merged.idleOps.startedAt=Number.isFinite(idleStartedAt) ? idleStartedAt : null;
      merged.idleOps.durationMs=Number.isFinite(idleDurationMs) ? idleDurationMs : 0;
      merged.radShield=Number.isFinite(Number(merged.radShield)) ? Number(merged.radShield) : 0;
      const radShieldUntil=Number(merged.radShieldUntil);
      merged.radShieldUntil=Number.isFinite(radShieldUntil) ? radShieldUntil : null;
      return merged;
    };
    const loadSavedState=()=>{
      try{
        const raw=localStorage.getItem(SAVE_KEY);
        if(!raw) return null;
        return hydrateState(JSON.parse(raw));
      }catch(err){
        console.warn('Save load failed.',err);
        return null;
      }
    };
    let pendingSave=null;
    let lastSaveAt=0;
    const saveGame=()=>{
      try{
        const payload={...state,flags:Array.from(state.flags||[]),saveVersion:SAVE_VERSION};
        localStorage.setItem(SAVE_KEY,JSON.stringify(payload));
        lastSaveAt=Date.now();
      }catch(err){
        console.warn('Save failed.',err);
      }
    };
    const savedState=loadSavedState();
    let state=createDefaultState();
    let allowAutosave=!savedState;
    const MISSION_OVERRUN_MULTIPLIER=2;
    const SAVE_DEBOUNCE_MS=1500;
    const SAVE_MIN_INTERVAL_MS=8000;
    const queueSave=({force=false}={})=>{
      if(!allowAutosave) return;
      if(force){
        if(pendingSave){
          clearTimeout(pendingSave);
          pendingSave=null;
        }
        saveGame();
        return;
      }
      if(pendingSave) return;
      const now=Date.now();
      const elapsed=now-lastSaveAt;
      const delay=Math.max(0,elapsed>=SAVE_MIN_INTERVAL_MS ? SAVE_DEBOUNCE_MS : SAVE_MIN_INTERVAL_MS-elapsed);
      pendingSave=setTimeout(()=>{
        pendingSave=null;
        saveGame();
      },delay);
    };

    const ITEM_CATALOG={
      'basic backpack':{type:'armor',slot:'backpack',rarity:'common',value:6,mods:{carryBonus:6,insulation:0.1}},
      'rusty flashlight':{type:'tool',slot:'tool',rarity:'common',value:6,mods:{riskMod:-0.02}},
      'cargo pants':{type:'armor',slot:'pants',rarity:'common',value:7,mods:{insulation:0.4},breakdown:{items:{'cloth scraps':4}}},
      'field backpack':{type:'armor',slot:'backpack',rarity:'uncommon',value:14,mods:{carryBonus:9,insulation:0.2}},
      'flare':{type:'tool',slot:'tool',rarity:'uncommon',value:10,mods:{lootBonus:0.04}},
      'patch kit':{type:'tool',slot:'tool',rarity:'uncommon',value:12,mods:{riskMod:-0.04}},
      'patch-kit':{type:'tool',slot:'tool',rarity:'uncommon',value:12,mods:{riskMod:-0.04}},
      'utility coat':{type:'armor',slot:'chest',rarity:'uncommon',value:12,mods:{staminaBonus:1,insulation:0.8},breakdown:{items:{'cloth scraps':6}}},
      'microcell':{type:'tool',slot:'tool',rarity:'rare',value:22,mods:{idleSpeed:0.15,energyRegen:1,staminaBonus:2}},
      'rigged backpack':{type:'armor',slot:'backpack',rarity:'rare',value:24,mods:{carryBonus:12,insulation:0.3}},
      'bandage':{type:'consumable',rarity:'common',value:4,effect:'hp+8'},
      'ration bar':{type:'consumable',rarity:'common',value:3,effect:'hunger-12,morale+2'},
      'water flask':{type:'consumable',rarity:'common',value:4,effect:'thirst-12'},
      'spark tonic':{type:'consumable',rarity:'uncommon',value:8,effect:'energy+18,stamina+6'},
      'scrap wiring':{type:'junk',rarity:'common',value:2,salvage:2,stackable:true},
      'scrap bundle':{type:'junk',rarity:'common',value:1,salvage:1,stackable:true},
      'wire spool':{type:'junk',rarity:'common',value:2,salvage:2,stackable:true},
      'cloth scraps':{type:'junk',rarity:'common',value:1,salvage:1,stackable:true},
      'plastic shards':{type:'junk',rarity:'common',value:1,salvage:1,stackable:true},
      'electronics bits':{type:'junk',rarity:'common',value:3,salvage:2,stackable:true},
      'old coin':{type:'junk',rarity:'uncommon',value:6,salvage:1},
      'lockbox key':{type:'key',rarity:'rare',value:18},
      'relay crystal':{type:'junk',rarity:'rare',value:20,salvage:6},
      'drone core':{type:'tool',slot:'tool',rarity:'epic',value:32,mods:{lootBonus:0.08,energyRegen:2}},
      'fusion core shard':{type:'junk',rarity:'legendary',value:60,salvage:12},
      'scrapboss helm':{type:'armor',slot:'helmet',rarity:'legendary',value:85,mods:{moraleBonus:4,insulation:0.6},breakdown:{items:{'cloth scraps':5,'scrap wiring':2}}},
      'warlord helm':{type:'armor',slot:'helmet',rarity:'legendary',value:85,mods:{moraleBonus:4,insulation:0.6},breakdown:{items:{'cloth scraps':4,'scrap wiring':2}}},
      'safehouse warden coat':{type:'armor',slot:'chest',rarity:'legendary',value:90,mods:{staminaBonus:4,insulation:1}},
      'facility command badge':{type:'tool',slot:'tool',rarity:'legendary',value:95,mods:{lootBonus:0.12,energyRegen:2}},
      'riot jacket':{type:'armor',slot:'chest',rarity:'legendary',value:88,mods:{insulation:0.9,moraleBonus:2},breakdown:{items:{'cloth scraps':6,'plastic shards':2}}},
      'field rations':{type:'consumable',rarity:'common',value:5,effect:'hunger-16,stamina+4'},
      'water canister':{type:'consumable',rarity:'common',value:5,effect:'thirst-18,temp-1'},
      'painkillers':{type:'consumable',rarity:'uncommon',value:11,effect:'hp+12,morale+2'},
      'glowing herbs':{type:'consumable',rarity:'uncommon',value:10,effect:'rads-4,temp+1'},
      'military rations':{type:'consumable',rarity:'uncommon',value:12,effect:'hunger-22,stamina+6'},
      'coil battery':{type:'tool',slot:'tool',rarity:'uncommon',value:13,mods:{energyRegen:1}},
      'spare filter':{type:'tool',slot:'tool',rarity:'uncommon',value:12,mods:{riskMod:-0.03}},
      'copper wire':{type:'junk',rarity:'common',value:4,salvage:3,stackable:true},
      'reactor shard':{type:'junk',rarity:'rare',value:34,salvage:10},
      'exo brace':{type:'armor',slot:'gloves',rarity:'rare',value:28,mods:{staminaBonus:4,insulation:0.4}},
      'scavenger boots':{type:'armor',slot:'shoes',rarity:'uncommon',value:16,mods:{staminaBonus:2},breakdown:{items:{'cloth scraps':4,'scrap bundle':1}}},
      'underground map':{type:'tool',slot:'tool',rarity:'uncommon',value:15,mods:{riskMod:-0.05,lootBonus:0.03}},
      'data cartridge':{type:'tool',slot:'tool',rarity:'rare',value:26,mods:{lootBonus:0.06}},
      'signal wristband':{type:'tool',slot:'tool',rarity:'uncommon',value:14,mods:{moraleBonus:2}},
      'riot shield':{type:'weapon',slot:'weapon',rarity:'rare',value:30,mods:{riskMod:-0.06,insulation:0.5}},
      'flare paint':{type:'tool',slot:'tool',rarity:'uncommon',value:13,mods:{lootBonus:0.05}},
      'flashbang':{type:'tool',slot:'tool',rarity:'rare',value:24,mods:{combatBonus:5}},
      'foam canister':{type:'tool',slot:'tool',rarity:'uncommon',value:15,mods:{combatBonus:3,riskMod:-0.02}},
      'viral clip drive':{type:'junk',rarity:'rare',value:28,salvage:7},
      'limited hoodie':{type:'armor',slot:'chest',rarity:'rare',value:27,mods:{moraleBonus:3,insulation:0.6},breakdown:{items:{'cloth scraps':5}}},
      'payload crate':{type:'junk',rarity:'uncommon',value:18,salvage:5},
      'stun baton':{type:'weapon',slot:'weapon',rarity:'rare',value:29,mods:{combatBonus:6}},
      'mystery supply':{type:'junk',rarity:'rare',value:25,salvage:6},
      'salvaged tech':{type:'junk',rarity:'rare',value:27,salvage:8},
      'shock gel':{type:'consumable',rarity:'uncommon',value:12,effect:'hp+10,temp+1'},
      'overclock chip':{type:'tool',slot:'tool',rarity:'rare',value:31,mods:{energyRegen:2,combatBonus:4}},
      'insulated cloak':{type:'armor',slot:'chest',rarity:'rare',value:26,mods:{insulation:1.1,riskMod:-0.02},breakdown:{items:{'cloth scraps':6}}},
      'scavenger harness':{type:'armor',slot:'chest',rarity:'uncommon',value:17,mods:{staminaBonus:2}},
      'hardened canteen':{type:'consumable',rarity:'uncommon',value:9,effect:'thirst-16,stamina+3'},
      'ember ration':{type:'consumable',rarity:'common',value:6,effect:'hunger-14,temp+2'},
      'signal jammer':{type:'tool',slot:'tool',rarity:'rare',value:33,mods:{riskMod:-0.07,combatBonus:2}},

      /* base items */
      'pocket pack':{type:'armor',slot:'backpack',rarity:'common',value:18,mods:{carryBonus:7}},
      'scout daypack':{type:'armor',slot:'backpack',rarity:'uncommon',value:26,mods:{carryBonus:8}},
      'salvage tote':{type:'armor',slot:'backpack',rarity:'uncommon',value:24,mods:{carryBonus:9}},
      'expedition frame pack':{type:'armor',slot:'backpack',rarity:'rare',value:44,mods:{carryBonus:14}},
      'jury-rigged blade':{type:'weapon',slot:'weapon',rarity:'common',value:9,mods:{combatBonus:3}},
      'scrap spear':{type:'weapon',slot:'weapon',rarity:'uncommon',value:18,mods:{combatBonus:5,lootBonus:0.01}},
      'pipe rifle':{type:'weapon',slot:'weapon',rarity:'rare',value:32,mods:{combatBonus:7,riskMod:-0.01}},
      'compact medkit':{type:'consumable',rarity:'uncommon',value:14,effect:'hp+18'},
      'filtered water pack':{type:'consumable',rarity:'uncommon',value:13,effect:'thirst-20,rads-2'},
      'anti-rad serum':{type:'consumable',rarity:'rare',value:32,effect:'rads-40,radshield+25'},
      'morale patch':{type:'consumable',rarity:'common',value:7,effect:'morale+8,stamina+2'},

      /* iron ward */
      'ledger-etched compass':{type:'tool',slot:'tool',rarity:'uncommon',value:19,mods:{riskMod:-0.04,lootBonus:0.02}},
      'clocktower chime':{type:'junk',rarity:'uncommon',value:16,salvage:4},
      'iron ward seals':{type:'junk',rarity:'common',value:3,salvage:2,stackable:true},
      'market shock knife':{type:'weapon',slot:'weapon',rarity:'rare',value:34,mods:{combatBonus:6,lootBonus:0.02}},
      'tarpaulin roll':{type:'junk',rarity:'common',value:4,salvage:2,stackable:true},

      /* cold shelter */
      'thermal wrap':{type:'consumable',rarity:'common',value:6,effect:'temp+3,stamina+4'},
      'bunker schematics':{type:'tool',slot:'tool',rarity:'uncommon',value:21,mods:{riskMod:-0.02}},
      'lantern oil':{type:'junk',rarity:'common',value:2,salvage:1,stackable:true},
      'stabilizer brace':{type:'armor',slot:'gloves',rarity:'uncommon',value:20,mods:{staminaBonus:3,insulation:0.3}},
      'cache latch':{type:'junk',rarity:'uncommon',value:10,salvage:3},

      /* blackwood expanse */
      'spore lantern':{type:'tool',slot:'tool',rarity:'uncommon',value:22,mods:{riskMod:-0.03,lootBonus:0.03}},
      'rad moss poultice':{type:'consumable',rarity:'uncommon',value:15,effect:'hp+10,rads-5,temp+1'},
      'hardened bark plate':{type:'armor',slot:'chest',rarity:'uncommon',value:18,mods:{insulation:0.7,riskMod:-0.02}},
      'monsoon canteen':{type:'consumable',rarity:'rare',value:23,effect:'thirst-24,temp+1'},
      'feral talon':{type:'junk',rarity:'rare',value:24,salvage:7},

      /* downtown portland */
      'floodgate keycard':{type:'key',rarity:'rare',value:22},
      'signal flare rack':{type:'tool',slot:'tool',rarity:'uncommon',value:20,mods:{lootBonus:0.05,moraleBonus:1}},
      'riot-line tape':{type:'junk',rarity:'common',value:3,salvage:2,stackable:true},
      'bridge-runner pack':{type:'armor',slot:'backpack',rarity:'uncommon',value:28,mods:{carryBonus:10}},
      'arc pistol':{type:'weapon',slot:'weapon',rarity:'rare',value:38,mods:{combatBonus:8,energyRegen:1}}
    };

    const LOOT_BY_RARITY={
      common:['bandage','ration bar','water flask','scrap wiring','scrap bundle','wire spool','cloth scraps','plastic shards','electronics bits','rusty flashlight','cargo pants','field rations','water canister','copper wire','ember ration','morale patch','pocket pack','jury-rigged blade','iron ward seals','tarpaulin roll','lantern oil','thermal wrap','riot-line tape'],
      uncommon:['flare','patch kit','patch-kit','old coin','spark tonic','utility coat','field backpack','coil battery','spare filter','scavenger boots','underground map','signal wristband','flare paint','foam canister','scavenger harness','hardened canteen','shock gel','salvage tote','scout daypack','scrap spear','compact medkit','filtered water pack','ledger-etched compass','clocktower chime','bunker schematics','stabilizer brace','cache latch','spore lantern','rad moss poultice','hardened bark plate','signal flare rack','bridge-runner pack'],
      rare:['microcell','lockbox key','relay crystal','rigged backpack','exo brace','reactor shard','data cartridge','riot shield','flashbang','limited hoodie','stun baton','mystery supply','salvaged tech','overclock chip','insulated cloak','signal jammer','viral clip drive','expedition frame pack','pipe rifle','market shock knife','monsoon canteen','feral talon','floodgate keycard','arc pistol','anti-rad serum'],
      epic:['drone core'],
      legendary:['fusion core shard','scrapboss helm','warlord helm','safehouse warden coat','facility command badge','riot jacket']
    };

    const RAID_TEMPLATES=[
      {id:'quick',label:'Quick Grab',desc:'Fast sweep for low-tier gear.',time:6,energy:8,loot:2,risk:'low'},
      {id:'deep',label:'Deep Sweep',desc:'Longer push with higher-value crates.',time:12,energy:14,loot:3,risk:'medium'},
      {id:'hazard',label:'Hazard Drift',desc:'Pressurized route for rare tech.',time:16,energy:18,loot:4,risk:'high'},
      {id:'vault',label:'Lockbox Crack',desc:'Spend a key to crack sealed cache.',time:10,energy:10,loot:3,risk:'high',key:1}
    ];

    const ACTION_TIMES={camp:10};
    const RAD_SHIELD_DURATION_MINUTES=12*60;
    const RAD_DANGER_THRESHOLD=20;
    const riskTable={low:0.08,medium:0.2,high:0.32,deadly:0.45};
    const riskRank={low:1,medium:2,high:3,deadly:4};
    const expansions={};
    const EXPANSION_MANIFEST=[
      {id:'town',name:'Titan Mart Megastore',file:'expansions/town.txt'},
      {id:'safehouse',name:'Harbor Barter Shelter',file:'expansions/safehouse.txt'},
      {id:'forest',name:'Blacksite Service Annex',file:'expansions/forest.txt'},
      {id:'portland_slums',name:'Rubbletide Shanty Row',file:'expansions/portland_slums.txt'},
      {id:'corporate_complex',name:'Arclight Corporate High-Rise',file:'expansions/corporate_complex.txt'},
      {id:'metro_ganglands',name:'Metro Ganglands',file:'expansions/metro_ganglands.txt'}
    ];
    const EMBEDDED_EXPANSIONS={
      town:`@expansion
id:town
name:Titan Mart Megastore
summary:A gutted megagrocer with dark aisles, smashed coolers, and a loading dock turned into a barter line. Shelves still hide sealed cases.
shop:true

@door
label:Titan Mart Loading Dock
hint:food stock, cold storage, bulk salvage
note:You squeeze past tipped shopping carts and into the cold shadow of the loading dock.
target:loading-dock

@scene loading-dock
title:Loading Dock
desc:Pallets of shrink-wrapped goods are split open and tagged for barter. The air smells like old flour and ozone.
tags:Grocer / Trade
option:Check the freezer aisle => loading-dock | risk:medium | time:7 | reward:cold stock | success:item:field rations,item:water canister,flag:titan-freezer,log:You pry a sealed crate of emergency meals from the ice. | fail:temp-2,log:The coolant burns your fingers.
option:Crack the manager cage => loading-dock | risk:high | time:6 | reward:security cache | success:item:riot-line tape,item:pipe rifle,flag:titan-cage,log:A lockbox still holds a serviceable rifle and straps. | fail:hp-6,log:The cage door slams on your shoulder.

@mission
id:scavenger-run
label:Grocer stock run
desc:Quick sweep across the aisles for sealed stock.
risk:medium
time:9
energy:12
loot:2
lootType:sealed stock

@mission
id:equipment-run-2
label:Dangerous stockroom loot run
desc:Push into the locked stockroom for intact kits and tools.
risk:high
time:14
energy:18
loot:3
lootType:bulk supplies

@quest
id:frontline-relay
title:Recover the shipment manifest
desc:Locate the master manifest kiosk so the shelter can track remaining stock.
risk:high
time:12
energy:16
loot:3
lootType:stock ledger
reward:manifest recovery
success:item:signal flare rack,item:riot shield,credits+18,flag:frontline-relay
fail:hp-10,morale-4
flag:frontline-relay
once:true

@quest
id:frontline-medic
title:Escort the barter runner
desc:Keep a runner alive long enough to haul an overloaded cart back to safety.
risk:medium
time:10
energy:14
loot:2
lootType:trade kits
reward:barter run
success:item:bandage,item:morale patch,credits+12,flag:frontline-medic
fail:hp-6,morale-5
flag:frontline-medic
once:true`,
      safehouse:`@expansion
id:safehouse
name:Harbor Barter Shelter
summary:A fortified shelter wedged into a river pier. Bunks, a barter counter, and a hand-painted notice wall keep the community glued together.
shop:true

@door
label:Harbor Shelter Gate
hint:rest, barter, recovery
note:The gate locks behind you. Warm light and stew steam bleed into the corridor.
target:commons

@scene commons
title:Harbor Commons
desc:Rows of bunks glow with heat lamps. A barter counter sits beside a wall of hand-scrawled schedules.
tags:Safe / Barter
option:Rest in the bunks => commons | risk:low | time:6 | reward:rested | success:hp+10,stamina+12,morale+6,log:The bunk warmth sinks into your bones. | fail:morale-2,log:Sleep won't come tonight.
option:Boil a meal at the heater => commons | risk:low | time:5 | reward:hot meal | success:hunger-18,thirst-6,temp+2,log:Steam and salt do the job. | fail:hunger-4,log:The burner sputters out.
option:Update the shelter logbook => commons | risk:low | time:4 | reward:morale boost | success:morale+5,flag:horizon-log,log:New names go on the board. Old names come off. | fail:morale-2,log:The pen runs dry.

@quest
id:shelter-vent
title:Seal the intake vents
desc:Patch a cracked intake valve before the next storm rolls through.
risk:medium
time:8
energy:10
loot:2
lootType:shelter supplies
reward:vent patches
success:item:thermal wrap,item:spare filter,credits+10,flag:shelter-vent
fail:temp-3,morale-4
flag:shelter-vent
once:true

@quest
id:shelter-reserve
title:Audit the reserve lockers
desc:Count and re-tag the emergency lockers in the lower hall before trade night.
risk:low
time:7
energy:8
loot:1
lootType:stored rations
reward:bonus rations
success:item:ration bar,item:water flask,credits+6,flag:shelter-reserve
fail:morale-2
flag:shelter-reserve
once:true`,
      forest:`@expansion
id:forest
name:Blacksite Service Annex
summary:A shuttered government annex with rusted blast doors, silent terminals, and warning stripes still intact.
shop:true

@door
label:Annex Checkpoint
hint:classified caches, facility tech
note:Warning stripes fade under your boots as the checkpoint scanners wheeze awake.
target:control-hall

@scene control-hall
title:Control Hall
desc:Desks and terminals sit frozen under dust. A backup generator hums somewhere below.
tags:Government / Hazard
option:Stabilize the power feed => control-hall | risk:medium | time:8 | reward:facility access | success:credits+10,flag:clinic-power,log:Control lights hum back to steady. | fail:temp-2,log:The breaker snaps.
option:Scan the access ledger => control-hall | risk:high | time:7 | reward:classified intel | success:item:compact medkit,flag:clinic-ledger,log:A sealed drawer pops with the right code. | fail:hp-6,log:An alarm shrieks and then dies.

@mission
id:medical-run
label:Dangerous annex loot run
desc:Push into the restricted wing for trauma supplies and tech.
risk:high
time:12
energy:16
loot:3
lootType:classified crates

@mission
id:item-run
label:Dangerous systems loot run
desc:Raid the sealed lockers for high-value gear.
risk:high
time:11
energy:15
loot:2
lootType:facility gear

@quest
id:clinic-serum
title:Retrieve the sealed payload
desc:A sealed payload canister is still logged in the vault freezer.
risk:high
time:13
energy:18
loot:3
lootType:facility cache
reward:sealed payload
success:item:filtered water pack,item:painkillers,credits+20,flag:clinic-serum
fail:hp-8,morale-4
flag:clinic-serum
once:true

@quest
id:clinic-evac
title:Evacuate the survey drone
desc:Bring the intact survey drone back online and escort it out.
risk:medium
time:10
energy:14
loot:2
lootType:facility supplies
reward:drone kit
success:item:spark tonic,item:bandage,credits+14,flag:clinic-evac
fail:hp-6,morale-3
flag:clinic-evac
once:true`,
      portland_slums:`@expansion
id:portland_slums
name:Rubbletide Shanty Row
summary:A dangerous shanty sprawl of tarp roofs, rope bridges, and rusted containers hanging over dark water.
shop:true

@door
label:Rubbletide Access
hint:shanty caches, risky barter runs
note:You step onto a wobbling plank bridge as the shanty fires crackle below.
target:tarp-lane

@scene tarp-lane
title:Tarp Lane
desc:Tarp roofs sag under rainwater. Rope bridges sway between stacked containers.
tags:Shanty / Dangerous
option:Patch a rope bridge => tarp-lane | risk:medium | time:6 | reward:route salvage | success:item:field rations,flag:grain-pallet,log:You lash down a crate of edible packs. | fail:hunger+6,log:The bridge lurches under your weight.
option:Follow the smoke trail => tarp-lane | risk:high | time:8 | reward:cache clue | success:item:ember ration,flag:grain-trail,log:A trail of cooking smoke leads to a sealed cache. | fail:hp-5,log:A plank snaps and drops you hard.

@mission
id:random-run
label:Dangerous shanty loot run
desc:Navigate the shanty alleys for whatever the tides left.
risk:high
time:12
energy:16
loot:3
lootType:mixed salvage

@mission
id:food-run
label:Dangerous barter run
desc:Cut through the shanty market for preserved rations.
risk:high
time:10
energy:15
loot:3
lootType:barter stores

@quest
id:grain-silo
title:Crack the lockbox shanty
desc:Open the locked container before the gang returns.
risk:high
time:13
energy:18
loot:4
lootType:barter stores
reward:lockbox haul
success:item:field rations,item:water canister,credits+18,flag:grain-silo
fail:hp-8,hunger+8
flag:grain-silo
once:true

@quest
id:grain-barge
title:Salvage the barge cache
desc:A barge of preserved goods sits wedged under the bridge.
risk:medium
time:9
energy:12
loot:2
lootType:food crates
reward:barge haul
success:item:ember ration,item:hardened canteen,credits+12,flag:grain-barge
fail:hp-6,morale-3
flag:grain-barge
once:true`
      ,
      corporate_complex:`@expansion
id:corporate_complex
name:Arclight Corporate High-Rise
summary:A corporate complex high-rise of shattered glass and cold marble, crawling with patrols guarding premium caches and medical bays.
minLevel:5
shop:false

@door
label:Arclight Service Lift
hint:executive armory, med bays, high-value loot
note:Elevator cables groan as you slip into the tower's service lift.
target:executive-lobby

@scene executive-lobby
title:Executive Lobby
desc:Security kiosks blink in the marble atrium. The air reeks of ozone and spilled antiseptic.
tags:Corporate / Combat
option:Force the security vault => executive-lobby | risk:high | time:8 | reward:weapon cache | success:item:arc pistol,item:riot shield,log:You pry open a vault drawer stuffed with combat gear. | fail:hp-8,morale-4,log:A stunner arc jumps the panel.
option:Clear the triage wing => executive-lobby | risk:medium | time:7 | reward:medical supplies | success:item:compact medkit,item:painkillers,log:You strip the triage lockers for intact kits. | fail:hp-4,temp-1,log:A smashed vial cuts your hand.

@mission
id:executive-run
label:High-rise weapons sweep
desc:Room-to-room sweep for intact weapon crates.
risk:high
time:14
energy:18
loot:4
lootType:weapon cases

@mission
id:med-vault-run
label:High-rise medical sweep
desc:Secure trauma supplies from sealed clinics.
risk:medium
time:12
energy:15
loot:3
lootType:medical supplies

@quest
id:penthouse-raid
title:Crack the penthouse armory
desc:The executive armory still registers sealed. Punch through and haul the best weapons out.
risk:high
time:15
energy:20
loot:4
lootType:armory cache
reward:armory haul
success:item:arc pistol,item:market shock knife,credits+24,flag:penthouse-raid
fail:hp-10,morale-6
flag:penthouse-raid
once:true

@quest
id:triage-cache
title:Secure the triage cabinet
desc:Pull the locked medical cabinet before patrols return.
risk:medium
time:11
energy:14
loot:3
lootType:medical packs
reward:triage cache
success:item:anti-rad serum,item:compact medkit,credits+16,flag:triage-cache
fail:hp-6,temp-2
flag:triage-cache
once:true`,
      metro_ganglands:`@expansion
id:metro_ganglands
name:Metro Ganglands
summary:An underground maze of tagged tunnels, clattering trains, and gang lookout nests trading in mid-tier gear.
unlockCost:30
shop:true

@door
label:Ganglands Turnstile
hint:equipment runs, mid-tier weapons, telecom job
note:Graffiti warnings blur past as the ganglands open into the rail tunnels.
target:concourse

@scene concourse
title:Ganglands Concourse
desc:Abandoned ticket booths are now gang checkpoints. The rails hum with stolen power.
tags:Metro / Hostile
option:Trade for a safe route => concourse | risk:low | time:6 | reward:safe passage | success:credits-6,log:You pay a toll and earn a quiet route. | fail:hp-4,log:The lookout spots you anyway.
option:Slip into the tool cage => concourse | risk:medium | time:7 | reward:gear cache | success:item:coil battery,item:scavenger harness,log:You scoop up toolkits and harnesses. | fail:hp-5,morale-2,log:A sentry catches you climbing out.

@mission
id:gangland-supply
label:Gangland supply pull
desc:Run the tunnels for equipment bundles and mid-tier weapons.
risk:medium
time:11
energy:14
loot:3
lootType:equipment crates

@mission
id:tunnel-sweep
label:Tunnel gear sweep
desc:Search maintenance shafts for tools and clothing.
risk:medium
time:10
energy:13
loot:3
lootType:utility caches

@quest
id:metro-telecom
title:Reconnect the telecom relay
desc:Splice the shattered fiber lines and bring the relay back online.
risk:medium
time:12
energy:16
loot:3
lootType:signal crates
reward:telecom link
success:item:data cartridge,credits+18,flag:metro-telecom,log:The relay hums to life. New stock opens across the ganglands.
fail:hp-6,morale-4
flag:metro-telecom
once:true`
    };
    let expansionsExpected=0;
    let expansionsLoaded=0;
    let expansionsAttempted=0;
    const idleOperations=[
      {id:'salvage',label:'Drone salvage',desc:'Remote drones bring back scrap and junk.',duration:3,cost:{credits:8},reward:'scrap+3,item:scrap wiring'},
      {id:'survey',label:'Cartography sweep',desc:'Low-risk sweep for new routes and caches.',duration:2,cost:{credits:5},reward:'credits+4,item:old coin'},
      {id:'resupply',label:'Supply errand',desc:'Courier route for field medicine.',duration:4,cost:{credits:10,scrap:1},reward:'item:bandage,item:water flask'}
    ];

    const IDLE_DURATION_MULTIPLIER=1;
    const TIME_DISPLAY_MULTIPLIER=4;
    const formatMinutesPrecise=(minutes)=>minutes>=1?`${minutes.toFixed(1)} min`:`${Math.max(5,Math.round(minutes*60))}s`;
    const getIdleDurationMinutes=(op,gearMods=getGearMods())=>{
      const base=op.duration*IDLE_DURATION_MULTIPLIER;
      const adjusted=base*(1-(gearMods.idleSpeed||0));
      return clamp(adjusted,1,5);
    };

    const CRAFTING_PAGE_SIZE=4;
    const MARKET_PAGE_SIZE=6;
    const CRAFTING_RECIPES=[
      {id:'bandage',label:'Bandage',desc:'Quick field wrap to stabilize wounds.',cost:{'cloth scraps':5}},
      {id:'water flask',label:'Water flask',desc:'Patch together a reusable hydration pouch.',cost:{'plastic shards':6,'cloth scraps':3}},
      {id:'ration bar',label:'Ration bar',desc:'Compress salvageable nutrients into a meal.',cost:{'scrap bundle':7,'plastic shards':2}},
      {id:'patch kit',label:'Patch kit',desc:'Bundle wire and electronics into repair gear.',cost:{'wire spool':8,'electronics bits':4}},
      {id:'morale patch',label:'Morale patch',desc:'Stitch a bright patch that steadies nerves.',cost:{'cloth scraps':4,'plastic shards':2}},
      {id:'compact medkit',label:'Compact medkit',desc:'Upgrade basic wraps into a full trauma pack.',cost:{'bandage':2,'cloth scraps':6,'electronics bits':3}},
      {id:'filtered water pack',label:'Filtered water pack',desc:'Pair a flask with a fresh filter for clean water.',cost:{'water flask':1,'spare filter':1,'plastic shards':4}},
      {id:'jury-rigged blade',label:'Jury-rigged blade',desc:'Sharpen scrap into a brutal close-range tool.',cost:{'scrap wiring':4,'wire spool':3}},
      {id:'scrap spear',label:'Scrap spear',desc:'Bind rods and scrap into a reach advantage.',cost:{'copper wire':3,'scrap bundle':6,'cloth scraps':5}},
      {id:'pocket pack',label:'Pocket pack',desc:'Add extra compartments without adding weight.',cost:{'cloth scraps':6,'plastic shards':3}},
      {id:'salvage tote',label:'Salvage tote',desc:'Reinforce a tote for hauling extra salvage.',cost:{'cloth scraps':8,'plastic shards':5,'wire spool':4}},
      {id:'scout daypack',label:'Scout daypack',desc:'Build a balanced daypack for longer routes.',cost:{'salvage tote':1,'wire spool':4,'cloth scraps':6}},
      {id:'bridge-runner pack',label:'Bridge-runner pack',desc:'Tethered pack tuned for wet transit lanes.',cost:{'salvage tote':1,'riot-line tape':4,'wire spool':4}},
      {id:'ledger-etched compass',label:'Ledger-etched compass',desc:'Etch trade routes into a compass that never lies.',cost:{'old coin':2,'electronics bits':4,'wire spool':3}}
    ];

    const MARKET_STOCK_BY_ZONE={
      safehouse:[
        {id:'bandage',cost:10,tag:'Shelter care'},
        {id:'water flask',cost:12,tag:'Hydration'},
        {id:'ration bar',cost:14,tag:'Rations'},
        {id:'morale patch',cost:16,tag:'Morale'},
        {id:'spare filter',cost:22,tag:'Air kit'},
        {id:'thermal wrap',cost:20,tag:'Warmth'},
        {id:'anti-rad serum',cost:46,tag:'Anti-rad'}
      ],
      town:[
        {id:'jury-rigged blade',cost:20,tag:'Weapon'},
        {id:'scrap spear',cost:34,tag:'Weapon'},
        {id:'pipe rifle',cost:72,tag:'Weapon'},
        {id:'riot shield',cost:58,tag:'Defense'},
        {id:'utility coat',cost:32,tag:'Armor'},
        {id:'exo brace',cost:46,tag:'Field gear'},
        {id:'anti-rad serum',cost:46,tag:'Anti-rad'}
      ],
      forest:[
        {id:'bandage',cost:10,tag:'Medical'},
        {id:'painkillers',cost:18,tag:'Medical'},
        {id:'compact medkit',cost:32,tag:'Medical'},
        {id:'filtered water pack',cost:26,tag:'Hydration'},
        {id:'spark tonic',cost:22,tag:'Stims'},
        {id:'morale patch',cost:16,tag:'Recovery'},
        {id:'anti-rad serum',cost:46,tag:'Anti-rad'}
      ],
      portland_slums:[
        {id:'ration bar',cost:14,tag:'Rations'},
        {id:'field rations',cost:20,tag:'Rations'},
        {id:'ember ration',cost:22,tag:'Rations'},
        {id:'water canister',cost:24,tag:'Hydration'},
        {id:'hardened canteen',cost:28,tag:'Hydration'},
        {id:'monsoon canteen',cost:40,tag:'Hydration'},
        {id:'anti-rad serum',cost:46,tag:'Anti-rad'}
      ],
      corporate_complex:[
        {id:'arc pistol',cost:82,tag:'Weapon'},
        {id:'market shock knife',cost:64,tag:'Weapon'},
        {id:'riot shield',cost:60,tag:'Defense'},
        {id:'compact medkit',cost:32,tag:'Medical'},
        {id:'painkillers',cost:20,tag:'Medical'},
        {id:'anti-rad serum',cost:46,tag:'Anti-rad'}
      ],
      metro_ganglands:[
        {id:'scavenger harness',cost:30,tag:'Clothing'},
        {id:'limited hoodie',cost:44,tag:'Clothing'},
        {id:'utility coat',cost:34,tag:'Armor'},
        {id:'coil battery',cost:26,tag:'Tool'},
        {id:'flashbang',cost:48,tag:'Tool'},
        {id:'market shock knife',cost:62,tag:'Weapon'}
      ]
    };
    const METRO_GANGLANDS_UPGRADE_STOCK=[
      {id:'arc pistol',cost:82,tag:'Weapon'},
      {id:'stun baton',cost:52,tag:'Weapon'},
      {id:'riot jacket',cost:120,tag:'Armor'},
      {id:'facility command badge',cost:140,tag:'Tool'},
      {id:'drone core',cost:96,tag:'Tool'},
      {id:'expedition frame pack',cost:72,tag:'Backpack'},
      {id:'signal jammer',cost:58,tag:'Tool'},
      {id:'overclock chip',cost:60,tag:'Tool'},
      {id:'insulated cloak',cost:54,tag:'Armor'},
      {id:'exo brace',cost:50,tag:'Gear'}
    ];
    const MARKET_STOCK_DEFAULT=[
      {id:'pocket pack',cost:26,tag:'Backpack'},
      {id:'scout daypack',cost:38,tag:'Backpack'},
      {id:'expedition frame pack',cost:68,tag:'Backpack'},
      {id:'jury-rigged blade',cost:18,tag:'Weapon'},
      {id:'scrap spear',cost:32,tag:'Weapon'},
      {id:'pipe rifle',cost:70,tag:'Weapon'},
      {id:'arc pistol',cost:82,tag:'Weapon'},
      {id:'compact medkit',cost:30,tag:'Medical'},
      {id:'filtered water pack',cost:28,tag:'Hydration'},
      {id:'morale patch',cost:16,tag:'Morale'},
      {id:'anti-rad serum',cost:46,tag:'Anti-rad'},
      {id:'spare filter',cost:24,tag:'Gear mod'},
      {id:'coil battery',cost:26,tag:'Gear mod'},
      {id:'bunker schematics',cost:44,tag:'Route intel'}
    ];

    const dom={
      introModal:document.getElementById('introModal'),
      introTitle:document.getElementById('introTitle'),
      introMessage:document.getElementById('introMessage'),
      introActions:document.getElementById('introActions'),
      stats:document.getElementById('stats'),
      meta:document.getElementById('meta'),
      excursionStatus:document.getElementById('excursionStatus'),
      tempoHint:document.getElementById('tempoHint'),
      doors:document.getElementById('doors'),
      doorsHint:document.getElementById('doorsHint'),
      zoneTitle:document.getElementById('zoneTitle'),
      zoneDesc:document.getElementById('zoneDesc'),
      zoneBadge:document.getElementById('zoneBadge'),
      raidActions:document.getElementById('raidActions'),
      inventory:document.getElementById('inventory'),
      equipment:document.getElementById('equipment'),
      crafting:document.getElementById('crafting'),
      backpackCount:document.getElementById('backpackCount'),
      loadoutCount:document.getElementById('loadoutCount'),
      codex:document.getElementById('codex'),
      idleOps:document.getElementById('idleOps'),
      hubLock:document.getElementById('hubLock'),
      screenNav:document.getElementById('screenNav'),
      screens:{
        main:document.getElementById('screen-main'),
        locations:document.getElementById('screen-locations'),
        mission:document.getElementById('screen-mission')
      },
      screenButtons:Array.from(document.querySelectorAll('#screenNav button')),
      enterLocations:document.getElementById('enterLocations'),
      returnMain:document.getElementById('returnMain'),
      travelStatus:document.getElementById('travelStatus'),
      missionTitle:document.getElementById('missionTitle'),
      missionMeta:document.getElementById('missionMeta'),
      missionProgress:document.getElementById('missionProgress'),
      missionLog:document.getElementById('missionLog'),
      missionActions:document.getElementById('missionActions'),
      missionRewardsCard:document.getElementById('missionRewardsCard'),
      missionRewardHint:document.getElementById('missionRewardHint'),
      missionRewardList:document.getElementById('missionRewardList'),
      stash:document.getElementById('stash'),
      stashActions:document.getElementById('stashActions'),
      stashDetail:document.getElementById('stashDetail'),
      stashItemActions:document.getElementById('stashItemActions'),
      stashCount:document.getElementById('stashCount'),
      stashTitle:document.getElementById('stashTitle'),
      stashSubtitle:document.getElementById('stashSubtitle'),
      stashCommandTitle:document.getElementById('stashCommandTitle'),
      marketInventory:document.getElementById('marketInventory'),
      marketHint:document.getElementById('marketHint'),
      marketBackpack:document.getElementById('marketBackpack'),
      marketBackpackCount:document.getElementById('marketBackpackCount'),
      marketSubtitle:document.getElementById('marketSubtitle'),
      itemDetail:document.getElementById('itemDetail'),
      itemActions:document.getElementById('itemActions'),
      inventoryNav:Array.from(document.querySelectorAll('#inventoryNav button')),
      inventoryScreens:{
        backpack:document.getElementById('inventoryBackpack'),
        loadout:document.getElementById('inventoryLoadout'),
        crafting:document.getElementById('inventoryCrafting')
      },
      stashNav:Array.from(document.querySelectorAll('#stashNav button')),
      stashScreens:{
        vault:document.getElementById('stashVault'),
        market:document.getElementById('stashMarket')
      },
      tabs:document.querySelector('.tabs'),
      tabButtons:Array.from(document.querySelectorAll('.tab-buttons button')),
      tabContents:{
        hub:document.getElementById('tab-hub'),
        inventory:document.getElementById('tab-inventory'),
        field:document.getElementById('tab-field')
      }
    };

    let activeTab='hub';

    /* ================= UTILITIES ================= */
    const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
    const pct=(v,max)=>Math.round((v/max)*100);
    const NORMAL_BODY_TEMP=98;
    const BODY_TEMP_MIN=70;
    const BODY_TEMP_MAX=104;
    const moveToward=(value,target,amount)=>{
      if(value<target) return Math.min(target,value+amount);
      if(value>target) return Math.max(target,value-amount);
      return value;
    };
    const getTotalMinutes=()=>((state.day||0)*24*60)+(state.timeMinutes||0);
    const updateRadShield=()=>{
      if(!state.radShieldUntil || !state.radShield) return state.radShield || 0;
      if(getTotalMinutes()>=state.radShieldUntil){
        state.radShield=0;
        state.radShieldUntil=null;
      }
      return state.radShield || 0;
    };
    const fmtTime=(mins)=>{
      const m=mins%60;const h=Math.floor(mins/60)%24;const suffix=h>=12?"PM":"AM";
      const hour=((h+11)%12+1);return `${hour}:${m.toString().padStart(2,'0')} ${suffix}`;
    }
    const setCodex=(msg)=>{ state.codex=[msg]; };
    const isHubZone=(zone=state.zone)=>{
      if(!zone) return false;
      const name=(zone.name||'').toLowerCase();
      return zone.id==='safehouse' || zone.id==='drift-yard' || name.includes('safehouse') || name.includes('hub') || name.includes('drift yard');
    };
    const canAccessVault=()=>isHubZone(state.zone) && !state.mission.active && !state.travel.active;
    const canAccessMarket=()=>state.marketAccess.active && state.marketAccess.zoneId===state.zone.id && !state.mission.active && !state.travel.active;
    const isMarketZone=(zone=state.zone)=>{
      if(!zone) return false;
      const exp=expansions[zone.id];
      if(exp?.meta?.shop==='true') return true;
      return zone.id==='town' || (zone.name||'').toLowerCase().includes('market');
    };
    const zoneHasShop=(zone=state.zone)=>isMarketZone(zone) || zone.id==='safehouse';
    const getMarketStockForZone=(zoneId)=>{
      if(!zoneId) return MARKET_STOCK_DEFAULT;
      if(zoneId==='metro_ganglands'){
        const base=MARKET_STOCK_BY_ZONE[zoneId] || MARKET_STOCK_DEFAULT;
        if(state.flags.has('metro-telecom')){
          return [...base,...METRO_GANGLANDS_UPGRADE_STOCK];
        }
        return base;
      }
      return MARKET_STOCK_BY_ZONE[zoneId] || MARKET_STOCK_DEFAULT;
    };
    const ensureZoneScene=(zone=state.zone)=>{
      const exp=expansions[zone.id];
      if(!exp) return null;
      const availableSceneId=zone.sceneId || exp.door?.target || Object.keys(exp.scenes || {})[0];
      if(availableSceneId && zone.sceneId!==availableSceneId){
        zone.sceneId=availableSceneId;
      }
      if(!availableSceneId) return null;
      const scene=exp.scenes?.[availableSceneId];
      return scene ? {id:availableSceneId,...scene} : null;
    };
    const clearMarketAccess=()=>{
      if(state.marketAccess.active){
        state.marketAccess={active:false,zoneId:null};
        if(state.stashScreen==='market'){
          state.stashScreen='vault';
        }
      }
    };
    const vaultBlockedMessage='Return to a hub location to access the vault.';
    const logMsg=(msg)=>{
      const stamp=`[Day ${state.day} // ${fmtTime(state.timeMinutes)}] ${msg}`;
      if(state.mission.active && !state.mission.completed){
        state.mission.statusMessage=stamp;
        state.mission.summary=stamp;
        renderMissionStatus();
        return;
      }
      if(state.idleOps.active && !state.idleOps.completed){
        state.idleOps.statusMessage=stamp;
        renderIdleOps();
        return;
      }
      setCodex(msg);
    }
    let travelResolveTimer=null;
    const scheduleTravelResolution=()=>{
      if(travelResolveTimer){
        clearTimeout(travelResolveTimer);
        travelResolveTimer=null;
      }
      if(!state.travel.active) return;
      const endsAt=Number(state.travel.endsAt);
      if(!Number.isFinite(endsAt)) return;
      const delay=Math.max(0,endsAt-Date.now())+60;
      travelResolveTimer=setTimeout(()=>{
        if(state.travel.active){
          renderTravelStatus();
        }
      },delay);
    };

    const GRID_PAGE_SIZE=18;
    const STACK_LIMIT=25;
    const STACKABLE_CHUNK_RANGE={min:5,max:20};
    const STACKABLE_ITEMS=new Set(['scrap bundle','wire spool','cloth scraps','plastic shards','electronics bits','scrap wiring','copper wire']);
    const isStackable=(id)=>STACKABLE_ITEMS.has(id);
    const getItemCount=(arr,id)=>arr.reduce((acc,item)=>acc+(item===id?1:0),0);
    const slotUsageFor=(id,count)=>isStackable(id)?Math.ceil(count/STACK_LIMIT):count;
    const getSlotUsage=(arr)=>{
      const tally={};
      arr.forEach(item=>{tally[item]=(tally[item]||0)+1;});
      return Object.entries(tally).reduce((total,[id,count])=>total+slotUsageFor(id,count),0);
    };
    const hasCapacityFor=(arr,limit,id,count=1)=>{
      const currentSlots=getSlotUsage(arr);
      const existingCount=getItemCount(arr,id);
      const currentItemSlots=slotUsageFor(id,existingCount);
      const nextItemSlots=slotUsageFor(id,existingCount+count);
      const projected=currentSlots-currentItemSlots+nextItemSlots;
      return projected<=limit;
    };
    const removeItem=(arr,item)=>{const idx=arr.indexOf(item); if(idx>=0) arr.splice(idx,1);};
    const removeItems=(arr,item,count)=>{
      for(let i=0;i<count;i++){
        const idx=arr.indexOf(item);
        if(idx<0) return i===count;
        arr.splice(idx,1);
      }
      return true;
    };
    const addItemCopies=(arr,item,count=1)=>{for(let i=0;i<count;i++) arr.push(item);};
    const routeItemGain=(item)=>{
      if(hasCapacityFor(state.inventory,getBackpackLimit(),item,1)){
        state.inventory.push(item);
        return 'inventory';
      }
      if(canAccessVault() && hasCapacityFor(state.stash.items,state.stashLimit,item,1)){
        state.stash.items.push(item);
        return 'vault';
      }
      return 'lost';
    };
    const getItem=(id)=>ITEM_CATALOG[id] || {type:'junk',rarity:'common',value:1};
    const formatDisplayMinutes=(minutes)=>Math.max(1,Math.round(minutes*TIME_DISPLAY_MULTIPLIER));
    const normalizeBreakdown=(breakdown)=>({
      scrap:Math.max(0,Number(breakdown?.scrap || 0)),
      items:{...(breakdown?.items || {})}
    });
    const BREAKDOWN_DEFAULTS={
      armor:{items:{'cloth scraps':4}},
      tool:{items:{'electronics bits':3,'plastic shards':2}},
      weapon:{items:{'scrap wiring':3,'copper wire':2},scrap:1},
      consumable:{items:{'scrap bundle':2,'plastic shards':1}},
      key:{items:{'electronics bits':2,'scrap wiring':1}}
    };
    const getBreakdownOutputs=(item)=>{
      const data=getItem(item);
      if(data.breakdown){
        return normalizeBreakdown(data.breakdown);
      }
      if(data.type==='junk'){
        return {scrap:data.salvage || Math.max(1,Math.floor((data.value || 1)/2)),items:{}};
      }
      const fallback=BREAKDOWN_DEFAULTS[data.type];
      if(fallback){
        return normalizeBreakdown(fallback);
      }
      return {scrap:Math.max(1,Math.floor((data.value || 1)/2)),items:{'scrap bundle':1}};
    };
    const formatBreakdownOutput=(outputs)=>{
      const parts=[];
      if(outputs.scrap){
        parts.push(`${outputs.scrap} scrap`);
      }
      Object.entries(outputs.items || {}).forEach(([id,count])=>{
        if(count>0) parts.push(`${count} ${id}`);
      });
      return parts.join(' · ');
    };
    const applyBreakdownOutputs=(outputs,{preferred='inventory'}={})=>{
      const losses=[];
      if(outputs.scrap){
        state.scrap+=outputs.scrap;
      }
      Object.entries(outputs.items || {}).forEach(([id,count])=>{
        for(let i=0;i<count;i++){
          const preferStash=preferred==='stash';
          if(preferStash && canAccessVault() && hasCapacityFor(state.stash.items,state.stashLimit,id,1)){
            state.stash.items.push(id);
            continue;
          }
          if(hasCapacityFor(state.inventory,getBackpackLimit(),id,1)){
            state.inventory.push(id);
            continue;
          }
          if(canAccessVault() && hasCapacityFor(state.stash.items,state.stashLimit,id,1)){
            state.stash.items.push(id);
            continue;
          }
          losses.push(id);
        }
      });
      if(losses.length){
        logMsg(`${losses.length}x ${losses[0]} lost: no storage space available.`);
      }
    };
    const formatMods=(mods)=>{
      if(!mods) return [];
      return Object.entries(mods).map(([key,val])=>{
        const label=key.replace(/([A-Z])/g,' $1').toLowerCase();
        const sign=val>0?'+':'';
        return `${label} ${sign}${val}`;
      });
    };
    const rarityLabel=(rarity)=>rarity ? `${rarity[0].toUpperCase()}${rarity.slice(1)}` : '';
    const formatEffects=(effect)=>{
      if(!effect) return [];
      const labels={temp:'body temp',backpack:'backpack slots'};
      return effect.split(',').map(token=>token.trim()).filter(Boolean).map(token=>{
        if(token.startsWith('item:')) return `Adds item: ${token.slice(5).trim()}`;
        if(token.startsWith('note:')) return token.slice(5).trim();
        if(token.startsWith('log:')) return token.slice(4).trim();
        if(token.startsWith('flag:')) return `Flags ${token.slice(5).trim()}`;
        const radPercentMatch=token.match(/^rads([+-]\d+)%$/i);
        if(radPercentMatch){
          return `radiation ${radPercentMatch[1]}%`;
        }
        const radShieldMatch=token.match(/^radshield([+-]\d+)/i);
        if(radShieldMatch){
          const value=Number(radShieldMatch[1]);
          const display=value>0 ? `-${Math.abs(value)}%` : `${value}%`;
          return `radiation accumulation ${display}`;
        }
        const match=token.match(/([a-zA-Z]+)([+-]\d+)/);
        if(match){
          const stat=match[1];
          const delta=match[2];
          const label=labels[stat] || stat;
          return `${label} ${delta}`;
        }
        return token;
      });
    };
    const groupItems=(items)=>{
      const tally=items.reduce((acc,item)=>{
        acc[item]=(acc[item]||0)+1;
        return acc;
      },{});
      return Object.entries(tally).map(([id,count])=>({id,count,data:getItem(id)}));
    };
    const rollLootItem=(risk,bonus=0)=>{
      const roll=Math.random();
      const bias={
        low:{common:0.7,uncommon:0.22,rare:0.07,epic:0.009,legendary:0.001},
        medium:{common:0.55,uncommon:0.28,rare:0.13,epic:0.035,legendary:0.005},
        high:{common:0.4,uncommon:0.3,rare:0.18,epic:0.09,legendary:0.03},
        deadly:{common:0.3,uncommon:0.28,rare:0.2,epic:0.14,legendary:0.08}
      };
      const dist=bias[risk] || bias.low;
      const adjusted={
        common:Math.max(0.05,dist.common-(bonus*0.5)),
        uncommon:dist.uncommon+(bonus*0.2),
        rare:dist.rare+(bonus*0.2),
        epic:dist.epic+(bonus*0.08),
        legendary:dist.legendary+(bonus*0.02)
      };
      const rollTable=[
        ['common',adjusted.common],
        ['uncommon',adjusted.uncommon],
        ['rare',adjusted.rare],
        ['epic',adjusted.epic],
        ['legendary',adjusted.legendary]
      ];
      let cursor=0;
      for(const [rarity,weight] of rollTable){
        cursor+=weight;
        if(roll<=cursor){
          const pool=LOOT_BY_RARITY[rarity];
          return pool[Math.floor(Math.random()*pool.length)];
        }
      }
      return 'scrap wiring';
    };
    const rollStackableChunk=()=>STACKABLE_CHUNK_RANGE.min+Math.floor(Math.random()*(STACKABLE_CHUNK_RANGE.max-STACKABLE_CHUNK_RANGE.min+1));
    const rollLootDrop=(risk,bonus=0)=>{
      const id=rollLootItem(risk,bonus);
      const count=isStackable(id)?rollStackableChunk():1;
      return {id,count};
    };
    const getGearMods=(excludeItem)=>{
      return state.equipped.reduce((acc,item)=>{
        if(excludeItem && item===excludeItem) return acc;
        const mod=getItem(item).mods;
        if(!mod) return acc;
        Object.entries(mod).forEach(([key,val])=>{
          acc[key]=(acc[key]||0)+val;
        });
        return acc;
      },{});
    };
    const getBackpackLimit=(excludeItem)=>state.backpackLimit+(getGearMods(excludeItem).carryBonus||0);
    const getBackpackUsage=()=>getSlotUsage(state.inventory);
    const getStashUsage=()=>getSlotUsage(state.stash.items);
    const canUnequipItem=(item)=>hasCapacityFor(state.inventory,getBackpackLimit(item),item,1);
    const XP_BASE=80;
    const XP_GROWTH=20;
    const xpToNextLevel=(level)=>XP_BASE+(XP_GROWTH*(level-1));
    const EQUIPMENT_SLOTS={
      backpack:1,
      gloves:1,
      helmet:1,
      eyewear:1,
      pants:1,
      shoes:1,
      chest:1,
      weapon:2,
      tool:3
    };
    const EQUIPMENT_SLOT_LABELS={
      backpack:'Backpack',
      gloves:'Gloves',
      helmet:'Helmet',
      eyewear:'Eyewear',
      pants:'Pants',
      shoes:'Shoes',
      chest:'Chest',
      weapon:'Weapon',
      tool:'Tool'
    };
    const getEquipmentSlotUsage=()=>{
      const usage=Object.keys(EQUIPMENT_SLOTS).reduce((acc,key)=>{acc[key]=0;return acc;},{});
      state.equipped.forEach(item=>{
        const slot=getItem(item).slot;
        if(slot && usage.hasOwnProperty(slot)){
          usage[slot]+=1;
        }
      });
      return usage;
    };
    const getEquipmentUsageCount=()=>{
      const usage=getEquipmentSlotUsage();
      return Object.values(usage).reduce((sum,val)=>sum+val,0);
    };
    const getEquipmentSlotTotal=()=>Object.values(EQUIPMENT_SLOTS).reduce((sum,val)=>sum+val,0);
    const slotLabel=(slot)=>EQUIPMENT_SLOT_LABELS[slot] || slot;
    const getEquippedItemBySlot=(slot)=>state.equipped.find(item=>getItem(item).slot===slot);
    const getBackpackLimitAfterSwap=(currentBackpack,newBackpack)=>{
      const currentMods=getGearMods(currentBackpack);
      const newMods=getItem(newBackpack).mods || {};
      const carryBonus=(currentMods.carryBonus||0)+(newMods.carryBonus||0);
      return state.backpackLimit+carryBonus;
    };
    const canSwapBackpack=(currentBackpack,newBackpack,removeFromInventory)=>{
      const tempInventory=[...state.inventory];
      if(removeFromInventory){
        removeItem(tempInventory,newBackpack);
      }
      const limit=getBackpackLimitAfterSwap(currentBackpack,newBackpack);
      return hasCapacityFor(tempInventory,limit,currentBackpack,1);
    };
    const canEquipItem=(item,source='inventory')=>{
      const data=getItem(item);
      if(!data.slot) return {ok:false,reason:'This item cannot be equipped.'};
      const usage=getEquipmentSlotUsage();
      const limit=EQUIPMENT_SLOTS[data.slot] || 0;
      if((usage[data.slot]||0) >= limit){
        if(data.slot==='backpack'){
          const equippedBackpack=getEquippedItemBySlot('backpack');
          if(equippedBackpack){
            const removeFromInventory=source==='inventory';
            if(canSwapBackpack(equippedBackpack,item,removeFromInventory)){
              return {ok:true,reason:'',requiresSwap:true,swapItem:equippedBackpack};
            }
            return {ok:false,reason:'Backpack too full to swap.'};
          }
        }
        return {ok:false,reason:`${slotLabel(data.slot)} slot full.`};
      }
      return {ok:true,reason:'',requiresSwap:false};
    };
    function awardXp(amount,sourceLabel){
      if(amount<=0) return;
      state.xp+=amount;
      let leveled=false;
      while(state.xp>=state.nextLevelXp){
        state.xp-=state.nextLevelXp;
        state.level+=1;
        state.maxHp+=6;
        state.maxStamina+=4;
        state.maxMorale+=3;
        state.nextLevelXp=xpToNextLevel(state.level);
        state.hp=clamp(state.hp+10,0,state.maxHp);
        state.stamina=clamp(state.stamina+8,0,state.maxStamina);
        state.morale=clamp(state.morale+6,0,state.maxMorale);
        leveled=true;
      }
      if(leveled){
        logMsg(`Level up! You are now level ${state.level}.`);
      }else if(sourceLabel){
        logMsg(`+${amount} XP from ${sourceLabel}.`);
      }
    }
    const STASH_UPGRADE_STEP=6;
    const STASH_UPGRADE_BASE_COST={credits:32,scrap:4};
    const STASH_UPGRADE_GROWTH={credits:24,scrap:3};
    const getStashUpgradeCost=()=>{
      const level=state.stashUpgradeLevel;
      return {
        credits:STASH_UPGRADE_BASE_COST.credits+(STASH_UPGRADE_GROWTH.credits*level),
        scrap:STASH_UPGRADE_BASE_COST.scrap+(STASH_UPGRADE_GROWTH.scrap*level)
      };
    };
    const upgradeStash=()=>{
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      const cost=getStashUpgradeCost();
      if(!canAfford(cost)){
        setCodex('Not enough resources to expand the stash.');
        return;
      }
      applyCost(cost);
      state.stashLimit+=STASH_UPGRADE_STEP;
      state.stashUpgradeLevel+=1;
      setCodex(`Vault expanded by ${STASH_UPGRADE_STEP} slots.`);
      logMsg(`Vault expansion complete. Capacity now ${state.stashLimit}.`);
      renderAll();
    };
    const formatCost=(cost)=>Object.entries(cost).map(([k,v])=>`${v} ${k}`).join(' · ');
    const canAfford=(cost)=>Object.entries(cost).every(([k,v])=>state[k]>=v);
    const applyCost=(cost)=>{
      Object.entries(cost).forEach(([k,v])=>{
        state[k]=Math.max(0,state[k]-v);
      });
    };
    const addToArray=(arr,item)=>{arr.push(item);};
    function equipItem(item){
      if(state.equipped.includes(item)) return;
      const data=getItem(item);
      const check=canEquipItem(item,'inventory');
      if(!check.ok){
        setCodex(check.reason || 'No open slots for that item.');
        return;
      }
      if(check.requiresSwap){
        const equippedBackpack=check.swapItem || getEquippedItemBySlot('backpack');
        if(!equippedBackpack){
          setCodex('No open slots for that item.');
          return;
        }
        removeItem(state.inventory,item);
        removeItem(state.equipped,equippedBackpack);
        state.inventory.push(equippedBackpack);
        state.equipped.push(item);
        state.selected={source:'equipped',item};
        setCodex(`${item} equipped.`);
        logMsg(`Swapped to ${item}.`);
        renderAll();
        return;
      }
      removeItem(state.inventory,item);
      state.equipped.push(item);
      state.selected={source:'equipped',item};
      setCodex(`${item} equipped.`);
      logMsg(`Equipped ${item}.`);
      renderAll();
    }
    function unequipItem(item){
      if(!canUnequipItem(item)){
        setCodex('Backpack full. Make space before unequipping.');
        return;
      }
      removeItem(state.equipped,item);
      state.inventory.push(item);
      state.selected={source:'inventory',item};
      setCodex(`${item} stowed.`);
      logMsg(`Unequipped ${item}.`);
      renderAll();
    }
    function consumeItem(item){
      const data=getItem(item);
      if(data.type!=='consumable'){
        setCodex('That item cannot be used like a consumable.');
        return;
      }
      if(data.effect){
        applyEffects(data.effect,'success');
      }
      removeItem(state.inventory,item);
      state.selected={source:null,item:null};
      logMsg(`Consumed ${item}.`);
      setCodex(`${item} used.`);
      renderAll();
    }
    function stashItem(item){
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      if(!hasCapacityFor(state.stash.items,state.stashLimit,item,1)){
        setCodex('Stash is full.');
        return;
      }
      removeItem(state.inventory,item);
      state.stash.items.push(item);
      state.selected={source:'stash',item};
      setCodex(`${item} stored in ${state.stash.name}.`);
      logMsg(`Stored ${item} in ${state.stash.name}.`);
      renderAll();
    }
    function stashItemStack(item,count){
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      const available=getItemCount(state.inventory,item);
      const transferCount=Math.min(count,available);
      if(transferCount<=0){
        setCodex('No stack available to route.');
        return;
      }
      if(!hasCapacityFor(state.stash.items,state.stashLimit,item,transferCount)){
        setCodex('Stash is full.');
        return;
      }
      removeItems(state.inventory,item,transferCount);
      addItemCopies(state.stash.items,item,transferCount);
      state.selected={source:'stash',item};
      setCodex(`${item} stack routed into ${state.stash.name}.`);
      logMsg(`Routed ${transferCount}x ${item} into ${state.stash.name}.`);
      renderAll();
    }
    function stashItemHalf(item){
      const available=getItemCount(state.inventory,item);
      const half=Math.floor(available/2);
      if(half<=0){
        setCodex('Not enough of that item to split.');
        return;
      }
      stashItemStack(item,half);
    }
    function unstashItem(item){
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      if(!hasCapacityFor(state.inventory,getBackpackLimit(),item,1)){
        setCodex('Backpack full.');
        return;
      }
      removeItem(state.stash.items,item);
      state.inventory.push(item);
      state.selected={source:'inventory',item};
      setCodex(`${item} withdrawn from ${state.stash.name}.`);
      logMsg(`Retrieved ${item} from ${state.stash.name}.`);
      renderAll();
    }
    function sellItem(item){
      if(!canAccessMarket()){
        setCodex('Visit a shop to sell items.');
        return;
      }
      const data=getItem(item);
      removeItem(state.inventory,item);
      state.credits+=data.value || 1;
      state.selected={source:null,item:null};
      logMsg(`Sold ${item} for ${data.value || 1} credits.`);
      renderAll();
    }
    function sellItemStack(item,count){
      if(!canAccessMarket()){
        setCodex('Visit a shop to sell items.');
        return;
      }
      const available=getItemCount(state.inventory,item);
      const sellCount=Math.min(count,available);
      if(sellCount<=0) return;
      const data=getItem(item);
      removeItems(state.inventory,item,sellCount);
      state.credits+=(data.value || 1) * sellCount;
      state.selected={source:null,item:null};
      logMsg(`Sold ${sellCount}x ${item} for ${(data.value || 1) * sellCount} credits.`);
      renderAll();
    }
    function dismantleItem(item){
      removeItem(state.inventory,item);
      const breakdown=getBreakdownOutputs(item);
      applyBreakdownOutputs(breakdown,{preferred:'inventory'});
      state.selected={source:null,item:null};
      logMsg(`Dismantled ${item} for ${formatBreakdownOutput(breakdown) || 'junk'}.`);
      renderAll();
    }

    function resetIdleOpsState(){
      state.idleOps={active:false,id:null,startedAt:null,durationMs:0,etaMinutes:0,completed:false,statusMessage:'',rewards:[]};
    }
    function closeIdleOp(){
      resetIdleOpsState();
      state.selected={source:null,item:null};
      setCodex('Idle operation closed. Ready for another dispatch.');
      renderAll();
    }

    function startIdleOp(opId){
      if(state.idleOps.active){
        setCodex('An idle operation is already underway.');
        return;
      }
      if(state.idleOps.completed){
        if((state.idleOps.rewards?.length||0)>0){
          setCodex('Resolve idle rewards before dispatching a new operation.');
          return;
        }
        resetIdleOpsState();
      }
      const op=idleOperations.find(entry=>entry.id===opId);
      if(!op) return;
      if(!canAfford(op.cost)){
        setCodex('Insufficient resources for this operation.');
        return;
      }
      startLoops();
      applyCost(op.cost);
      const gearMods=getGearMods();
      const duration=getIdleDurationMinutes(op,gearMods);
      state.idleOps={
        active:true,
        id:opId,
        startedAt:Date.now(),
        durationMs:duration*60000,
        etaMinutes:duration,
        completed:false,
        statusMessage:`Idle op launched: ${op.label}.`,
        rewards:[]
      };
      logMsg(`Idle op launched: ${op.label}. ETA ${formatMinutesPrecise(duration)}.`);
      renderAll();
    }

    function completeIdleOp(){
      const op=idleOperations.find(entry=>entry.id===state.idleOps.id);
      if(!op) return;
      const rewards=[];
      applyEffects(op.reward,'success',{deferItemsTo:rewards});
      state.idleOps={
        active:false,
        id:op.id,
        startedAt:null,
        durationMs:0,
        etaMinutes:0,
        completed:true,
        statusMessage:`Idle op complete: ${op.label}. Rewards ready.`,
        rewards
      };
      state.selected={source:null,item:null};
      setCodex('Idle operation complete. Review rewards.');
      renderAll();
    }

    /* ================= RENDERING ================= */
    function renderBars(){
      const rows=[
        ['HP','hp','maxHp','hp'],
        ['Stamina','stamina','maxStamina','stamina'],
        ['Morale','morale','maxMorale','morale'],
        ['Energy','energy','maxEnergy','stamina'],
        ['Hunger','hunger','maxHunger','hunger'],
        ['Hydration','thirst','maxThirst','thirst'],
        ['Radiation','rads',100,'rads'],
        ['Body Temp','bodyTemp','maxBodyTemp','temp']
      ];
      dom.stats.innerHTML=rows.map(([label,key,maxKey,cls])=>{
        const val=state[key];const max=(typeof maxKey==='string')?state[maxKey]:maxKey;
        const percent=clamp(pct(val,max),0,200);
        return `<div class="statline"><div>${label}</div><div class="bar ${cls}"><span style="width:${percent}%;"></span></div><div>${Math.round(val)}/${max}</div></div>`;
      }).join('');
    dom.meta.innerHTML=`<span class="pill-inline"><b>Credits</b>${state.credits}</span>`+
        `<span class="pill-inline"><b>Scrap</b>${state.scrap}</span>`+
        `<span class="pill-inline"><b>Keys</b>${state.keys}</span>`+
        `<span class="pill-inline"><b>Level</b>${state.level}</span>`+
        `<span class="pill-inline"><b>XP</b>${state.xp}/${state.nextLevelXp}</span>`+
        `<span class="pill-inline"><b>Time</b>${fmtTime(state.timeMinutes)}</span>`+
        `<span class="pill-inline"><b>Day</b>${state.day}</span>`+
        `<span class="pill-inline"><b>Backpack</b>${getBackpackUsage()}/${getBackpackLimit()}</span>`;
    }

    const rewardSources={
      mission:{
        key:'missionReward',
        getItems:()=>state.mission.rewards || [],
        clear:()=>{ state.mission.rewards=[]; }
      },
      idle:{
        key:'idleReward',
        getItems:()=>state.idleOps.rewards || [],
        clear:()=>{ state.idleOps.rewards=[]; }
      }
    };
    const getRewardConfig=(source)=>Object.values(rewardSources).find(cfg=>cfg.key===source) || null;
    const rewardHasItem=(source,item)=>{
      const cfg=getRewardConfig(source);
      if(!cfg) return false;
      return cfg.getItems().includes(item);
    };
    const getRewardItemCount=(source,item)=>{
      const cfg=getRewardConfig(source);
      if(!cfg) return 0;
      return cfg.getItems().filter(entry=>entry===item).length;
    };
    const removeRewardItem=(source,item)=>{
      const cfg=getRewardConfig(source);
      if(!cfg) return false;
      const bucket=cfg.getItems();
      const idx=bucket.indexOf(item);
      if(idx<0) return false;
      bucket.splice(idx,1);
      return true;
    };
    const removeRewardItems=(source,item,count)=>{
      const cfg=getRewardConfig(source);
      if(!cfg) return false;
      return removeItems(cfg.getItems(),item,count);
    };
    const isMissionResolved=()=>state.mission.active && state.mission.completed && (state.mission.rewards?.length||0)===0;
    function autoCloseMissionIfResolved(){
      if(isMissionResolved()){
        closeMission({auto:true});
      }
    }
    function claimRewardToInventory(source,item){
      if(!hasCapacityFor(state.inventory,getBackpackLimit(),item,1)){
        setCodex('Backpack full. Make room first.');
        return;
      }
      if(!removeRewardItem(source,item)) return;
      state.inventory.push(item);
      state.selected={source:'inventory',item};
      setCodex(`${item} packed into your backpack.`);
      autoCloseMissionIfResolved();
      renderAll();
    }
    function claimRewardStackToInventory(source,item){
      const count=getRewardItemCount(source,item);
      if(!count) return;
      if(!hasCapacityFor(state.inventory,getBackpackLimit(),item,count)){
        setCodex('Backpack full. Make room first.');
        return;
      }
      if(!removeRewardItems(source,item,count)) return;
      addItemCopies(state.inventory,item,count);
      state.selected={source:'inventory',item};
      setCodex(`${item} stack packed into your backpack.`);
      autoCloseMissionIfResolved();
      renderAll();
    }
    function claimRewardToVault(source,item){
      if(source==='missionReward'){
        setCodex('Mission rewards can only be packed, equipped, broken down, or left behind.');
        return;
      }
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      if(!hasCapacityFor(state.stash.items,state.stashLimit,item,1)){
        setCodex('Stash full. Sell or break down to clear space.');
        return;
      }
      if(!removeRewardItem(source,item)) return;
      state.stash.items.push(item);
      state.selected={source:'stash',item};
      setCodex(`${item} routed into the vault.`);
      renderAll();
    }
    function equipRewardItem(source,item){
      const data=getItem(item);
      const check=canEquipItem(item,source);
      if(!check.ok){
        setCodex(check.reason || 'No open slots for that item.');
        return;
      }
      if(check.requiresSwap){
        const equippedBackpack=check.swapItem || getEquippedItemBySlot('backpack');
        if(!equippedBackpack){
          setCodex('No open slots for that item.');
          return;
        }
        if(!removeRewardItem(source,item)) return;
        removeItem(state.equipped,equippedBackpack);
        state.inventory.push(equippedBackpack);
        state.equipped.push(item);
        state.selected={source:'equipped',item};
        setCodex(`${item} equipped from rewards.`);
        autoCloseMissionIfResolved();
        renderAll();
        return;
      }
      if(!removeRewardItem(source,item)) return;
      state.equipped.push(item);
      state.selected={source:'equipped',item};
      setCodex(`${item} equipped from rewards.`);
      autoCloseMissionIfResolved();
      renderAll();
    }
    function scrapRewardItem(source,item){
      if(!removeRewardItem(source,item)) return;
      const breakdown=getBreakdownOutputs(item);
      applyBreakdownOutputs(breakdown);
      state.selected={source:null,item:null};
      setCodex(`${item} broken down into ${formatBreakdownOutput(breakdown) || 'junk'}.`);
      autoCloseMissionIfResolved();
      renderAll();
    }
    function leaveRewardItem(source,item){
      if(!removeRewardItem(source,item)) return;
      state.selected={source:null,item:null};
      setCodex(`${item} left behind.`);
      autoCloseMissionIfResolved();
      renderAll();
    }
    function clearRewardSource(source){
      const cfg=getRewardConfig(source);
      if(!cfg) return;
      cfg.clear();
      state.selected={source:null,item:null};
      setCodex(source==='missionReward' ? 'Mission rewards left behind.' : 'Idle rewards dismissed.');
      autoCloseMissionIfResolved();
      renderAll();
    }

    const hasCraftingMaterials=(recipe)=>Object.entries(recipe.cost).every(([id,count])=>getItemCount(state.inventory,id)>=count);
    const craftingCostLabel=(recipe)=>Object.entries(recipe.cost).map(([id,count])=>`${count} ${id}`).join(' · ');
    function craftRecipe(recipeId){
      const recipe=CRAFTING_RECIPES.find(entry=>entry.id===recipeId);
      if(!recipe) return;
      if(!hasCraftingMaterials(recipe)) {
        setCodex('Missing crafting materials.');
        return;
      }
      if(!hasCapacityFor(state.inventory,getBackpackLimit(),recipe.id,1)){
        setCodex('Backpack capacity reached. Crafting would overflow.');
        return;
      }
      Object.entries(recipe.cost).forEach(([id,count])=>removeItems(state.inventory,id,count));
      state.inventory.push(recipe.id);
      state.selected={source:'inventory',item:recipe.id};
      logMsg(`Crafted ${recipe.label} from salvage.`);
      renderAll();
    }

    function buyMarketItem(itemId){
      const zoneId=state.marketAccess.zoneId || state.zone.id;
      const stock=getMarketStockForZone(zoneId).find(entry=>entry.id===itemId);
      if(!stock) return;
      if(!canAccessMarket()){
        setCodex('Visit a shop to buy items.');
        return;
      }
      if(state.credits<stock.cost){
        setCodex('Not enough credits for this purchase.');
        return;
      }
      if(!hasCapacityFor(state.inventory,getBackpackLimit(),itemId,1)){
        setCodex('Backpack full. Make room before purchasing.');
        return;
      }
      state.credits-=stock.cost;
      state.inventory.push(itemId);
      state.selected={source:'inventory',item:itemId};
      logMsg(`Purchased ${itemId} for ${stock.cost} credits.`);
      renderAll();
    }

    function buildItemRow({id,count,data,source}){
      const row=document.createElement('div');
      row.className='item-row selectable';
      if(state.selected.source===source && state.selected.item===id){
        row.classList.add('selected');
      }
      row.onclick=()=>selectItem(source,id);
      const name=document.createElement('div');
      name.className='item-name';
      name.textContent=`${id} ×${count}`;
      const meta=document.createElement('div');
      meta.className='item-meta';
      const slotTag=data.slot ? `${slotLabel(data.slot)} · ` : '';
      meta.textContent=`${data.type} · ${slotTag}${data.value || 1} cr`;
      const chip=document.createElement('span');
      chip.className=`chip ${data.rarity}`;
      chip.textContent=data.rarity;
      row.appendChild(name);
      row.appendChild(chip);
      row.appendChild(meta);
      return row;
    }

    function buildItemTile({id,count,data,source}){
      const tile=document.createElement('button');
      tile.type='button';
      tile.className='icon-tile';
      if(state.selected.source===source && state.selected.item===id){
        tile.classList.add('selected');
      }
      tile.onclick=()=>selectItem(source,id);
      tile.title=`${id} ×${count}`;
      const name=document.createElement('div');
      name.className='icon-name';
      name.textContent=id;
      const meta=document.createElement('div');
      meta.className='icon-meta';
      const metaParts=[];
      if(data.slot) metaParts.push(slotLabel(data.slot));
      metaParts.push(rarityLabel(data.rarity) || data.type);
      meta.textContent=metaParts.filter(Boolean).join(' · ');
      const countEl=document.createElement('div');
      countEl.className='icon-count';
      countEl.textContent=`×${count}`;
      tile.appendChild(name);
      tile.appendChild(meta);
      tile.appendChild(countEl);
      return tile;
    }

    function buildRewardTile({id,count,data,source}){
      const wrap=document.createElement('div');
      wrap.className='reward-tile';
      const tile=buildItemTile({id,count,data,source});
      wrap.appendChild(tile);
      if(state.selected.source===source && state.selected.item===id){
        const actions=document.createElement('div');
        actions.className='reward-actions';
        const takeOneBtn=document.createElement('button');
        takeOneBtn.textContent='Take one';
        takeOneBtn.disabled=!hasCapacityFor(state.inventory,getBackpackLimit(),id,1);
        takeOneBtn.onclick=()=>claimRewardToInventory(source,id);
        actions.appendChild(takeOneBtn);
        if(count>1){
          const stackBtn=document.createElement('button');
          stackBtn.textContent='Take stack';
          stackBtn.disabled=!hasCapacityFor(state.inventory,getBackpackLimit(),id,count);
          stackBtn.onclick=()=>claimRewardStackToInventory(source,id);
          actions.appendChild(stackBtn);
        }
        if(data.slot){
          const equipBtn=document.createElement('button');
          equipBtn.textContent='Equip';
          equipBtn.disabled=!canEquipItem(id,source).ok;
          equipBtn.onclick=()=>equipRewardItem(source,id);
          actions.appendChild(equipBtn);
        }
        const scrapBtn=document.createElement('button');
        scrapBtn.textContent='Break down';
        scrapBtn.onclick=()=>scrapRewardItem(source,id);
        actions.appendChild(scrapBtn);
        wrap.appendChild(actions);
      }
      return wrap;
    }

    function buildEmptySlotTile(label){
      const tile=document.createElement('button');
      tile.type='button';
      tile.disabled=true;
      tile.className='icon-tile empty';
      const name=document.createElement('div');
      name.className='icon-name';
      name.textContent=label;
      const meta=document.createElement('div');
      meta.className='icon-meta';
      meta.textContent='Empty slot';
      tile.appendChild(name);
      tile.appendChild(meta);
      return tile;
    }

    function paginateEntries(entries,pageKey,pageSize){
      const totalPages=Math.max(1,Math.ceil(entries.length/pageSize));
      const safePage=clamp(state[pageKey] || 0,0,totalPages-1);
      state[pageKey]=safePage;
      const start=safePage*pageSize;
      return {entries:entries.slice(start,start+pageSize),page:safePage,totalPages};
    }

    function renderPager({page,totalPages,onPrev,onNext,label}){
      if(totalPages<=1) return null;
      const pager=document.createElement('div');
      pager.className='icon-pager';
      const prev=document.createElement('button');
      prev.textContent=label ? `Prev ${label}` : 'Prev';
      prev.disabled=page<=0;
      prev.onclick=onPrev;
      const info=document.createElement('div');
      info.className='page-info';
      info.textContent=`Page ${page+1} of ${totalPages}`;
      const next=document.createElement('button');
      next.textContent=label ? `Next ${label}` : 'Next';
      next.disabled=page>=totalPages-1;
      next.onclick=onNext;
      pager.appendChild(prev);
      pager.appendChild(info);
      pager.appendChild(next);
      return pager;
    }

    function renderItemDetails(){
      let {source,item}=state.selected;
      const sourceHasItem=()=>{
        if(!source || !item) return false;
        if(source==='inventory') return state.inventory.includes(item);
        if(source==='equipped') return state.equipped.includes(item);
        if(source==='stash') return state.stash.items.includes(item);
        if(source==='missionReward' || source==='idleReward') return rewardHasItem(source,item);
        return false;
      };
      if(source && item && !sourceHasItem()){
        state.selected={source:null,item:null};
        source=null;
        item=null;
      }
      const data=item?getItem(item):null;
      const vaultAccess=canAccessVault();
      const marketActive=canAccessMarket();
      const stashDefault=state.stashScreen==='market'
        ? 'Select backpack items to sell or break down in the trade bay.'
        : 'Select stash items to transfer, break down, or sell.';
      const targets=[
        {detail:dom.itemDetail,actions:dom.itemActions,default:'Select gear to view stats, uses, and actions.'},
        {detail:dom.stashDetail,actions:dom.stashItemActions,default:stashDefault}
      ];
      targets.forEach(target=>{
        if(!target.detail || !target.actions) return;
        if(!item || !data){
          target.detail.innerHTML=`<div class="command-hint">${target.default}</div>`;
        }else{
          const mods=formatMods(data.mods);
          const effects=formatEffects(data.effect);
          const uses=[];
          const breakdown=getBreakdownOutputs(item);
          const breakdownLabel=formatBreakdownOutput(breakdown);
          if(data.type==='consumable') uses.push('Consume for field boost.');
          if(data.slot) uses.push('Equip to gain passive bonuses.');
          uses.push('Break down into salvage.');
          if(data.type==='key') uses.push('Unlocks lockbox raids.');
          target.detail.innerHTML=`
            <div class="command-title">${item}</div>
            <div class="stat-list">
              <div>Type</div><span>${data.type}</span>
              <div>Rarity</div><span>${data.rarity}</span>
              <div>Value</div><span>${data.value || 1} credits</span>
              ${data.slot ? `<div>Slot</div><span>${slotLabel(data.slot)}</span>` : ''}
              ${breakdownLabel ? `<div>Breakdown</div><span>${breakdownLabel}</span>` : ''}
            </div>
            ${uses.length ? `<div class="small">${uses.join(' ')}</div>` : ''}
            ${effects.length ? `<div class="small"><b>Effects:</b> ${effects.join(' · ')}</div>` : ''}
            ${mods.length ? `<div class="small"><b>Mods:</b> ${mods.join(' · ')}</div>` : ''}
          `;
        }
        target.actions.innerHTML='';
      });
      if(!item || !data) return;

      const actionConfigs=[];
      if(source==='inventory'){
        const stackCount=getItemCount(state.inventory,item);
        const stackable=isStackable(item) || data.stackable;
        if(data.slot){
          const check=canEquipItem(item,'inventory');
          actionConfigs.push({
            label:'Deploy to loadout',
            action:()=>equipItem(item),
            disabled:!check.ok,
            blockedHint:check.ok ? '' : check.reason
          });
        }
        if(data.type==='consumable'){
          actionConfigs.push({label:'Use item',action:()=>consumeItem(item)});
        }
        if(vaultAccess){
          actionConfigs.push({
            label:'Route to vault',
            action:()=>stashItem(item),
            disabled:!hasCapacityFor(state.stash.items,state.stashLimit,item,1),
            blockedHint:''
          });
          if(stackable && stackCount>1){
            const halfCount=Math.floor(stackCount/2);
            actionConfigs.push({
              label:'Route stack to vault',
              action:()=>stashItemStack(item,stackCount),
              disabled:!hasCapacityFor(state.stash.items,state.stashLimit,item,stackCount),
              blockedHint:''
            });
            actionConfigs.push({
              label:'Route half stack',
              action:()=>stashItemStack(item,halfCount),
              disabled:halfCount<=0 || !hasCapacityFor(state.stash.items,state.stashLimit,item,halfCount),
              blockedHint:''
            });
          }
        }
        actionConfigs.push({label:'Break down into junk',action:()=>dismantleItem(item)});
        if(marketActive){
          actionConfigs.push({label:'Sell to market',action:()=>sellItem(item)});
          if(stackable && stackCount>1){
            const halfCount=Math.floor(stackCount/2);
            actionConfigs.push({label:'Sell stack',action:()=>sellItemStack(item,stackCount)});
            actionConfigs.push({label:'Sell half stack',action:()=>sellItemStack(item,halfCount),disabled:halfCount<=0});
          }
        }
      }else if(source==='equipped'){
        actionConfigs.push({label:'Return to backpack',action:()=>unequipItem(item),disabled:!canUnequipItem(item)});
      }else if(source==='stash'){
        actionConfigs.push({
          label:'Withdraw to backpack',
          action:()=>unstashItem(item),
          disabled:!vaultAccess || !hasCapacityFor(state.inventory,getBackpackLimit(),item,1),
          blockedHint:!vaultAccess ? vaultBlockedMessage : ''
        });
        actionConfigs.push({
          label:'Break down into junk',
          action:()=>scrapStashItem(item),
          disabled:!vaultAccess,
          blockedHint:!vaultAccess ? vaultBlockedMessage : ''
        });
        if(marketActive && vaultAccess){
          actionConfigs.push({
            label:'Sell to market',
            action:()=>sellStashItem(item)
          });
          const stackCount=getItemCount(state.stash.items,item);
          const stackable=isStackable(item) || data.stackable;
          if(stackable && stackCount>1){
            const halfCount=Math.floor(stackCount/2);
            actionConfigs.push({label:'Sell stack',action:()=>sellStashItemStack(item,stackCount)});
            actionConfigs.push({label:'Sell half stack',action:()=>sellStashItemStack(item,halfCount),disabled:halfCount<=0});
          }
        }
      }
      targets.forEach(target=>{
        if(!target.actions) return;
        actionConfigs.forEach(cfg=>{
          const btn=document.createElement('button');
          btn.textContent=cfg.label;
          if(cfg.disabled){
            btn.disabled=true;
            if(cfg.blockedHint){
              btn.title=cfg.blockedHint;
            }
          }
          btn.onclick=cfg.action;
          target.actions.appendChild(btn);
        });
        if(!actionConfigs.length){
          const msg=document.createElement('div');
          msg.className='command-hint';
          msg.textContent='No actions available.';
          target.actions.appendChild(msg);
        }
      });
    }

    function renderInventory(){
      dom.inventory.innerHTML='';
      dom.equipment.innerHTML='';
      if(!state.inventory.length){
        const empty=document.createElement('div');
        empty.className='muted-box';
        empty.textContent='Backpack empty. Run raids to pull more loot.';
        empty.classList.add('grid-span');
        dom.inventory.appendChild(empty);
      }else{
        const grouped=groupItems(state.inventory);
        const {entries,page,totalPages}=paginateEntries(grouped,'inventoryPage',GRID_PAGE_SIZE);
        entries.forEach(({id,count,data})=>{
          dom.inventory.appendChild(buildItemTile({id,count,data,source:'inventory'}));
        });
        const pager=renderPager({
          page,
          totalPages,
          label:'items',
          onPrev:()=>{state.inventoryPage=Math.max(0,page-1); renderInventory();},
          onNext:()=>{state.inventoryPage=Math.min(totalPages-1,page+1); renderInventory();}
        });
        if(pager){
          pager.classList.add('grid-span');
          dom.inventory.appendChild(pager);
        }
      }
      const equippedBySlot=Object.keys(EQUIPMENT_SLOTS).reduce((acc,key)=>{acc[key]=[];return acc;},{});
      state.equipped.forEach(item=>{
        const slot=getItem(item).slot;
        if(slot && equippedBySlot[slot]){
          equippedBySlot[slot].push(item);
        }
      });
      Object.entries(EQUIPMENT_SLOTS).forEach(([slot,count])=>{
        for(let i=0;i<count;i++){
          const item=equippedBySlot[slot].shift();
          if(item){
            dom.equipment.appendChild(buildItemTile({id:item,count:1,data:getItem(item),source:'equipped'}));
          }else{
            dom.equipment.appendChild(buildEmptySlotTile(slotLabel(slot)));
          }
        }
      });
      if(dom.backpackCount){
        dom.backpackCount.textContent=`(${getBackpackUsage()}/${getBackpackLimit()})`;
      }
      if(dom.loadoutCount){
        dom.loadoutCount.textContent=`(${getEquipmentUsageCount()}/${getEquipmentSlotTotal()})`;
      }
      dom.codex.textContent = state.codex[state.codex.length-1] || '';
    }

    function changeCraftingPage(delta){
      const totalPages=Math.max(1,Math.ceil(CRAFTING_RECIPES.length/CRAFTING_PAGE_SIZE));
      state.craftingPage=clamp(state.craftingPage+delta,0,totalPages-1);
      renderCrafting();
    }

    function changeMarketPage(delta){
      const zoneId=state.marketAccess.zoneId || state.zone.id;
      const totalPages=Math.max(1,Math.ceil(getMarketStockForZone(zoneId).length/MARKET_PAGE_SIZE));
      state.marketPage=clamp(state.marketPage+delta,0,totalPages-1);
      renderMarketStock();
    }

    function renderCrafting(){
      if(!dom.crafting) return;
      dom.crafting.innerHTML='';
      if(!CRAFTING_RECIPES.length){
        const empty=document.createElement('div');
        empty.className='muted-box';
        empty.textContent='No recipes available yet.';
        dom.crafting.appendChild(empty);
        return;
      }
      const totalPages=Math.max(1,Math.ceil(CRAFTING_RECIPES.length/CRAFTING_PAGE_SIZE));
      state.craftingPage=clamp(state.craftingPage,0,totalPages-1);
      const start=state.craftingPage*CRAFTING_PAGE_SIZE;
      const visibleRecipes=CRAFTING_RECIPES.slice(start,start+CRAFTING_PAGE_SIZE);
      const grid=document.createElement('div');
      grid.className='recipe-grid';
      visibleRecipes.forEach(recipe=>{
        const card=document.createElement('div');
        card.className='recipe-card';
        const titleRow=document.createElement('div');
        titleRow.className='title-row';
        titleRow.innerHTML=`<span>${recipe.label}</span><span class="small">craft</span>`;
        const desc=document.createElement('div');
        desc.className='small';
        desc.textContent=recipe.desc;
        const reqs=document.createElement('div');
        reqs.className='reqs';
        const reqParts=Object.entries(recipe.cost).map(([id,count])=>{
          const have=getItemCount(state.inventory,id);
          const status=have>=count?'✓':'•';
          return `${status} ${id} ${have}/${count}`;
        });
        reqs.textContent=reqParts.join(' · ');
        const craftBtn=document.createElement('button');
        craftBtn.textContent=`Craft ${recipe.label}`;
        const canCraft=hasCraftingMaterials(recipe) && hasCapacityFor(state.inventory,getBackpackLimit(),recipe.id,1);
        craftBtn.disabled=!canCraft;
        if(!hasCraftingMaterials(recipe)) craftBtn.title='Missing materials.';
        else if(!hasCapacityFor(state.inventory,getBackpackLimit(),recipe.id,1)) craftBtn.title='Backpack capacity reached.';
        craftBtn.onclick=()=>craftRecipe(recipe.id);
        card.appendChild(titleRow);
        card.appendChild(desc);
        card.appendChild(reqs);
        card.appendChild(craftBtn);
        grid.appendChild(card);
      });
      dom.crafting.appendChild(grid);
      if(totalPages>1){
        const pager=document.createElement('div');
        pager.className='pager';
        const prev=document.createElement('button');
        prev.textContent='Previous recipes';
        prev.disabled=state.craftingPage===0;
        prev.onclick=()=>changeCraftingPage(-1);
        const info=document.createElement('div');
        info.className='page-info';
        const end=Math.min(CRAFTING_RECIPES.length,start+visibleRecipes.length);
        info.textContent=`Showing recipes ${start+1}-${end} of ${CRAFTING_RECIPES.length}`;
        const next=document.createElement('button');
        next.textContent='More recipes';
        next.disabled=state.craftingPage>=totalPages-1;
        next.onclick=()=>changeCraftingPage(1);
        pager.appendChild(prev);
        pager.appendChild(info);
        pager.appendChild(next);
        dom.crafting.appendChild(pager);
      }
    }

    function renderMarketStock(){
      if(!dom.marketInventory) return;
      dom.marketInventory.innerHTML='';
      const marketActive=canAccessMarket();
      const zoneId=state.marketAccess.zoneId || state.zone.id;
      const stockList=getMarketStockForZone(zoneId);
      if(dom.marketHint){
        const zoneName=expansions[zoneId]?.meta?.name || state.zone.name;
        dom.marketHint.textContent=marketActive
          ? `Market vendors are online in ${zoneName}. Trade while the shop is open.`
          : 'Visit a shop in your current location to access vendors.';
      }
      const totalPages=Math.max(1,Math.ceil(stockList.length/MARKET_PAGE_SIZE));
      state.marketPage=clamp(state.marketPage,0,totalPages-1);
      const start=state.marketPage*MARKET_PAGE_SIZE;
      const visibleStock=stockList.slice(start,start+MARKET_PAGE_SIZE);
      const grid=document.createElement('div');
      grid.className='market-grid';
      visibleStock.forEach(stock=>{
        const data=getItem(stock.id);
        const card=document.createElement('div');
        card.className='market-card';
        const titleRow=document.createElement('div');
        titleRow.className='title-row';
        titleRow.innerHTML=`<span>${stock.id}</span><span class="small">${stock.tag}</span>`;
        const desc=document.createElement('div');
        desc.className='small';
        desc.textContent=`${rarityLabel(data.rarity)} · ${data.type}`;
        const cost=document.createElement('div');
        cost.className='cost';
        cost.textContent=`${stock.cost} credits`;
        const btn=document.createElement('button');
        btn.textContent=`Buy ${stock.id}`;
        const canBuy=marketActive && state.credits>=stock.cost && hasCapacityFor(state.inventory,getBackpackLimit(),stock.id,1);
        btn.disabled=!canBuy;
        if(!marketActive) btn.title='Visit a shop to buy.';
        else if(!hasCapacityFor(state.inventory,getBackpackLimit(),stock.id,1)) btn.title='Backpack full.';
        else if(state.credits<stock.cost) btn.title='Not enough credits.';
        btn.onclick=()=>buyMarketItem(stock.id);
        card.appendChild(titleRow);
        card.appendChild(desc);
        card.appendChild(cost);
        card.appendChild(btn);
        grid.appendChild(card);
      });
      dom.marketInventory.appendChild(grid);
      if(totalPages>1){
        const pager=document.createElement('div');
        pager.className='pager';
        const prev=document.createElement('button');
        prev.textContent='Previous items';
        prev.disabled=state.marketPage===0;
        prev.onclick=()=>changeMarketPage(-1);
        const info=document.createElement('div');
        info.className='page-info';
        const end=Math.min(stockList.length,start+visibleStock.length);
        info.textContent=`Showing items ${start+1}-${end} of ${stockList.length}`;
        const next=document.createElement('button');
        next.textContent='More items';
        next.disabled=state.marketPage>=totalPages-1;
        next.onclick=()=>changeMarketPage(1);
        pager.appendChild(prev);
        pager.appendChild(info);
        pager.appendChild(next);
        dom.marketInventory.appendChild(pager);
      }
    }

    function renderIdleOps(){
      dom.idleOps.innerHTML='';
      const gearMods=getGearMods();
      const vaultAccess=canAccessVault();
      if(state.idleOps.active){
        const op=idleOperations.find(entry=>entry.id===state.idleOps.id);
        const startedAt=Number.isFinite(state.idleOps.startedAt) ? state.idleOps.startedAt : Date.now();
        const elapsed=Math.max(0,(Date.now()-startedAt)/1000);
        const total=Math.max(1,state.idleOps.durationMs/1000);
        const pctDone=clamp((elapsed/total)*100,0,100);
        const card=document.createElement('div');
        card.className='op-card';
        const title=document.createElement('div');
        title.innerHTML=`<b>${op.label}</b> · in progress`;
        const progress=document.createElement('div');
        progress.className='progress';
        progress.innerHTML=`<span style="width:${pctDone}%;"></span>`;
        const meta=document.createElement('div');
        meta.className='op-meta';
        const remainingMinutes=Math.max(0,(total-elapsed)/60);
        meta.textContent=`ETA ${formatMinutesPrecise(remainingMinutes)} · ${op.desc}`;
        const signal=document.createElement('div');
        signal.className='op-meta';
        signal.textContent=state.idleOps.statusMessage || 'Operation underway.';
        card.appendChild(title);
        card.appendChild(progress);
        card.appendChild(meta);
        card.appendChild(signal);
        dom.idleOps.appendChild(card);
        return;
      }
      if(state.idleOps.completed){
        const op=idleOperations.find(entry=>entry.id===state.idleOps.id);
        const card=document.createElement('div');
        card.className='op-card';
        const title=document.createElement('div');
        title.innerHTML=`<b>${op?.label || 'Idle operation'}</b> · complete`;
        const meta=document.createElement('div');
        meta.className='op-meta';
        meta.textContent=state.idleOps.statusMessage || 'Rewards ready to review.';
        card.appendChild(title);
        card.appendChild(meta);
        const rewardsWrap=document.createElement('div');
        rewardsWrap.className='item-grid';
        const rewards=state.idleOps.rewards || [];
        if(rewards.length){
          groupItems(rewards).forEach(({id,count,data})=>{
            const row=buildItemRow({id,count,data,source:'idleReward'});
            rewardsWrap.appendChild(row);
            const actions=document.createElement('div');
            actions.className='inline-actions';
            const packBtn=document.createElement('button');
            packBtn.textContent='Take one';
            packBtn.disabled=!hasCapacityFor(state.inventory,getBackpackLimit(),id,1);
            packBtn.onclick=()=>claimRewardToInventory('idleReward',id);
            actions.appendChild(packBtn);
            const stackBtn=document.createElement('button');
            stackBtn.textContent='Take stack';
            stackBtn.disabled=!hasCapacityFor(state.inventory,getBackpackLimit(),id,count);
            stackBtn.onclick=()=>claimRewardStackToInventory('idleReward',id);
            actions.appendChild(stackBtn);
            if(data.slot){
              const equipBtn=document.createElement('button');
              equipBtn.textContent='Equip';
              equipBtn.disabled=!canEquipItem(id,'idleReward').ok;
              equipBtn.onclick=()=>equipRewardItem('idleReward',id);
              actions.appendChild(equipBtn);
            }
            const vaultBtn=document.createElement('button');
            vaultBtn.textContent='Vault';
            vaultBtn.disabled=!vaultAccess || !hasCapacityFor(state.stash.items,state.stashLimit,id,1);
            vaultBtn.title=vaultAccess ? '' : vaultBlockedMessage;
            vaultBtn.onclick=()=>claimRewardToVault('idleReward',id);
            actions.appendChild(vaultBtn);
            const scrapBtn=document.createElement('button');
            scrapBtn.textContent='Break down';
            scrapBtn.onclick=()=>scrapRewardItem('idleReward',id);
            actions.appendChild(scrapBtn);
            const leaveBtn=document.createElement('button');
            leaveBtn.textContent='Leave';
            leaveBtn.onclick=()=>leaveRewardItem('idleReward',id);
            actions.appendChild(leaveBtn);
            rewardsWrap.appendChild(actions);
          });
        }else{
          const empty=document.createElement('div');
          empty.className='muted-box';
          empty.textContent='Rewards resolved. Close the operation to dispatch again.';
          rewardsWrap.appendChild(empty);
        }
        card.appendChild(rewardsWrap);
        const footer=document.createElement('div');
        footer.className='op-actions';
        if(rewards.length){
          const leaveAll=document.createElement('button');
          leaveAll.textContent='Leave all rewards';
          leaveAll.onclick=()=>clearRewardSource('idleReward');
          footer.appendChild(leaveAll);
        }
        const closeBtn=document.createElement('button');
        closeBtn.textContent='Close operation';
        closeBtn.disabled=rewards.length>0;
        closeBtn.onclick=closeIdleOp;
        footer.appendChild(closeBtn);
        card.appendChild(footer);
        dom.idleOps.appendChild(card);
      }
      const blockedDispatch=state.idleOps.active || state.idleOps.completed;
      idleOperations.forEach(op=>{
        const card=document.createElement('div');
        card.className='op-card';
        const title=document.createElement('div');
        title.innerHTML=`<b>${op.label}</b>`;
        const meta=document.createElement('div');
        meta.className='op-meta';
        const duration=getIdleDurationMinutes(op,gearMods);
        meta.textContent=`${op.desc} · ${formatMinutesPrecise(duration)}`;
        const cost=document.createElement('div');
        cost.className='op-meta';
        cost.textContent=`Cost: ${formatCost(op.cost)} · Reward: ${op.reward}`;
        const actions=document.createElement('div');
        actions.className='op-actions';
        const btn=document.createElement('button');
        btn.textContent='Dispatch';
        btn.onclick=()=>startIdleOp(op.id);
        if(blockedDispatch || !canAfford(op.cost)) btn.disabled=true;
        if(state.idleOps.completed && (state.idleOps.rewards?.length||0)>0){
          btn.title='Resolve idle rewards before dispatching again.';
        }
        actions.appendChild(btn);
        card.appendChild(title);
        card.appendChild(meta);
        card.appendChild(cost);
        card.appendChild(actions);
        dom.idleOps.appendChild(card);
      });
    }

    function setActiveTab(tab){
      activeTab=tab;
      syncTabs();
    }

    function syncTabs(){
      dom.tabButtons.forEach(btn=>{
        const target=btn.dataset.tab;
        btn.classList.toggle('active',target===activeTab);
        btn.disabled=false;
      });
      if(state.mission.active){
        const stashBtn=dom.tabButtons.find(btn=>btn.dataset.tab==='field');
        if(stashBtn) stashBtn.disabled=true;
      }
      Object.entries(dom.tabContents).forEach(([id,el])=>{
        el.classList.toggle('active',id===activeTab);
      });
    }

    dom.tabButtons.forEach(btn=>{
      btn.onclick=()=>{ activeTab=btn.dataset.tab; syncTabs(); };
    });

    function setInventoryScreen(screen){
      const changed=state.inventoryScreen!==screen;
      state.inventoryScreen=screen;
      dom.inventoryNav.forEach(btn=>{
        btn.classList.toggle('active',btn.dataset.invScreen===screen);
      });
      Object.entries(dom.inventoryScreens).forEach(([id,el])=>{
        el.classList.toggle('active',id===screen);
      });
      if(changed){
        clearSelection();
      }
    }

    function setStashScreen(screen){
      const changed=state.stashScreen!==screen;
      state.stashScreen=screen;
      dom.stashNav.forEach(btn=>{
        btn.classList.toggle('active',btn.dataset.stashScreen===screen);
      });
      Object.entries(dom.stashScreens).forEach(([id,el])=>{
        el.classList.toggle('active',id===screen);
      });
      if(changed){
        clearSelection();
      }
    }

    dom.inventoryNav.forEach(btn=>{
      btn.onclick=()=>setInventoryScreen(btn.dataset.invScreen);
    });

    dom.stashNav.forEach(btn=>{
      btn.onclick=()=>setStashScreen(btn.dataset.stashScreen);
    });

    function clearSelection(){
      if(!state.selected.source) return;
      state.selected={source:null,item:null};
      renderItemDetails();
      renderInventory();
      renderStash();
      renderMissionStatus();
      renderIdleOps();
    }

    function selectItem(source,item){
      state.selected={source,item};
      renderItemDetails();
      renderInventory();
      renderStash();
      renderMissionStatus();
      renderIdleOps();
    }

    function isMissionBlockingTravel(){
      return state.mission.active && !state.mission.completed;
    }

    function isRewardBlockingTravel(){
      return state.mission.active && state.mission.completed && (state.mission.rewards?.length||0)>0;
    }

    function syncMissionCompletion(){
      if(!state.mission.active || state.mission.completed) return;
      const now=Date.now();
      normalizeMissionTiming(now);
      if(state.mission.type==='combat'){
        combatTick(now);
        if(state.mission.completed) return;
        if(state.mission.fleeing && now>=state.mission.endsAt){
          completeMission({combatResolved:true});
        }else if(now>=state.mission.endsAt){
          completeMission({combatResolved:true,forcedFail:true});
        }
        return;
      }
      if(now>=state.mission.endsAt){
        completeMission();
      }
    }

    function setScreen(screen){
      syncMissionCompletion();
      if(screen==='locations' && isMissionBlockingTravel()){
        setCodex('Mission in progress. Locations hub locked.');
        return;
      }
      if(screen==='main' && isMissionBlockingTravel()){
        setCodex('Mission in progress. Stay on the raid feed.');
        return;
      }
      if(screen==='mission' && !state.mission.active){
        setCodex('No mission active.');
        return;
      }
      state.screen=screen;
      if(screen==='locations'){
        ensureExpansionsLoaded();
      }
      renderAll();
    }

    function renderScreens(){
      syncMissionCompletion();
      dom.screenButtons.forEach(btn=>{
        const target=btn.dataset.screen;
        const isLocked=target==='mission' && !state.mission.active;
        const isLocationsLocked=target==='locations' && isMissionBlockingTravel();
        const isMainLocked=target==='main' && isMissionBlockingTravel();
        btn.classList.toggle('active',target===state.screen);
        btn.disabled=isLocked || isLocationsLocked || isMainLocked;
      });
      if(dom.enterLocations){
        dom.enterLocations.disabled=isMissionBlockingTravel();
      }
      Object.entries(dom.screens).forEach(([id,el])=>{
        el.classList.toggle('active',id===state.screen);
      });
    }

    dom.screenButtons.forEach(btn=>{
      btn.onclick=()=>setScreen(btn.dataset.screen);
    });
    dom.enterLocations.onclick=()=>setScreen('locations');
    dom.returnMain.onclick=()=>setScreen('main');

    function renderExcursionStatus(){
      const scene=ensureZoneScene(state.zone);
      const locationLabel=scene?.title ? `${state.zone.name} · ${scene.title}` : state.zone.name;
      dom.excursionStatus.innerHTML=`<b>Loop status:</b> Location ${locationLabel} · Energy ${state.energy}/${state.maxEnergy} · Backpack ${getBackpackUsage()}/${getBackpackLimit()} · Stash ${getStashUsage()}/${state.stashLimit} · Loadout ${getEquipmentUsageCount()}/${getEquipmentSlotTotal()}.`;
      dom.tempoHint.textContent='Run missions to earn XP, then review rewards and swap in better gear.';
    }

    function renderHubAccess(){
      dom.hubLock.textContent=isMissionBlockingTravel()
        ? 'Mission underway. Await extraction clearance before entering locations hub.'
        : state.mission.active
          ? 'Mission resolved. Review rewards, then redeploy from the locations hub.'
          : 'Ops bay is live. Step into the locations hub to pick a gate and launch a raid.';
    }

    function renderZone(){
      const scene=ensureZoneScene(state.zone);
      dom.zoneTitle.textContent=scene?.title ? `${state.zone.name} · ${scene.title}` : state.zone.name;
      dom.zoneDesc.textContent=scene?.desc || state.zone.desc;
      dom.zoneBadge.textContent=`${state.zone.risk} risk`;
    }

    function formatRewardEstimate({loot=0,lootType='',reward='',risk='low',time=8,xp}={}){
      const parts=[];
      if(loot){
        const min=Math.max(1,loot);
        const max=Math.max(min,loot+2);
        const lootLabel=`${min}-${max} loot`;
        parts.push(lootType ? `${lootLabel} ${lootType}` : lootLabel);
      }
      if(reward) parts.push(reward);
      const xpValue=Number.isFinite(xp) ? xp : computeMissionXp(risk,time);
      if(xpValue) parts.push(`XP ${xpValue}`);
      return parts.length ? `Rewards ${parts.join(' · ')}` : '';
    }

    function buildMissionMeta({risk='low',time=8,energy,key,loot=0,lootType='',reward='',xp}={}){
      const parts=[`${risk} · ${formatDisplayMinutes(time)} min`];
      const rewardLabel=formatRewardEstimate({loot,lootType,reward,risk,time,xp});
      if(rewardLabel) parts.push(rewardLabel);
      if(Number.isFinite(energy)){
        const costParts=[`${energy} energy`];
        if(key) costParts.push(`${key} key`);
        parts.push(costParts.join(' · '));
      }
      return parts.join(' · ');
    }

    function renderRaidActions(){
      dom.raidActions.innerHTML='';
      const exp=expansions[state.zone.id];
      const scene=ensureZoneScene(state.zone);
      if(scene && scene.options && scene.options.length){
        scene.options.forEach(option=>{
          const optionFlag=option.flag;
          if(option.once && optionFlag && state.flags.has(optionFlag)) return;
          const btn=document.createElement('button');
          const label=option.label || 'Local action';
          const meta=buildMissionMeta({
            risk:option.risk,
            time:option.time,
            loot:option.loot,
            lootType:option.lootType,
            reward:option.reward
          });
          btn.innerHTML=`<span>${label}</span><span class="small">${meta}</span>`;
          btn.onclick=()=>startSceneAction(option);
          if(state.mission.active || state.travel.active) btn.disabled=true;
          if(option.risk==='high') btn.classList.add('danger');
          dom.raidActions.appendChild(btn);
        });
      }
      const vendorEligible=zoneHasShop();
      if(vendorEligible){
        const shopBtn=document.createElement('button');
        shopBtn.innerHTML=`<span>Visit shop</span><span class="small">trade · vendors</span>`;
        shopBtn.onclick=()=>openMarketAccess();
        if(state.mission.active || state.travel.active) shopBtn.disabled=true;
        dom.raidActions.appendChild(shopBtn);
      }
      if(exp && exp.quests && exp.quests.length){
        exp.quests.forEach(quest=>{
          const btn=document.createElement('button');
          const questFlag=quest.flag || quest.id;
          const completed=quest.once && questFlag && state.flags.has(questFlag);
          const label=quest.title || 'Local contract';
          const time=quest.time || 10;
          const risk=quest.risk || state.zone.risk;
          const energy=quest.energy ?? 12;
          const keyCost=quest.key || 0;
          const meta=buildMissionMeta({
            risk,
            time,
            energy,
            key:keyCost,
            loot:quest.loot || 0,
            lootType:quest.lootType || '',
            reward:quest.reward || ''
          });
          btn.innerHTML=`<span>${label}</span><span class="small">${meta}</span>`;
          btn.onclick=()=>runQuest(quest);
          if(completed){
            btn.disabled=true;
            btn.title='Contract complete.';
          }else if(state.mission.active || state.travel.active || !canAfford({energy,keys:keyCost})){
            btn.disabled=true;
          }
          if(risk==='high') btn.classList.add('danger');
          dom.raidActions.appendChild(btn);
        });
      }
      if(isHubZone() && !dom.raidActions.children.length){
        const blocked=document.createElement('div');
        blocked.className='muted-box';
        blocked.textContent='Hub zone secure. Use the transit console to select a field site.';
        dom.raidActions.appendChild(blocked);
        return;
      }
      if(!isHubZone()){
        const missions=(exp?.missions && exp.missions.length) ? exp.missions : RAID_TEMPLATES;
        missions.forEach(raid=>{
          const btn=document.createElement('button');
          const meta=buildMissionMeta({
            risk:raid.risk,
            time:raid.time,
            energy:raid.energy,
            key:raid.key,
            loot:raid.loot,
            lootType:raid.lootType,
            reward:raid.reward,
            xp:raid.xp
          });
          btn.innerHTML=`<span>${raid.label}</span><span class="small">${meta}</span>`;
          btn.onclick=()=>startMission(raid);
          if(state.mission.active || state.travel.active || !canAfford({energy:raid.energy,keys:raid.key||0})) btn.disabled=true;
          if(raid.risk==='high') btn.classList.add('danger');
          dom.raidActions.appendChild(btn);
        });
        const combatBtn=document.createElement('button');
        const combatProfile=getCombatProfile(state.zone.risk);
        const combatMeta=buildMissionMeta({
          risk:combatProfile.risk,
          time:combatProfile.time,
          energy:10,
          loot:2+Math.floor(combatProfile.difficulty),
          lootType:'combat salvage',
          xp:computeMissionXp(combatProfile.risk,combatProfile.time)
        });
        combatBtn.innerHTML=`<span>Engage hostiles</span><span class="small">${combatMeta}</span>`;
        combatBtn.onclick=startCombatMission;
        if(state.mission.active || state.travel.active || !canAfford({energy:10})) combatBtn.disabled=true;
        combatBtn.classList.add('danger');
        dom.raidActions.appendChild(combatBtn);
        const canCamp=state.screen==='locations' && state.zone.id!=='safehouse';
        if(canCamp){
          const rest=document.createElement('button');
        rest.innerHTML=`<span>Make camp</span><span class="small">recover · ${formatDisplayMinutes(ACTION_TIMES.camp)} min</span>`;
          rest.onclick=runCamp;
          if(state.mission.active || state.travel.active) rest.disabled=true;
          dom.raidActions.appendChild(rest);
        }
      }
    }

    function openMarketAccess(){
      if(state.mission.active || state.travel.active){
        setCodex('Finish current operations before visiting vendors.');
        return;
      }
      if(!zoneHasShop()){
        setCodex('No vendors are set up here.');
        return;
      }
      state.marketAccess={active:true,zoneId:state.zone.id};
      state.marketPage=0;
      setCodex('Vendor bay open. Trade out of your active pack while the shop is live.');
      setActiveTab('field');
      setStashScreen('market');
      renderAll();
    }

    function startSceneAction(option){
      if(state.mission.active){
        setCodex('Mission already underway.');
        return;
      }
      if(state.travel.active){
        setCodex('Finish travel before taking local action.');
        return;
      }
      startLoops();
      const label=option.label || 'Local action';
      const risk=option.risk || state.zone.risk;
      const time=option.time || 8;
      const durationMs=computeMissionDurationMs({risk,time,loot:option.loot});
      const raidLike={
        id:`scene-${Date.now()}`,
        label,
        desc:'',
        time,
        energy:0,
        loot:0,
        risk
      };
      const now=Date.now();
      state.mission={
        active:true,
        type:'scene',
        raid:raidLike,
        startedAt:now,
        endsAt:now+durationMs,
        completed:false,
        success:null,
        summary:'',
        rewards:[],
        statusMessage:`Action underway: ${label}.`,
        location:{...state.zone},
        fleeing:false,
        fleeEndsAt:null,
        pendingResolution:null,
        xpReward:computeMissionXp(risk,time),
        rewardEffects:{success:option.success||'',fail:option.fail||''},
        questMeta:null,
        combat:null,
        sceneTarget:option.target || null
      };
      setCodex(`Action launched: ${label}.`);
      logMsg(`Local action: ${label} (${formatDisplayMinutes(time)} min).`);
      setActiveTab('hub');
      setScreen('mission');
      normalizeMissionTiming(Date.now());
      renderAll();
    }

    function resolveTravelIfComplete(){
      if(!state.travel.active) return false;
      if(!state.travel.target || !state.travel.endsAt){
        state.travel={active:false,endsAt:null,target:null};
        setCodex('Transit data lost. Select a zone gate to reroute.');
        logMsg('Transit data lost. Zone selection reset.');
        if(travelResolveTimer){
          clearTimeout(travelResolveTimer);
          travelResolveTimer=null;
        }
        return true;
      }
      if(Date.now()<state.travel.endsAt) return false;
      state.zone=state.travel.target;
      clearMarketAccess();
      state.travel={active:false,endsAt:null,target:null};
      setCodex(`Arrived at ${state.zone.name}.`);
      logMsg(`Transit complete: ${state.zone.name}.`);
      saveGame();
      if(travelResolveTimer){
        clearTimeout(travelResolveTimer);
        travelResolveTimer=null;
      }
      return true;
    }

    function renderTravelStatus(){
      if(resolveTravelIfComplete()){
        return renderTravelStatus();
      }
      const doorButtons=dom.doors.querySelectorAll('button');
      doorButtons.forEach(btn=>{
        btn.disabled=state.mission.active || state.travel.active || isRewardBlockingTravel();
      });
      if(state.travel.active){
        scheduleTravelResolution();
        const targetName=state.travel.target?.name || 'unknown gate';
        dom.travelStatus.innerHTML=`<span class="spinner"></span><span>Routing to ${targetName}… hold tight.</span>`;
      }else{
        dom.travelStatus.textContent='Transit clear. Select a zone gate to jump.';
      }
    }

    function renderMissionStatus(){
      if(!state.mission.active){
        dom.missionTitle.textContent='No mission active.';
        dom.missionMeta.textContent='Launch a raid from the locations hub to enter the field.';
        dom.missionProgress.querySelector('span').style.width='0%';
        dom.missionLog.textContent='';
        dom.missionActions.innerHTML='';
        if(dom.missionRewardsCard) dom.missionRewardsCard.style.display='none';
        if(dom.missionRewardList) dom.missionRewardList.innerHTML='';
        if(dom.missionRewardHint) dom.missionRewardHint.textContent='Complete a mission to review rewards.';
        return;
      }
      const raid=state.mission.raid;
      const remainingMs=Math.max(0,state.mission.endsAt-Date.now());
      const totalMs=Math.max(1,state.mission.endsAt-state.mission.startedAt);
      const percent=clamp(((totalMs-remainingMs)/totalMs)*100,0,100);
      dom.missionProgress.querySelector('span').style.width=`${state.mission.completed ? 100 : percent}%`;
      const remainingSec=Math.ceil(remainingMs/1000);
      const labelPrefix=state.mission.type==='combat'
        ? 'In combat'
        : (state.mission.type==='contract'
          ? 'In contract'
          : (state.mission.type==='scene' ? 'In action' : 'In raid'));
      dom.missionTitle.textContent=state.mission.completed
        ? `Mission complete: ${raid.label}`
        : `${labelPrefix}: ${raid.label}`;
      const etaLabel=state.mission.fleeing ? 'Escaping…' : `ETA ${remainingSec}s`;
      dom.missionMeta.textContent=`${raid.risk} risk · ${formatDisplayMinutes(raid.time)} min op · ${state.mission.location?.name || state.zone.name} · XP ${state.mission.xpReward || computeMissionXp(raid.risk,raid.time)} · ${state.mission.completed ? 'Rewards ready' : etaLabel}`;
      const liveMessage=state.mission.statusMessage || state.mission.summary;
      dom.missionLog.textContent=liveMessage || 'Stay sharp. Watch the feed for extraction clearance.';
      dom.missionActions.innerHTML='';
      const rewards=state.mission.rewards || [];
      const rewardsReady=state.mission.completed && rewards.length>0;
      if(state.mission.completed && rewards.length===0){
        autoCloseMissionIfResolved();
        if(!state.mission.active) return;
      }
      if(dom.missionRewardsCard){
        dom.missionRewardsCard.style.display=state.mission.completed ? 'flex' : 'none';
      }
      if(dom.missionRewardList){
        dom.missionRewardList.innerHTML='';
        if(rewardsReady){
          if(dom.missionRewardHint) dom.missionRewardHint.textContent='Select a reward to choose an action.';
          const grid=document.createElement('div');
          grid.className='icon-grid';
          groupItems(rewards).forEach(({id,count,data})=>{
            grid.appendChild(buildRewardTile({id,count,data,source:'missionReward'}));
          });
          dom.missionRewardList.appendChild(grid);
        }else if(state.mission.completed){
          if(dom.missionRewardHint) dom.missionRewardHint.textContent='Rewards resolved.';
          const empty=document.createElement('div');
          empty.className='muted-box';
          empty.textContent=state.mission.success ? 'No rewards remaining. Mission will close automatically.' : 'Mission failed. Mission will close automatically.';
          dom.missionRewardList.appendChild(empty);
        }
      }
      if(!state.mission.completed && state.mission.type==='combat'){
        const combat=state.mission.combat;
        if(combat){
          const hud=document.createElement('div');
          hud.className='combat-hud';
          const title=document.createElement('div');
          title.className='combat-title';
          title.textContent=`Signal log: ${raid.enemyName}`;
          const stats=document.createElement('div');
          stats.className='combat-stats';
          const consumeState=combat.consumable
            ? `Applying ${combat.consumable.item} (${Math.max(0,Math.ceil((combat.consumable.readyAt-Date.now())/1000))}s)`
            : 'No consumable in use';
          stats.innerHTML=`<div><b>Enemy HP</b> ${Math.max(0,Math.round(combat.enemyHp))}/${Math.round(combat.enemyMaxHp)}</div>`+
            `<div><b>Enemies left</b> ${combat.enemiesRemaining}/${combat.totalEnemies}</div>`+
            `<div><b>You dealt</b> ${Math.round(combat.totalDamageDealt)}</div>`+
            `<div><b>You took</b> ${Math.round(combat.totalDamageTaken)}</div>`+
            `<div><b>Consumable</b> ${consumeState}</div>`;
          hud.appendChild(title);
          hud.appendChild(stats);
          const consumables=document.createElement('div');
          consumables.className='combat-consumables';
          const consumableItems=groupItems(state.inventory.filter(item=>getItem(item).type==='consumable'));
          if(consumableItems.length){
            const hint=document.createElement('div');
            hint.className='small';
            hint.textContent='Backpack consumables (3s channel, one at a time):';
            consumables.appendChild(hint);
            consumableItems.forEach(({id,count})=>{
              const btn=document.createElement('button');
              btn.textContent=`Use ${id} ×${count}`;
              btn.disabled=Boolean(combat.consumable);
              btn.onclick=()=>applyCombatConsumable(id);
              consumables.appendChild(btn);
            });
          }else{
            const empty=document.createElement('div');
            empty.className='small';
            empty.textContent='No consumables in backpack.';
            consumables.appendChild(empty);
          }
          hud.appendChild(consumables);
          dom.missionActions.appendChild(hud);
        }
        const fleeBtn=document.createElement('button');
        fleeBtn.textContent=state.mission.fleeing ? 'Fleeing…' : 'Flee (5s)';
        fleeBtn.disabled=state.mission.fleeing;
        fleeBtn.onclick=attemptFlee;
        dom.missionActions.appendChild(fleeBtn);
      }
      if(state.mission.completed){
        if(rewardsReady){
          const leaveAll=document.createElement('button');
          leaveAll.textContent='Leave all rewards';
          leaveAll.onclick=()=>clearRewardSource('missionReward');
          dom.missionActions.appendChild(leaveAll);
        }
        const closeBtn=document.createElement('button');
        closeBtn.textContent='Close mission';
        closeBtn.disabled=rewards.length>0;
        closeBtn.onclick=closeMission;
        dom.missionActions.appendChild(closeBtn);
      }
    }

    function renderStash(){
      dom.stash.innerHTML='';
      dom.marketBackpack.innerHTML='';
      dom.stashActions.innerHTML='';
      const vaultAccess=canAccessVault();
      const marketActive=canAccessMarket();
      const inMarketScreen=state.stashScreen==='market';
      if(dom.stashTitle){
        dom.stashTitle.textContent=inMarketScreen ? 'Trade Bay' : 'Stash Vault';
      }
      if(dom.stashCommandTitle){
        dom.stashCommandTitle.textContent=inMarketScreen ? 'Trade Console' : 'Vault Command Card';
      }
      if(inMarketScreen){
        if(dom.marketSubtitle){
          dom.marketSubtitle.innerHTML=`Backpack Inventory <span class="small" id="marketBackpackCount"></span>`;
          dom.marketBackpackCount=document.getElementById('marketBackpackCount');
        }
        if(dom.marketBackpackCount){
          dom.marketBackpackCount.textContent=`(${getBackpackUsage()}/${getBackpackLimit()})`;
        }
        const items=state.inventory;
        if(!items.length){
          const empty=document.createElement('div');
          empty.className='muted-box';
          empty.textContent='Backpack is empty. Trade when you have gear on hand.';
          dom.marketBackpack.appendChild(empty);
        }else{
          const grid=document.createElement('div');
          grid.className='icon-grid';
          const grouped=groupItems(items);
          const {entries,page,totalPages}=paginateEntries(grouped,'stashPage',GRID_PAGE_SIZE);
          entries.forEach(({id,count,data})=>{
            grid.appendChild(buildItemTile({id,count,data,source:'inventory'}));
          });
          dom.marketBackpack.appendChild(grid);
          const pager=renderPager({
            page,
            totalPages,
            label:'items',
            onPrev:()=>{state.stashPage=Math.max(0,page-1); renderStash();},
            onNext:()=>{state.stashPage=Math.min(totalPages-1,page+1); renderStash();}
          });
          if(pager) dom.marketBackpack.appendChild(pager);
        }
        const notice=document.createElement('div');
        notice.className='muted-box';
        notice.textContent=marketActive
          ? 'Trade bay open. Select backpack items to sell or break down.'
          : 'Visit a shop to trade with local vendors.';
        dom.stashActions.appendChild(notice);
        renderMarketStock();
        return;
      }
      if(dom.stashSubtitle){
        dom.stashSubtitle.innerHTML=`Vault Inventory <span class="small" id="stashCount"></span>`;
        dom.stashCount=document.getElementById('stashCount');
      }
      if(dom.stashCount){
        dom.stashCount.textContent=`(${getStashUsage()}/${state.stashLimit})`;
      }
      const items=state.stash.items;
      if(!items.length){
        const empty=document.createElement('div');
        empty.className='muted-box';
        empty.textContent='Stash is empty. Move loot here for long-term storage.';
        dom.stash.appendChild(empty);
      }else{
        const grid=document.createElement('div');
        grid.className='icon-grid';
        const grouped=groupItems(items);
        const {entries,page,totalPages}=paginateEntries(grouped,'stashPage',GRID_PAGE_SIZE);
        entries.forEach(({id,count,data})=>{
          grid.appendChild(buildItemTile({id,count,data,source:'stash'}));
        });
        dom.stash.appendChild(grid);
        const pager=renderPager({
          page,
          totalPages,
          label:'items',
          onPrev:()=>{state.stashPage=Math.max(0,page-1); renderStash();},
          onNext:()=>{state.stashPage=Math.min(totalPages-1,page+1); renderStash();}
        });
        if(pager) dom.stash.appendChild(pager);
      }
      if(!vaultAccess){
        const blocked=document.createElement('div');
        blocked.className='muted-box';
        blocked.textContent=vaultBlockedMessage;
        dom.stashActions.appendChild(blocked);
        return;
      }
      const upgradesHeading=document.createElement('div');
      upgradesHeading.className='command-title';
      upgradesHeading.textContent='Safehouse upgrades';
      dom.stashActions.appendChild(upgradesHeading);
      const upgradesHint=document.createElement('div');
      upgradesHint.className='small';
      upgradesHint.textContent='Invest scrap and credits to expand storage capacity.';
      dom.stashActions.appendChild(upgradesHint);
      const upgradeCost=getStashUpgradeCost();
      const upgradeCard=document.createElement('div');
      upgradeCard.className='op-card';
      const upgradeTitle=document.createElement('div');
      upgradeTitle.innerHTML='<b>Safehouse storage</b>';
      const upgradeMeta=document.createElement('div');
      upgradeMeta.className='op-meta';
      upgradeMeta.textContent=`Increase vault capacity by ${STASH_UPGRADE_STEP} slots.`;
      const upgradeCostLine=document.createElement('div');
      upgradeCostLine.className='op-meta';
      upgradeCostLine.textContent=`Cost: ${formatCost(upgradeCost)} · Current capacity ${state.stashLimit}.`;
      const upgradeActions=document.createElement('div');
      upgradeActions.className='op-actions';
      const upgradeBtn=document.createElement('button');
      upgradeBtn.textContent=`Upgrade storage (+${STASH_UPGRADE_STEP})`;
      upgradeBtn.onclick=upgradeStash;
      if(!vaultAccess){
        upgradeBtn.disabled=true;
        upgradeBtn.title=vaultBlockedMessage;
      }else if(!canAfford(upgradeCost)){
        upgradeBtn.disabled=true;
        upgradeBtn.title='Need more credits or scrap.';
      }
      upgradeActions.appendChild(upgradeBtn);
      upgradeCard.appendChild(upgradeTitle);
      upgradeCard.appendChild(upgradeMeta);
      upgradeCard.appendChild(upgradeCostLine);
      upgradeCard.appendChild(upgradeActions);
      dom.stashActions.appendChild(upgradeCard);
      const bulk=document.createElement('div');
      bulk.className='inventory inline-actions';
      const sellAll=document.createElement('button');
      sellAll.textContent='Sell all stash';
      sellAll.onclick=bulkSellStash;
      if(!vaultAccess){
        sellAll.disabled=true;
        sellAll.title=vaultBlockedMessage;
      }else if(!canAccessMarket()){
        sellAll.disabled=true;
        sellAll.title='Visit a shop to sell.';
      }
      const scrapAll=document.createElement('button');
      scrapAll.textContent='Break down all stash';
      scrapAll.onclick=bulkScrapStash;
      if(!vaultAccess){
        scrapAll.disabled=true;
        scrapAll.title=vaultBlockedMessage;
      }
      bulk.appendChild(sellAll);
      bulk.appendChild(scrapAll);
      dom.stashActions.appendChild(bulk);
      renderMarketStock();
    }

    /* ================= GAMEPLAY ================= */
    function computeFailChance(risk){
      const base=riskTable[risk] ?? 0.12;
      const gearMods=getGearMods();
      const radsPenalty=Math.min(0.08,state.rads*0.004);
      const hungerPenalty=state.hunger>70?0.05:0;
      const thirstPenalty=state.thirst>70?0.05:0;
      const fatiguePenalty=state.stamina<30?0.04:0;
      const energyPenalty=state.energy<25?0.06:0;
      const tempPenalty=state.bodyTemp<94?0.07:(state.bodyTemp>102?0.05:0);
      const total=base + hungerPenalty + thirstPenalty + fatiguePenalty + energyPenalty + radsPenalty + tempPenalty - (gearMods.riskMod||0);
      return clamp(total,0.05,0.75);
    }

    function tickTime(minutes){
      const total=state.timeMinutes+formatDisplayMinutes(minutes);
      if(total>=24*60){
        state.timeMinutes=total%(24*60);
        advanceDay();
      }else{
        state.timeMinutes=total;
      }
      updateRadShield();
    }

    function advanceDay(){
      state.day++;
      state.timeMinutes=6*60;
    }

    function rollComplication(source){
      const tension=computeFailChance(state.zone.risk) * 0.55;
      if(Math.random()>tension) return;
      const complications=[
        {desc:'A cold gust slips through your seals.',effects:'temp-2,stamina-2'},
        {desc:'An unseen stalker snatches some scrap.',effects:'scrap-2,temp-1'},
        {desc:'Hunger cramps slow you down.',effects:'stamina-6,hp-3'},
        {desc:'Static surge fries a component.',effects:'credits-6,temp-1'}
      ];
      if(state.rads>RAD_DANGER_THRESHOLD){
        complications.push({desc:'Radiation spike makes your skin crawl.',effects:'rads+1,hp-2'});
      }
      const hit=complications[Math.floor(Math.random()*complications.length)];
      applyEffects(hit.effects,'fail');
      logMsg(`Complication (${source}): ${hit.desc}`);
    }

    function applyEffects(effectStr,outcome,options={}){
      if(!effectStr) return;
      updateRadShield();
      const deferItemsTo=Array.isArray(options.deferItemsTo) ? options.deferItemsTo : null;
      effectStr.split(',').forEach(token=>{
        token=token.trim(); if(!token) return;
        if(token.startsWith('item:')){
          const item=token.slice(5).trim();
          if(deferItemsTo){
            deferItemsTo.push(item);
          }else{
            const routed=routeItemGain(item);
            if(routed==='lost'){
              logMsg(`${item} lost: no storage space available.`);
            }
          }
          return;
        }
        if(token.startsWith('flag:')){ state.flags.add(token.slice(5)); return; }
        if(token.startsWith('note:')){ setCodex(token.slice(5)); return; }
        if(token.startsWith('log:')){ logMsg(token.slice(4)); return; }
        const radPercentMatch=token.match(/^rads([+-]\d+)%$/i);
        if(radPercentMatch){
          const percent=Number(radPercentMatch[1]);
          const delta=Math.round(state.rads*(percent/100));
          state.rads=Math.max(0,state.rads+delta);
          return;
        }
        const radShieldMatch=token.match(/^radshield([+-]\d+)/i);
        if(radShieldMatch){
          const percent=Number(radShieldMatch[1]);
          state.radShield=clamp(percent/100,0,0.75);
          state.radShieldUntil=getTotalMinutes()+RAD_SHIELD_DURATION_MINUTES;
          return;
        }
        const match=token.match(/([a-zA-Z]+)([+-]\d+)/);
        if(match){
          const stat=match[1]; const delta=Number(match[2]);
          if(stat==='hp') state.hp=clamp(state.hp+delta,0,state.maxHp);
          else if(stat==='stamina') state.stamina=clamp(state.stamina+delta,0,state.maxStamina);
          else if(stat==='morale') state.morale=clamp(state.morale+delta,0,state.maxMorale);
          else if(stat==='hunger') state.hunger=clamp(state.hunger+delta,0,state.maxHunger);
          else if(stat==='thirst') state.thirst=clamp(state.thirst+delta,0,state.maxThirst);
          else if(stat==='rads'){
            const shield=delta>0 ? updateRadShield() : 0;
            const adjusted=delta>0 ? Math.max(0,Math.round(delta*(1-shield))) : delta;
            state.rads=Math.max(0,state.rads+adjusted);
          }
          else if(stat==='credits') state.credits=Math.max(0,state.credits+delta);
          else if(stat==='scrap') state.scrap=Math.max(0,state.scrap+delta);
          else if(stat==='energy') state.energy=clamp(state.energy+delta,0,state.maxEnergy);
          else if(stat==='keys') state.keys=Math.max(0,state.keys+delta);
          else if(stat==='temp') state.bodyTemp=clamp(state.bodyTemp+delta,BODY_TEMP_MIN,BODY_TEMP_MAX);
          else if(stat==='backpack') state.backpackLimit=Math.max(0,state.backpackLimit+delta);
        }
      });
      if(outcome==='fail' && state.hp<=0){
        logMsg('Emergency evac: you collapse and lose momentum.');
        state.hp=clamp(40,1,state.maxHp);
        state.morale=clamp(state.morale-12,0,state.maxMorale);
        state.energy=clamp(state.energy-20,0,state.maxEnergy);
      }
    }
    function runRaidInstant(raid,location,options={}){
      tickTime(raid.time);
      const gearMods=getGearMods();
      state.hunger=clamp(state.hunger+2,0,state.maxHunger);
      state.thirst=clamp(state.thirst+2,0,state.maxThirst);
      state.stamina=clamp(state.stamina-6+(gearMods.staminaBonus||0),0,state.maxStamina);
      const deferItemsTo=Array.isArray(options.deferItemsTo) ? options.deferItemsTo : null;
      const rewards=[];

      const locationRisk=location?.risk || state.zone.risk;
      const effectiveRisk=(riskRank[raid.risk] >= riskRank[locationRisk]) ? raid.risk : locationRisk;
      const failChance=computeFailChance(effectiveRisk);
      const roll=Math.random();
      const success=roll>failChance;
      state.bodyTemp=clamp(state.bodyTemp-1.1,BODY_TEMP_MIN,BODY_TEMP_MAX);
      if(success){
        const lootBonus=gearMods.lootBonus || 0;
        const pulls=Math.max(1,raid.loot+(Math.random()<0.35?1:0));
        for(let i=0;i<pulls;i++){
          const drop=rollLootDrop(effectiveRisk,lootBonus);
          addItemCopies(rewards,drop.id,drop.count);
        }
        if(deferItemsTo){
          deferItemsTo.push(...rewards);
        }else{
          rewards.forEach(item=>{
            const routed=routeItemGain(item);
            if(routed==='lost'){
              logMsg(`${item} lost: no storage space available.`);
            }
          });
        }
        logMsg(`✓ ${raid.label} succeeded. Rewards secured.`);
      }else{
        applyEffects('hp-6,morale-4,temp-2','fail');
        rollComplication('raid');
        logMsg(`✖ ${raid.label} failed. You limp back empty-handed.`);
      }
      return {success,rewards,effectiveRisk};
    }

    const getRiskIndex=(risk)=>riskRank[risk] || riskRank.low;
    const MIN_MISSION_SECONDS=4;
    const MAX_MISSION_SECONDS=30;
    const computeMissionDurationSeconds=({risk='low',time=8,loot=0}={})=>{
      const riskIdx=getRiskIndex(risk);
      const timeWeight=Math.max(1,time*0.45);
      const lootWeight=loot ? loot*1.4 : 0;
      const base=4+((riskIdx-1)*4)+timeWeight+lootWeight;
      return clamp(Math.round(base),MIN_MISSION_SECONDS,MAX_MISSION_SECONDS);
    };
    const computeMissionDurationMs=(params)=>computeMissionDurationSeconds(params)*1000;
    const computeMissionXp=(risk,time)=>{
      const riskIdx=getRiskIndex(risk);
      return Math.max(12,Math.round(18+(riskIdx*12)+(time*1.6)));
    };
    const computeCombatChance=(risk)=>{
      const riskIdx=getRiskIndex(risk);
      return clamp(0.12+(riskIdx*0.08),0.12,0.55);
    };
    function getCombatProfile(risk){
      const riskIdx=getRiskIndex(risk);
      return {
        id:`combat-${Date.now()}`,
        label:`Hostile contact (${risk})`,
        risk,
        time:Math.max(6,8+riskIdx*2),
        enemyName:['Scavenger pack','Rogue drone','Ambush crew','Rad-stalker'][riskIdx-1] || 'Hostiles',
        difficulty:1+(riskIdx*0.55)
      };
    }
    function shouldTriggerCombat(risk){
      const chance=computeCombatChance(risk);
      return Math.random()<chance;
    }
    function preparePendingResolution(pending,rewards){
      const pendingRewards=rewards || [];
      state.mission.pendingResolution={...pending,rewards:pendingRewards};
    }
    function launchCombatFromPending(pending){
      const combatProfile=getCombatProfile(pending.risk);
      const combatState=initCombatState(combatProfile);
      const now=Date.now();
      const estimatedMs=clamp(combatState.expectedRounds*COMBAT_ROUND_MS,MIN_MISSION_SECONDS*1000,MAX_MISSION_SECONDS*1000);
      state.mission={
        ...state.mission,
        type:'combat',
        raid:combatProfile,
        startedAt:now,
        endsAt:now+estimatedMs,
        completed:false,
        success:null,
        summary:`Combat engaged: ${combatProfile.enemyName}. ${describeCombatState(combatState)}`,
        rewards:[],
        statusMessage:`Combat engaged: ${combatProfile.enemyName}. ${describeCombatState(combatState)}`,
        fleeing:false,
        fleeEndsAt:null,
        xpReward:computeMissionXp(combatProfile.risk,combatProfile.time),
        rewardEffects:{success:'',fail:''},
        combat:combatState,
        sceneTarget:null
      };
      setCodex('Hostile contact! Hold out or flee.');
      logMsg(`Combat encounter triggered by ${pending.label}. ${describeCombatState(combatState)}`);
      setScreen('mission');
      normalizeMissionTiming(Date.now());
      renderAll();
    }
    function resolvePendingMission(outcomeOverride){
      const pending=state.mission.pendingResolution;
      if(!pending) return;
      const rewards=pending.rewards || [];
      const outcome=outcomeOverride || (pending.success ? 'success' : 'fail');
      const effects=outcome==='success' ? pending.successEffects : pending.failEffects;
      if(effects){
        if(outcome==='success') applyEffects(effects,outcome,{deferItemsTo:rewards});
        else applyEffects(effects,outcome);
      }
      if(outcome==='success' && pending.xpReward){
        awardXp(pending.xpReward,pending.label);
      }
      if(outcome==='success' && pending.flag && pending.once){
        state.flags.add(pending.flag);
      }
      state.mission.completed=true;
      state.mission.success=outcome==='success';
      state.mission.rewards=rewards;
      state.mission.summary=outcome==='success'
        ? 'Extraction secured. Review rewards before closing the mission.'
        : 'Extraction rough. Patch up before you re-deploy.';
      state.mission.statusMessage=outcome==='success'
        ? `Mission complete: ${pending.label}. Rewards ready.`
        : `Mission failed: ${pending.label}.`;
      state.mission.pendingResolution=null;
      setCodex(outcome==='success' ? 'Mission complete. Rewards ready to review.' : 'Mission failed. Recover and try again.');
      setActiveTab('hub');
      state.screen='mission';
      state.selected={source:null,item:null};
      renderAll();
    }
    const COMBAT_ROUND_MS=1200;
    const COMBAT_CONSUME_MS=3000;
    const combatVariance=(base,spread)=>Math.max(1,Math.round(base*(1-spread)+(Math.random()*base*spread*2)));
    const describeCombatState=(combat)=>`Enemy HP ${Math.max(0,Math.round(combat.enemyHp))}/${Math.round(combat.enemyMaxHp)} · Enemies left ${combat.enemiesRemaining}/${combat.totalEnemies}`;
    function initCombatState(profile){
      const gearMods=getGearMods();
      const riskIdx=getRiskIndex(profile.risk);
      const totalEnemies=Math.max(1,1+Math.max(0,riskIdx-1));
      const playerDamage=Math.max(6,Math.round(8+(state.level*1.8)+((gearMods.combatBonus||0)*1.4)+((gearMods.staminaBonus||0)*0.6)));
      const enemyDamage=Math.max(2,Math.round((3+(riskIdx*2.6))-(playerDamage*0.12)-((gearMods.riskMod||0)*18)));
      const enemyMaxHp=Math.max(28,Math.round(26+(riskIdx*12)+(profile.difficulty*8)));
      const totalEnemyHp=enemyMaxHp*totalEnemies;
      const expectedRounds=Math.max(4,Math.ceil(totalEnemyHp/Math.max(8,playerDamage*0.9)));
      return {
        riskIdx,
        enemyMaxHp,
        enemyHp:enemyMaxHp,
        totalEnemies,
        enemiesRemaining:totalEnemies,
        playerDamage,
        enemyDamage,
        round:0,
        totalDamageTaken:0,
        totalDamageDealt:0,
        nextTickAt:Date.now()+COMBAT_ROUND_MS,
        consumable:null,
        expectedRounds
      };
    }
    function runCombatEncounter(profile,{success,fleeing=false}={}){
      const gearMods=getGearMods();
      const combat=state.mission.combat || initCombatState(profile);
      const rewards=[];
      const lootPulls=success ? 2+Math.floor(profile.difficulty) : 1;
      for(let i=0;i<lootPulls;i++){
        const drop=rollLootDrop(profile.risk,gearMods.lootBonus||0);
        addItemCopies(rewards,drop.id,drop.count);
      }
      const creditReward=Math.max(6,Math.round((profile.difficulty*12)+(Math.random()*10)));
      const credited=success ? creditReward : Math.round(creditReward*(fleeing?0.6:0.5));
      state.credits+=credited;
      const xpBase=computeMissionXp(profile.risk,profile.time);
      const xpReward=success ? xpBase : Math.round(xpBase*(fleeing?0.7:0.6));
      awardXp(xpReward,profile.enemyName);
      const summary=success
        ? `Hostiles down. You dealt ${Math.round(combat.totalDamageDealt)} and took ${Math.round(combat.totalDamageTaken)} damage. ${credited} credits recovered.`
        : fleeing
          ? `You flee under fire after taking ${Math.round(combat.totalDamageTaken)} damage. Partial rewards recovered.`
          : `You are overrun after taking ${Math.round(combat.totalDamageTaken)} damage and pull back to survive.`;
      return {success,rewards,summary};
    }
    function applyCombatConsumable(item){
      if(!state.mission.active || state.mission.type!=='combat' || state.mission.completed) return;
      const combat=state.mission.combat;
      if(!combat) return;
      if(combat.consumable){
        setCodex(`Already applying ${combat.consumable.item}.`);
        return;
      }
      if(!state.inventory.includes(item)){
        setCodex('Consumable not found in backpack.');
        return;
      }
      const data=getItem(item);
      if(data.type!=='consumable'){
        setCodex('Only consumables can be used mid-combat.');
        return;
      }
      combat.consumable={item,readyAt:Date.now()+COMBAT_CONSUME_MS};
      state.mission.statusMessage=`Applying ${item}… 3s channel.`;
      renderMissionStatus();
    }
    function resolveCombatRound(){
      const combat=state.mission.combat;
      if(!combat) return;
      combat.round+=1;
      let roundLog='';
      if(!state.mission.fleeing){
        const dealt=combatVariance(combat.playerDamage,0.22);
        combat.enemyHp-=dealt;
        combat.totalDamageDealt+=dealt;
        roundLog=`You hit for ${dealt}.`;
        if(combat.enemyHp<=0){
          combat.enemiesRemaining-=1;
          roundLog+=` Target down.`;
          if(combat.enemiesRemaining>0){
            const nextHp=Math.round(combat.enemyMaxHp*(1+combat.riskIdx*0.04));
            combat.enemyMaxHp=nextHp;
            combat.enemyHp=nextHp;
            roundLog+=` ${combat.enemiesRemaining} hostiles remain.`;
          }
        }
      }else{
        roundLog='You focus on disengaging.';
      }
      const incoming=combatVariance(combat.enemyDamage,0.18);
      combat.totalDamageTaken+=incoming;
      state.hp=clamp(state.hp-incoming,0,state.maxHp);
      const staminaHit=Math.max(2,Math.round(incoming*0.6));
      state.stamina=clamp(state.stamina-staminaHit,0,state.maxStamina);
      roundLog+=` Incoming fire deals ${incoming}.`;
      const moraleHit=Math.max(1,Math.round(incoming*0.18));
      state.morale=clamp(state.morale-moraleHit,0,state.maxMorale);
      state.mission.statusMessage=`${roundLog} ${describeCombatState(combat)}`;
      logMsg(state.mission.statusMessage);
    }
    function combatTick(now){
      if(!state.mission.active || state.mission.type!=='combat' || state.mission.completed) return;
      const combat=state.mission.combat;
      if(!combat) return;
      if(combat.consumable && now>=combat.consumable.readyAt){
        const {item}=combat.consumable;
        const data=getItem(item);
        if(data.effect) applyEffects(data.effect,'success');
        removeItem(state.inventory,item);
        combat.consumable=null;
        state.selected={source:null,item:null};
        state.mission.statusMessage=`${item} applied. ${describeCombatState(combat)}`;
        logMsg(state.mission.statusMessage);
      }
      if(now<combat.nextTickAt) return;
      combat.nextTickAt=now+COMBAT_ROUND_MS;
      resolveCombatRound();
      if(combat.enemiesRemaining<=0){
        state.mission.endsAt=now;
        completeMission({combatResolved:true});
      }else if(state.hp<=0){
        state.mission.endsAt=now;
        completeMission({combatResolved:true,forcedFail:true});
      }
    }

    function attemptFlee(){
      if(!state.mission.active || state.mission.type!=='combat' || state.mission.completed) return;
      if(state.mission.fleeing) return;
      state.mission.fleeing=true;
      state.mission.fleeEndsAt=Date.now()+5000;
      state.mission.endsAt=state.mission.fleeEndsAt;
      state.mission.statusMessage=`Attempting to flee… hold for 5 seconds. ${describeCombatState(state.mission.combat)}`;
      logMsg('Escape attempt initiated. Incoming fire continues during the retreat.');
      renderMissionStatus();
    }
    function startCombatMission(){
      if(state.mission.active){
        setCodex('Mission already underway.');
        return;
      }
      if(state.travel.active){
        setCodex('Finish travel before engaging hostiles.');
        return;
      }
      if(isHubZone(state.zone)){
        setCodex('Hub zones are secure. Travel to a field site to engage hostiles.');
        return;
      }
      startLoops();
      const profile=getCombatProfile(state.zone.risk);
      const cost={energy:10};
      if(!canAfford(cost)){
        setCodex('Not enough energy to pick a fight.');
        return;
      }
      applyCost(cost);
      const combatState=initCombatState(profile);
      const now=Date.now();
      const estimatedMs=clamp(combatState.expectedRounds*COMBAT_ROUND_MS,MIN_MISSION_SECONDS*1000,MAX_MISSION_SECONDS*1000);
      state.mission={
        active:true,
        type:'combat',
        raid:profile,
        startedAt:now,
        endsAt:now+estimatedMs,
        completed:false,
        success:null,
        summary:`Combat engaged: ${profile.enemyName}. ${describeCombatState(combatState)}`,
        rewards:[],
        statusMessage:`Combat engaged: ${profile.enemyName}. ${describeCombatState(combatState)}`,
        location:{...state.zone},
        fleeing:false,
        fleeEndsAt:null,
        pendingResolution:null,
        xpReward:computeMissionXp(profile.risk,profile.time),
        rewardEffects:{success:'',fail:''},
        questMeta:null,
        combat:combatState,
        sceneTarget:null
      };
      setCodex('You move to engage hostile contacts.');
      logMsg(`Combat sortie launched against ${profile.enemyName}. ${describeCombatState(combatState)}`);
      setActiveTab('hub');
      setScreen('mission');
      normalizeMissionTiming(Date.now());
      renderAll();
    }
    function runQuest(quest){
      if(state.mission.active || state.travel.active){
        setCodex('Finish current operations before starting a contract.');
        return;
      }
      const questFlag=quest.flag || quest.id;
      if(quest.once && questFlag && state.flags.has(questFlag)){
        setCodex('That contract has already been completed.');
        return;
      }
      const energyCost=quest.energy ?? 12;
      const raidLike={
        id:quest.id,
        label:quest.title || 'Special contract',
        desc:quest.desc,
        time:quest.time || 10,
        energy:energyCost,
        loot:Math.max(2,Math.round((quest.time||10)/5)),
        risk:quest.risk || state.zone.risk,
        key:quest.key||0
      };
      const cost={energy:raidLike.energy,keys:raidLike.key||0};
      if(!canAfford(cost)){
        setCodex('Not enough resources for that contract.');
        return;
      }
      startLoops();
      applyCost(cost);
      const now=Date.now();
      const durationMs=computeMissionDurationMs({risk:raidLike.risk,time:raidLike.time,loot:raidLike.loot});
      state.mission={
        active:true,
        type:'contract',
        raid:raidLike,
        startedAt:now,
        endsAt:now+durationMs,
        completed:false,
        success:null,
        summary:'',
        rewards:[],
        statusMessage:`Contract launched: ${raidLike.label}.`,
        location:{...state.zone},
        fleeing:false,
        fleeEndsAt:null,
        pendingResolution:null,
        xpReward:computeMissionXp(raidLike.risk,raidLike.time),
        rewardEffects:{success:quest.success||'',fail:quest.fail||''},
        questMeta:{flag:questFlag,once:quest.once},
        combat:null,
        sceneTarget:null
      };
      setCodex(`Contract launched: ${raidLike.label}.`);
      logMsg(`Contract deployed: ${raidLike.label} (${formatDisplayMinutes(raidLike.time)} min op).`);
      setActiveTab('hub');
      setScreen('mission');
      normalizeMissionTiming(Date.now());
      renderAll();
    }

    function resetMissionState(){
      state.mission={active:false,type:null,raid:null,startedAt:null,endsAt:null,completed:false,success:null,summary:'',rewards:[],statusMessage:'',location:null,fleeing:false,fleeEndsAt:null,pendingResolution:null,xpReward:0,rewardEffects:{success:'',fail:''},questMeta:null,combat:null,sceneTarget:null};
    }
    function closeMission({auto=false}={}){
      const lastLocation=state.mission.location ? {...state.mission.location} : null;
      const shouldRestoreLocation=lastLocation && lastLocation.id !== state.zone.id;
      resetMissionState();
      state.selected={source:null,item:null};
      if(shouldRestoreLocation){
        state.zone=lastLocation;
        clearMarketAccess();
      }
      setCodex(auto ? 'All rewards routed. Returning to the locations hub.' : 'Mission closed. Returning to the locations hub.');
      setActiveTab('hub');
      if(lastLocation){
        setScreen('locations');
      }else{
        setScreen('main');
      }
    }

    function startMission(raid){
      const cost={energy:raid.energy,keys:raid.key||0};
      if(state.mission.active){
        setCodex('Mission already underway.');
        return;
      }
      if(state.travel.active){
        setCodex('Finish travel before launching a mission.');
        return;
      }
      if(isHubZone(state.zone)){
        setCodex('Cannot launch raids from a hub zone. Travel to a field site.');
        return;
      }
      if(!canAfford(cost)){
        setCodex('Not enough resources for that raid.');
        return;
      }
      startLoops();
      applyCost(cost);
      const now=Date.now();
      const durationMs=computeMissionDurationMs({risk:raid.risk,time:raid.time,loot:raid.loot});
      state.mission={
        active:true,
        type:'raid',
        raid,
        startedAt:now,
        endsAt:now+durationMs,
        completed:false,
        success:null,
        summary:'',
        rewards:[],
        statusMessage:`Mission launched: ${raid.label}.`,
        location:{...state.zone},
        fleeing:false,
        fleeEndsAt:null,
        pendingResolution:null,
        xpReward:computeMissionXp(raid.risk,raid.time),
        rewardEffects:{success:'',fail:''},
        questMeta:null,
        combat:null,
        sceneTarget:null
      };
      setCodex(`Mission launched: ${raid.label}.`);
      logMsg(`Mission launched: ${raid.label} (${formatDisplayMinutes(raid.time)} min op).`);
      setActiveTab('hub');
      setScreen('mission');
      normalizeMissionTiming(Date.now());
      renderAll();
    }

    function completeMission({combatResolved=false,forcedFail=false}={}){
      if(!state.mission.active || state.mission.completed) return;
      const missionType=state.mission.type;
      const raid=state.mission.raid;
      if(missionType==='combat'){
        const combat=state.mission.combat;
        if(combat && !combatResolved && !state.mission.fleeing && state.hp>0 && combat.enemiesRemaining>0){
          combat.nextTickAt=Date.now();
          combatTick(Date.now());
          if(!state.mission.completed) return;
        }
        const defeated=!state.mission.fleeing && state.hp>0 && (combat?.enemiesRemaining||0)<=0;
        const success=forcedFail && !defeated ? false : defeated;
        const result=runCombatEncounter(raid,{success,fleeing:state.mission.fleeing});
        state.mission.completed=true;
        state.mission.success=result.success;
        state.mission.rewards=result.rewards;
        state.mission.summary=result.summary;
        state.mission.statusMessage=result.summary;
        if(state.hp<=0){
          applyEffects('hp+35,morale-12,energy-18','fail');
          state.mission.success=false;
          state.mission.summary='You collapse during the fight and are dragged to safety. Rewards are lost.';
          state.mission.statusMessage=state.mission.summary;
          state.mission.rewards=[];
        }
        if(state.mission.pendingResolution){
          const pendingRewards=state.mission.pendingResolution.rewards || [];
          pendingRewards.push(...result.rewards);
          state.mission.pendingResolution.rewards=pendingRewards;
          resolvePendingMission(result.success ? 'success' : 'fail');
          return;
        }
        setCodex(result.success ? 'Combat resolved. Rewards ready to review.' : 'Combat resolved. Regroup before redeploying.');
        setActiveTab('hub');
        state.screen='mission';
        renderAll();
        return;
      }

      if(missionType==='scene'){
        const rewards=[];
        const effectiveRisk=raid.risk || state.zone.risk;
        const failChance=computeFailChance(effectiveRisk);
        const success=Math.random()>failChance;
        const pending={
          label:raid.label,
          success,
          risk:effectiveRisk,
          xpReward:state.mission.xpReward,
          successEffects:state.mission.rewardEffects.success,
          failEffects:state.mission.rewardEffects.fail,
          flag:null,
          once:false
        };
        preparePendingResolution(pending,rewards);
        if(state.mission.sceneTarget){
          state.zone.sceneId=state.mission.sceneTarget;
        }
        resolvePendingMission(success ? 'success' : 'fail');
        return;
      }

      const rewards=[];
      const raidResult=runRaidInstant(raid,state.mission.location,{deferItemsTo:rewards});
      const success=raidResult.success;
      const effectiveRisk=raidResult.effectiveRisk || raid.risk;
      const pending={
        label:raid.label,
        success,
        risk:effectiveRisk,
        xpReward:state.mission.xpReward,
        successEffects:missionType==='contract' ? state.mission.rewardEffects.success : '',
        failEffects:missionType==='contract' ? state.mission.rewardEffects.fail : '',
        flag:missionType==='contract' ? state.mission.questMeta?.flag : null,
        once:missionType==='contract' ? state.mission.questMeta?.once : false
      };
      preparePendingResolution(pending,rewards);
      if(shouldTriggerCombat(effectiveRisk)){
        launchCombatFromPending(pending);
        return;
      }
      resolvePendingMission(success ? 'success' : 'fail');
    }

    function sellStashItem(item){
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      if(!canAccessMarket()){
        setCodex('Visit a shop to sell items.');
        return;
      }
      const data=getItem(item);
      removeItem(state.stash.items,item);
      state.credits+=data.value || 1;
      state.selected={source:null,item:null};
      renderAll();
    }
    function sellStashItemStack(item,count){
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      if(!canAccessMarket()){
        setCodex('Visit a shop to sell items.');
        return;
      }
      const available=getItemCount(state.stash.items,item);
      const sellCount=Math.min(count,available);
      if(sellCount<=0) return;
      const data=getItem(item);
      removeItems(state.stash.items,item,sellCount);
      state.credits+=(data.value || 1) * sellCount;
      state.selected={source:null,item:null};
      renderAll();
    }

    function scrapStashItem(item){
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      removeItem(state.stash.items,item);
      const breakdown=getBreakdownOutputs(item);
      applyBreakdownOutputs(breakdown,{preferred:'stash'});
      state.selected={source:null,item:null};
      renderAll();
    }

    function bulkSellStash(){
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      if(!canAccessMarket()){
        setCodex('Visit a shop to sell items.');
        return;
      }
      state.stash.items.forEach(item=>{
        const data=getItem(item);
        state.credits+=data.value || 1;
      });
      state.stash.items=[];
      state.selected={source:null,item:null};
      renderAll();
    }

    function bulkScrapStash(){
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      const itemsToScrap=[...state.stash.items];
      state.stash.items=[];
      itemsToScrap.forEach(item=>{
        const breakdown=getBreakdownOutputs(item);
        applyBreakdownOutputs(breakdown,{preferred:'stash'});
      });
      state.selected={source:null,item:null};
      renderAll();
    }

    function runCamp(){
      tickTime(ACTION_TIMES.camp);
      const gearMods=getGearMods();
      state.stamina=clamp(state.stamina+14,0,state.maxStamina);
      state.hp=clamp(state.hp+4,0,state.maxHp);
      state.morale=clamp(state.morale+4+(gearMods.moraleBonus||0),0,state.maxMorale);
      state.energy=clamp(state.energy+18+(gearMods.energyRegen||0),0,state.maxEnergy);
      state.hunger=clamp(state.hunger+3,0,state.maxHunger);
      state.thirst=clamp(state.thirst+3,0,state.maxThirst);
      state.bodyTemp=moveToward(state.bodyTemp,NORMAL_BODY_TEMP,4);
      logMsg('You bunker down, warm up, and recover energy.');
      rollComplication('camp');
      renderAll();
    }

    /* ================= EXPANSION LOADING ================= */
    function ensureExpansionsLoaded(){
      const needsReload=expansionsAttempted===0 || (expansionsLoaded===0 && expansionsAttempted>=expansionsExpected);
      if(dom.doors.children.length>0 && !needsReload) return;
      dom.doors.innerHTML='';
      loadGames();
    }

    async function loadGames(){
      let manifest=EXPANSION_MANIFEST;
      try{
        const res=await fetch('games.json',{cache:'no-store'});
        if(res.ok){
          const data=await res.json();
          if(Array.isArray(data.expansions) && data.expansions.length){
            manifest=data.expansions;
          }
        }
      }catch(err){
        console.warn('games.json unavailable, falling back to embedded manifest.',err);
      }
      expansionsExpected=manifest.length;
      expansionsLoaded=0;
      expansionsAttempted=0;
      dom.doors.innerHTML='';
      dom.doorsHint.textContent=manifest.length ? 'Loading expansions…' : 'No expansions configured.';
      manifest.forEach(meta=>loadExpansion(meta));
    }

    async function loadExpansion(meta){
      const embedded=EMBEDDED_EXPANSIONS[meta.id];
      try{
        const res=await fetch(meta.file,{cache:'no-store'});
        if(!res.ok){
          throw new Error(`Expansion fetch failed: ${meta.file}`);
        }
        const raw=await res.text();
        const expansion=parseExpansion(raw);
        expansion.meta.id=meta.id || expansion.meta.id;
        expansion.meta.name=meta.name || expansion.meta.name || meta.id;
        expansions[expansion.meta.id]=expansion;
        addDoor(expansion);
        expansionsLoaded+=1;
        dom.doorsHint.textContent='';
        logMsg(`Door bolted on: ${expansion.meta.name}`);
      }catch(err){
        if(embedded){
          const expansion=parseExpansion(embedded);
          expansion.meta.id=meta.id || expansion.meta.id;
          expansion.meta.name=meta.name || expansion.meta.name || meta.id;
          expansions[expansion.meta.id]=expansion;
          addDoor(expansion);
          expansionsLoaded+=1;
          dom.doorsHint.textContent='';
          logMsg(`Door bolted on: ${expansion.meta.name}`);
        }else{
          logMsg(`Failed to load ${meta.id}`);
          console.error(err);
        }
      }finally{
        expansionsAttempted+=1;
        if(expansionsLoaded===0 && expansionsAttempted>=expansionsExpected){
          dom.doorsHint.textContent='Unable to load expansions.';
        }
      }
    }

    function addDoor(exp){
      const btn=document.createElement('button');
      const minLevel=Number(exp.meta?.minLevel || exp.meta?.minlevel || 0);
      const unlockCost=Number(exp.meta?.unlockCost || exp.meta?.unlockcost || 0);
      const unlockFlag=`unlock-${exp.meta.id}`;
      let isUnlocked=!unlockCost || state.flags.has(unlockFlag);
      const getHintText=()=>((!isUnlocked && unlockCost)
        ? `Unlock ${unlockCost} credits`
        : (minLevel && state.level<minLevel)
          ? `Requires level ${minLevel}`
          : (exp.door?.hint||'Unknown contact'));
      const setDoorLabel=()=>{
        btn.innerHTML=`<span>${exp.door?.label||exp.meta.name}</span><span class="small">${getHintText()}</span>`;
      };
      setDoorLabel();
      btn.onclick=()=>{
        if(isMissionBlockingTravel()){
          setCodex('Mission in progress. Cannot change locations.');
          return;
        }
        if(isRewardBlockingTravel()){
          setCodex('Resolve mission rewards before changing locations.');
          return;
        }
        if(state.travel.active){
          setCodex('Already rerouting. Stand by.');
          return;
        }
        if(minLevel && state.level<minLevel){
          setCodex(`Access denied. Reach level ${minLevel} to enter ${exp.meta.name}.`);
          return;
        }
        if(unlockCost && !isUnlocked){
          if(state.credits<unlockCost){
            setCodex(`Need ${unlockCost} credits to unlock ${exp.meta.name}.`);
            return;
          }
          state.credits-=unlockCost;
          state.flags.add(unlockFlag);
          isUnlocked=true;
          setDoorLabel();
          logMsg(`${exp.meta.name} unlocked for ${unlockCost} credits.`);
          setCodex(`${exp.meta.name} unlocked. Transit cleared.`);
        }
        const targetScene=exp.door?.target || Object.keys(exp.scenes || {})[0] || null;
        const target={
          id:exp.meta.id,
          name:exp.meta.name,
          risk:exp.door?.risk || 'low',
          desc:exp.door?.desc || exp.door?.hint || 'Salvage zone marked by strange chatter.',
          sceneId:targetScene
        };
        state.travel={
          active:true,
          endsAt:Date.now(),
          target
        };
        if(exp.door?.note) setCodex(exp.door.note);
        renderAll();
      };
      if(minLevel && state.level<minLevel){
        btn.disabled=true;
        btn.title=`Requires level ${minLevel}`;
      }
      dom.doors.appendChild(btn);
    }

    function parseOption(str){
      // Format: Label => target | risk:low | time:10 | success:hp+5,credits+10 | fail:hp-5 | rad:1 | temp:1
      const segments=str.split('|').map(s=>s.trim()).filter(Boolean);
      const [labelPart,...rest]=segments;
      const [label,target]=labelPart.split('=>').map(s=>s&&s.trim());
      const opt={label:label||'Action',target:target||null,risk:'low',time:8,success:'',fail:'',rad:0,temp:0,loot:0,lootType:'',reward:'',once:false,flag:''};
      rest.forEach(seg=>{
        const [k,vRaw]=seg.split(':');
        const v=vRaw?.trim();
        if(!k) return;
        const key=k.trim().toLowerCase();
        if(key==='risk') opt.risk=v;
        else if(key==='time') opt.time=Number(v||8);
        else if(key==='success') opt.success=v;
        else if(key==='fail') opt.fail=v;
        else if(key==='rad') opt.rad=Number(v||0);
        else if(key==='temp') opt.temp=Number(v||0);
        else if(key==='loot') opt.loot=Number(v||0);
        else if(key==='loottype') opt.lootType=v;
        else if(key==='reward') opt.reward=v;
        else if(key==='once') opt.once=v !== 'false';
        else if(key==='flag') opt.flag=v;
      });
      return opt;
    }

    function parseExpansion(raw){
      const exp={meta:{},door:{},scenes:{},quests:[],missions:[]};
      let scope='meta';
      let currentScene=null;
      let currentQuest=null;
      let currentMission=null;
      raw.split(/\r?\n/).forEach(line=>{
        line=line.trim();
        if(!line || line.startsWith('#')) return;
        if(line.startsWith('@expansion')){scope='meta';currentScene=null;currentQuest=null;currentMission=null;return;}
        if(line.startsWith('@door')){scope='door';currentScene=null;currentQuest=null;currentMission=null;return;}
        if(line.startsWith('@scene')){
          scope='scene';
          currentQuest=null;
          currentMission=null;
          const id=line.split(/\s+/)[1] || `scene-${Object.keys(exp.scenes).length+1}`;
          currentScene={id,title:'',desc:'',tags:'',options:[]};
          exp.scenes[id]=currentScene;return;
        }
        if(line.startsWith('@mission')){
          scope='mission';
          currentScene=null;
          currentQuest=null;
          currentMission={
            id:`mission-${exp.missions.length+1}`,
            label:'Field operation',
            desc:'',
            risk:'medium',
            time:10,
            energy:12,
            loot:2,
            key:0,
            lootType:'',
            reward:''
          };
          exp.missions.push(currentMission);
          return;
        }
        if(line.startsWith('@quest')){
          scope='quest';
          currentScene=null;
          currentMission=null;
          currentQuest={
            id:`quest-${exp.quests.length+1}`,
            title:'Special contract',
            desc:'',
            risk:'medium',
            time:10,
            success:'',
            fail:'',
            once:true,
            flag:''
          };
          exp.quests.push(currentQuest);
          return;
        }
        const [key,...rest]=line.split(':');
        const value=rest.join(':').trim();
        if(scope==='meta') exp.meta[key]=value;
        else if(scope==='door') exp.door[key]=value;
        else if(scope==='scene' && currentScene){
          if(key==='option') currentScene.options.push(parseOption(value));
          else if(key==='desc') currentScene.desc += (currentScene.desc?' ':'') + value;
          else currentScene[key]=value;
        }else if(scope==='quest' && currentQuest){
          if(key==='desc') currentQuest.desc += (currentQuest.desc?' ':'') + value;
          else if(key==='time') currentQuest.time=Number(value || 10);
          else if(key==='once') currentQuest.once=value !== 'false';
          else currentQuest[key]=value;
        }else if(scope==='mission' && currentMission){
          if(key==='desc') currentMission.desc += (currentMission.desc?' ':'') + value;
          else if(['time','energy','loot','key'].includes(key)) currentMission[key]=Number(value || 0);
          else currentMission[key]=value;
        }
      });
      return exp;
    }

    function renderAll(){
      renderBars();
      renderInventory();
      renderCrafting();
      renderExcursionStatus();
      renderHubAccess();
      renderTravelStatus();
      renderMissionStatus();
      renderIdleOps();
      renderZone();
      renderRaidActions();
      renderStash();
      renderItemDetails();
      setInventoryScreen(state.inventoryScreen);
      setStashScreen(state.stashScreen);
      renderScreens();
      syncTabs();
      queueSave();
    }

    function hideIntroModal(){
      if(!dom.introModal) return;
      dom.introModal.classList.add('hidden');
    }

    function showIntroModal({returning=false}={}){
      if(!dom.introModal || !dom.introActions || !dom.introMessage || !dom.introTitle) return;
      dom.introActions.innerHTML='';
      if(returning){
        dom.introTitle.textContent='Welcome back, runner';
        dom.introMessage.textContent='Your autosave is ready. Continue from your last loop or start fresh.';
        const continueBtn=document.createElement('button');
        continueBtn.textContent='Continue autosave';
        continueBtn.onclick=()=>{
          const latestState=loadSavedState();
          if(latestState) state=latestState;
          allowAutosave=true;
          hideIntroModal();
          renderAll();
          queueSave({force:true});
        };
        const restartBtn=document.createElement('button');
        restartBtn.textContent='Start fresh';
        restartBtn.classList.add('danger');
        restartBtn.onclick=()=>{
          localStorage.removeItem(SAVE_KEY);
          state=createDefaultState();
          allowAutosave=true;
          renderAll();
          queueSave({force:true});
          hideIntroModal();
        };
        dom.introActions.appendChild(continueBtn);
        dom.introActions.appendChild(restartBtn);
      }else{
        dom.introTitle.textContent='Fight, loot, survive.';
        dom.introMessage.textContent='Start a fresh loop or purge storage to reset everything.';
        const startBtn=document.createElement('button');
        startBtn.textContent='Start fresh';
        startBtn.onclick=()=>{
          allowAutosave=true;
          queueSave({force:true});
          hideIntroModal();
        };
        const resetBtn=document.createElement('button');
        resetBtn.textContent='Clear saves';
        resetBtn.classList.add('danger');
        resetBtn.onclick=()=>{
          localStorage.removeItem(SAVE_KEY);
          state=createDefaultState();
          allowAutosave=true;
          renderAll();
          queueSave({force:true});
          hideIntroModal();
        };
        dom.introActions.appendChild(startBtn);
        dom.introActions.appendChild(resetBtn);
      }
      dom.introModal.classList.remove('hidden');
    }

    /* ================= INIT ================= */
    let loopsStarted=false;
    function startLoops(){
      if(loopsStarted) return;
      loopsStarted=true;
      setInterval(ambientTick,6500);
      setInterval(updateTimers,250);
      setInterval(saveGame,60000);
      window.addEventListener('beforeunload',saveGame);
    }

    function initGame(){
      renderAll();
      loadGames();
      showIntroModal({returning:Boolean(savedState)});
      startLoops();
    }

    if(document.readyState==='loading'){
      document.addEventListener('DOMContentLoaded',initGame);
    }else{
      initGame();
    }

    function normalizeMissionTiming(now){
      if(!state.mission.active || state.mission.completed) return;
      const startedAt=Number.isFinite(state.mission.startedAt) ? state.mission.startedAt : now;
      const fallbackDuration=computeMissionDurationMs({
        risk:state.mission.raid?.risk,
        time:state.mission.raid?.time,
        loot:state.mission.raid?.loot
      });
      const durationMs=Number.isFinite(fallbackDuration) ? fallbackDuration : (MIN_MISSION_SECONDS*1000);
      if(!Number.isFinite(state.mission.endsAt) || state.mission.endsAt<=startedAt){
        state.mission.startedAt=startedAt;
        state.mission.endsAt=startedAt+durationMs;
      }
      const maxDuration=MAX_MISSION_SECONDS*1000*MISSION_OVERRUN_MULTIPLIER;
      if(now-startedAt>maxDuration){
        state.mission.endsAt=now;
      }
    }

    function normalizeIdleTiming(now){
      if(!state.idleOps.active) return;
      const startedAt=Number.isFinite(state.idleOps.startedAt) ? state.idleOps.startedAt : null;
      if(!Number.isFinite(startedAt)){
        state.idleOps.startedAt=now;
      }
      const durationMs=Number(state.idleOps.durationMs);
      if(!Number.isFinite(durationMs) || durationMs<=0){
        const op=idleOperations.find(entry=>entry.id===state.idleOps.id);
        if(op){
          const duration=getIdleDurationMinutes(op,getGearMods());
          state.idleOps.durationMs=duration*60000;
        }
      }
    }

    function updateTimers(){
      if(resolveTravelIfComplete()){
        renderAll();
      }
      if(state.mission.active && !state.mission.completed){
        const now=Date.now();
        normalizeMissionTiming(now);
        if(state.mission.type==='combat'){
          combatTick(now);
          if(state.mission.fleeing && now>=state.mission.endsAt){
            completeMission({combatResolved:true});
          }else if(!state.mission.completed && !state.mission.fleeing && now>=state.mission.endsAt){
            completeMission({combatResolved:true,forcedFail:true});
          }
        }else if(now>=state.mission.endsAt){
          completeMission();
        }
      }
      if(state.mission.active && !state.mission.completed){
        renderMissionStatus();
      }
      if(state.travel.active){
        renderTravelStatus();
      }
      if(state.idleOps.active){
        const now=Date.now();
        normalizeIdleTiming(now);
        const elapsed=now-(state.idleOps.startedAt || now);
        if(elapsed>=state.idleOps.durationMs){
          completeIdleOp();
          return;
        }
        renderIdleOps();
      }
    }

    function ambientTick(){
      tickTime(4);
      if(state.idleOps.active){
        const elapsed=Date.now()-state.idleOps.startedAt;
        if(elapsed>=state.idleOps.durationMs){
          completeIdleOp();
          return;
        }
      }
      const gearMods=getGearMods();
      state.energy=clamp(state.energy+4+(gearMods.energyRegen||0),0,state.maxEnergy);
      state.hunger=clamp(state.hunger+1,0,state.maxHunger);
      state.thirst=clamp(state.thirst+1,0,state.maxThirst);
      const inHub=state.screen==='main' || state.screen==='locations';
      if(inHub){
        state.bodyTemp=moveToward(state.bodyTemp,NORMAL_BODY_TEMP,1.6);
      }else{
        const insulation=gearMods.insulation || 0;
        const loss=Math.max(0.4,1.3-insulation);
        state.bodyTemp=clamp(state.bodyTemp-loss,BODY_TEMP_MIN,BODY_TEMP_MAX);
      }
      if(state.hunger>=90){
        applyEffects('hp-3,morale-2','fail');
        logMsg('Starvation gnaws at you while you hesitate.');
      }
      if(state.thirst>=90){
        applyEffects('hp-4,stamina-5','fail');
        logMsg('Dehydration blurs your vision.');
      }
      if(state.bodyTemp<=92){
        applyEffects('hp-2,stamina-3','fail');
        if(state.timeMinutes%60===0){
          logMsg('Cold seeps into your limbs. Find shelter or warm up soon.');
        }
      }
      if(state.bodyTemp>=103){
        applyEffects('hp-2,morale-2','fail');
        if(state.timeMinutes%60===0){
          logMsg('Heat haze clouds your focus. Cool down before it worsens.');
        }
      }
      rollComplication('idle time');
      renderAll();
    }

  </script>
</body>
</html>
