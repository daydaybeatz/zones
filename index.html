<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Zones - fight, loot, survive.</title>
  <style>
    :root{
      color-scheme: dark;
      --bg:#0c0c0f;
      --panel:#121219;
      --panel-2:#191925;
      --accent:#5bd1ff;
      --accent-2:#8fffa3;
      --danger:#ff6b6b;
      --muted:#a7b0c0;
      --border:#202232;
      --shadow:0 10px 40px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box;}
    body{
      margin:0;min-height:100vh;background:radial-gradient(circle at 20% 20%, rgba(70,120,255,.08), transparent 35%),
      radial-gradient(circle at 80% 0%, rgba(80,255,200,.06), transparent 30%),
      var(--bg);
      color:#e8edf7;font-family:"Inter",system-ui,-apple-system,sans-serif;
      line-height:1.45;
      padding:12px;
    }
    #app{max-width:1200px;margin:auto;display:flex;flex-direction:column;gap:12px;}
    header{display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between;padding:14px 16px;background:var(--panel);border:1px solid var(--border);border-radius:12px;box-shadow:var(--shadow);position:sticky;top:0;z-index:3;backdrop-filter:blur(6px);}
    .title{font-size:20px;font-weight:700;letter-spacing:0.5px;display:flex;align-items:center;gap:8px;}
    .tagline{font-size:13px;color:var(--muted);}
    .pill{border:1px solid var(--border);border-radius:999px;padding:6px 10px;font-size:12px;color:var(--muted);background:rgba(255,255,255,0.02);}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:14px 16px;box-shadow:var(--shadow);}
    .panel h3{margin:0 0 6px;font-size:15px;letter-spacing:0.4px;}
    .grid-two{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:10px;}
    .statline{display:grid;grid-template-columns:110px 1fr 60px;align-items:center;font-size:13px;gap:8px;padding:6px 0;border-bottom:1px solid rgba(255,255,255,0.03);}    
    .bar{height:8px;background:#0f111a;border-radius:999px;overflow:hidden;border:1px solid #16182a;}
    .bar span{display:block;height:100%;border-radius:999px;}
    .bar.hp span{background:linear-gradient(90deg,#ff7a7a,#ffb36b);}    
    .bar.stamina span{background:linear-gradient(90deg,#71d2ff,#82ffa4);}    
    .bar.morale span{background:linear-gradient(90deg,#8aa9ff,#c3a1ff);}    
    .bar.rads span{background:linear-gradient(90deg,#80ffd3,#fffd8a);}    
    .bar.hunger span{background:linear-gradient(90deg,#ffc46a,#ff8c8c);}    
    .bar.thirst span{background:linear-gradient(90deg,#6ad8ff,#7f9cff);}    
    .bar.temp span{background:linear-gradient(90deg,#8fffa3,#5bd1ff);}    
    .rows{display:flex;flex-direction:column;gap:8px;}
    .meta{color:var(--muted);font-size:13px;display:flex;flex-wrap:wrap;gap:10px;}
    .meta b{color:#e8edf7;margin-right:4px;}
    .pill-inline{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;border:1px solid var(--border);background:rgba(255,255,255,0.03);font-size:12px;color:var(--muted);}    
    button{appearance:none;border:1px solid var(--border);background:var(--panel-2);color:#f6f7ff;border-radius:10px;padding:10px 12px;font-size:14px;text-align:left;cursor:pointer;transition:transform .05s ease, border .15s ease;display:flex;justify-content:space-between;align-items:center;gap:6px;min-height:46px;}
    button:hover{transform:translateY(-1px);border-color:var(--accent);}    
    button:active{transform:translateY(0);}
    .btn-secondary{background:#0f111a;}
    .danger{border-color:rgba(255,107,107,.6);color:#ffc2c2;}
    #doors,#raidActions{display:flex;flex-direction:column;gap:8px;}
    .log{white-space:pre-wrap;font-size:13px;color:#d8e1ff;line-height:1.35;max-height:320px;overflow:auto;padding:10px;background:#0f111a;border:1px solid var(--border);border-radius:12px;box-shadow:inset 0 0 0 1px rgba(255,255,255,0.02);}
    .small{font-size:12px;color:var(--muted);}
    .scene-title{font-size:17px;margin:0;color:#e8f1ff;}
    .scene-desc{margin:6px 0 10px;color:#cfd8ec;font-size:14px;}
    .badge{font-size:12px;border-radius:8px;padding:2px 8px;background:rgba(91,209,255,.08);border:1px solid rgba(91,209,255,.45);color:var(--accent-2);display:inline-flex;gap:6px;align-items:center;}
    .inline{display:flex;flex-wrap:wrap;gap:8px;align-items:center;}
    .inventory{display:flex;flex-wrap:wrap;gap:6px;margin-bottom:8px;}
    .inventory button{border:1px solid var(--border);padding:8px 10px;border-radius:10px;background:rgba(255,255,255,0.02);font-size:13px;cursor:pointer;}
    .inventory button:hover{border-color:var(--accent);}
    .inventory h4{margin:4px 0;font-size:13px;color:#cfd8ec;width:100%;}
    .inventory .pill-inline{margin-top:4px;}
    .inventory .inline-actions{width:100%;display:flex;flex-wrap:wrap;gap:6px;align-items:center;}
    .two-col{display:grid;grid-template-columns:1.1fr 1fr;gap:12px;}
    .tabs{background:var(--panel);border:1px solid var(--border);border-radius:12px;box-shadow:var(--shadow);}
    .tab-buttons{display:flex;gap:8px;padding:10px 12px;border-bottom:1px solid var(--border);flex-wrap:wrap;background:rgba(255,255,255,0.02);border-radius:12px 12px 0 0;}
    .tab-buttons button{flex:1 1 120px;text-align:center;justify-content:center;border-radius:10px;padding:10px 12px;border:1px solid var(--border);background:#0f111a;color:#e8edf7;min-height:40px;}
    .tab-buttons button.active{border-color:var(--accent);background:rgba(91,209,255,0.08);}
    .tab-buttons button:disabled{opacity:0.35;cursor:not-allowed;border-style:dashed;}
    .tab-content{display:none;padding:12px;}
    .tab-content.active{display:block;}
    .muted-box{padding:14px 16px;border-radius:10px;border:1px dashed var(--border);color:var(--muted);background:rgba(255,255,255,0.03);}
    .stack{display:flex;flex-direction:column;gap:12px;}
    .excursion-status{font-size:13px;color:var(--muted);display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
    .excursion-status b{color:#e8edf7;}
    .progress{height:10px;border-radius:999px;background:#0f111a;border:1px solid #1c1f32;overflow:hidden;}
    .progress span{display:block;height:100%;background:linear-gradient(90deg,#5bd1ff,#8fffa3);border-radius:999px;transition:width .2s ease;}
    .op-card{border:1px solid var(--border);border-radius:12px;padding:12px;background:rgba(255,255,255,0.02);display:flex;flex-direction:column;gap:8px;}
    .op-meta{display:flex;flex-wrap:wrap;gap:8px;color:var(--muted);font-size:12px;}
    .op-actions{display:flex;gap:8px;flex-wrap:wrap;}
    .screen-nav{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px;}
    .screen{display:none;flex-direction:column;gap:12px;}
    .screen.active{display:flex;}
    .spinner{width:18px;height:18px;border-radius:999px;border:2px solid rgba(255,255,255,0.2);border-top-color:var(--accent);animation:spin 0.8s linear infinite;}
    .spin-row{display:flex;align-items:center;gap:8px;font-size:13px;color:var(--muted);}
    .mission-card{display:flex;flex-direction:column;gap:10px;}
    .mission-title{font-size:16px;font-weight:600;}
    .mission-meta{font-size:13px;color:var(--muted);}
    .mission-actions{display:flex;gap:8px;flex-wrap:wrap;}
    @keyframes spin{to{transform:rotate(360deg);}}
    .item-grid{display:flex;flex-direction:column;gap:10px;}
    .icon-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(96px,1fr));gap:8px;}
    .icon-tile{align-items:flex-start;justify-content:space-between;flex-direction:column;gap:6px;aspect-ratio:1;padding:8px 10px;min-height:0;background:rgba(255,255,255,0.03);text-align:left;}
    .icon-tile .icon-name{font-weight:600;font-size:12px;line-height:1.25;}
    .icon-tile .icon-meta{font-size:10px;color:var(--muted);}
    .icon-tile .icon-count{font-size:11px;color:var(--muted);}
    .icon-tile.selected{border-color:var(--accent);box-shadow:0 0 0 1px rgba(91,209,255,0.3);}
    .icon-tile.empty{opacity:0.45;cursor:default;}
    .icon-tile.empty:hover{border-color:var(--border);transform:none;}
    .icon-pager{display:flex;gap:8px;align-items:center;justify-content:space-between;margin-top:8px;flex-wrap:wrap;}
    .icon-pager .page-info{font-size:12px;color:var(--muted);}
    .item-row{display:flex;flex-wrap:wrap;align-items:center;gap:8px;padding:10px;border:1px solid var(--border);border-radius:10px;background:rgba(255,255,255,0.02);}
    .item-row.selectable{cursor:pointer;transition:border .15s ease,transform .05s ease;}
    .item-row.selectable:hover{border-color:var(--accent);transform:translateY(-1px);}
    .item-row.selected{border-color:var(--accent);box-shadow:0 0 0 1px rgba(91,209,255,0.3);}
    .item-name{font-weight:600;}
    .item-meta{font-size:12px;color:var(--muted);}
    .item-actions{display:flex;flex-wrap:wrap;gap:6px;margin-left:auto;}
    .chip{border:1px solid var(--border);border-radius:999px;padding:2px 8px;font-size:11px;color:var(--muted);}
    .chip.common{color:#cfd8ec;}
    .chip.uncommon{color:#8fffa3;}
    .chip.rare{color:#5bd1ff;}
    .chip.epic{color:#c3a1ff;}
    .chip.legendary{color:#ffcf6a;}
    .inventory-layout{display:grid;grid-template-columns:minmax(0,1.1fr) minmax(0,0.9fr);gap:12px;align-items:start;}
    .subtabs{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px;}
    .subtabs button{flex:1 1 120px;justify-content:center;text-align:center;min-height:38px;padding:8px 10px;background:#0f111a;}
    .subtabs button.active{border-color:var(--accent);background:rgba(91,209,255,0.08);}
    .subscreen{display:none;}
    .subscreen.active{display:block;}
    .command-card{border:1px solid var(--border);border-radius:12px;padding:12px;background:rgba(255,255,255,0.02);display:flex;flex-direction:column;gap:10px;}
    .command-title{font-size:15px;font-weight:600;}
    .stat-list{display:grid;grid-template-columns:120px 1fr;gap:6px;font-size:13px;color:var(--muted);}
    .stat-list span{color:#e8edf7;}
    .action-grid{display:flex;flex-wrap:wrap;gap:8px;}
    .command-hint{font-size:12px;color:var(--muted);}
    .status-toggle{display:flex;align-items:center;gap:10px;font-size:13px;color:var(--muted);}
    .status-toggle button{min-height:36px;padding:6px 10px;}
    .combat-hud{border:1px solid var(--border);border-radius:12px;padding:10px;background:#0f111a;display:flex;flex-direction:column;gap:8px;}
    .combat-hud .combat-title{font-weight:600;font-size:14px;}
    .combat-stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:6px;font-size:13px;color:var(--muted);}
    .combat-stats b{color:#e8edf7;}
    .combat-consumables{display:flex;flex-direction:column;gap:6px;}
    .combat-consumables .inline-actions{margin-top:4px;}
    .recipe-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:8px;}
    .recipe-card{border:1px solid var(--border);border-radius:12px;padding:10px;background:rgba(255,255,255,0.02);display:flex;flex-direction:column;gap:6px;}
    .recipe-card .title-row{display:flex;justify-content:space-between;align-items:center;gap:6px;}
    .recipe-card .reqs{font-size:12px;color:var(--muted);}
    .pager{display:flex;flex-wrap:wrap;gap:8px;align-items:center;justify-content:space-between;margin-top:10px;}
    .pager .page-info{font-size:12px;color:var(--muted);}
    .pager button{min-height:36px;padding:6px 10px;justify-content:center;text-align:center;flex:0 0 auto;}
    .market-section{margin-top:12px;display:flex;flex-direction:column;gap:8px;}
    .market-section h4{margin:0;font-size:14px;color:#e8f1ff;}
    .market-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:8px;}
    .market-card{border:1px solid var(--border);border-radius:12px;padding:10px;background:rgba(255,255,255,0.02);display:flex;flex-direction:column;gap:6px;}
    .market-card .title-row{display:flex;justify-content:space-between;align-items:center;gap:6px;}
    .market-card .cost{font-size:12px;color:var(--accent-2);}
    .modal{position:fixed;inset:0;background:rgba(6,8,14,0.78);display:flex;align-items:center;justify-content:center;z-index:20;}
    .modal.hidden{display:none;}
    .modal-card{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:18px 20px;box-shadow:var(--shadow);width:min(440px,92%);display:flex;flex-direction:column;gap:10px;}
    .modal-actions{display:flex;gap:10px;justify-content:flex-end;flex-wrap:wrap;}
    @media(max-width:900px){header{position:static;} .two-col{grid-template-columns:1fr;} .tab-buttons button{flex:1 1 100%;}}
    @media(max-width:900px){.inventory-layout{grid-template-columns:1fr;}}
  </style>
</head>
<body>
  <div id="introModal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-card">
      <div class="command-title" id="introTitle">Welcome to Zero Lux</div>
      <div class="small" id="introMessage"></div>
      <div class="modal-actions" id="introActions"></div>
    </div>
  </div>
  <div id="app">
    <header>
      <div>
        <div class="title">Zones - fight, loot, survive. <span class="pill">inventory / looter / idle</span></div>
        <div class="tagline">Pick zones, run salvage loops, and sort rewards into gear, stash, or scrap.</div>
      </div>
      <div class="pill">Build #: 0.2b — inventory-focused loop</div>
    </header>

    <section class="panel">
      <div class="two-col">
        <div>
          <h3>Status Board</h3>
          <div id="stats"></div>
          <div class="meta" id="meta"></div>
        </div>
        <div class="rows">
          <div class="excursion-status" id="excursionStatus"></div>
          <div class="muted-box" id="tempoHint"></div>
        </div>
      </div>
    </section>

    <div class="tabs">
      <div class="tab-buttons">
        <button data-tab="hub" class="active">Operations</button>
        <button data-tab="inventory">Backpack</button>
        <button data-tab="field">Stash</button>
      </div>
      <div id="tab-hub" class="tab-content active">
        <div class="stack">
          <div class="screen-nav" id="screenNav">
            <button data-screen="main" class="active">Main Hub</button>
            <button data-screen="locations">Locations Hub</button>
          </div>
          <div id="screen-main" class="screen active">
            <section class="panel">
              <h3>Main Hub Deck</h3>
              <div class="rows">
                <div class="inline" style="justify-content:space-between;align-items:center;">
                  <div>
                    <p class="scene-title">Zero Lux Command Deck</p>
                    <p class="scene-desc">Synchronize with the field grid, then step into the locations hub to launch a raid.</p>
                  </div>
                  <span class="badge">Hub secure</span>
                </div>
                <div id="hubLock" class="muted-box"></div>
                <button id="enterLocations">Enter locations hub</button>
              </div>
            </section>
            <section class="panel">
              <h3>Idle Operations</h3>
              <div id="idleOps"></div>
            </section>
          </div>
          <div id="screen-locations" class="screen">
            <section class="panel">
              <h3>Transit Console</h3>
              <div class="spin-row" id="travelStatus"></div>
              <button class="btn-secondary" id="returnMain">Return to main hub</button>
            </section>
            <section class="panel">
              <h3>Zone Gates</h3>
              <div id="doors"></div>
              <div class="small" id="doorsHint">Loading expansions…</div>
            </section>
            <section class="panel">
              <div class="inline" style="justify-content:space-between;align-items:center;">
                <div>
                  <p class="scene-title" id="zoneTitle">Drift Yard</p>
                  <p class="scene-desc" id="zoneDesc">Low-risk salvage corridor. Ideal for stocking up on scrap and common gear.</p>
                </div>
                <span class="badge" id="zoneBadge">Low risk</span>
              </div>
              <div id="raidActions"></div>
            </section>
          </div>
          <div id="screen-mission" class="screen">
            <section class="panel">
              <h3>Mission Feed</h3>
              <div class="mission-card">
                <div class="mission-title" id="missionTitle">No mission active.</div>
                <div class="mission-meta" id="missionMeta"></div>
                <div class="progress" id="missionProgress"><span style="width:0%;"></span></div>
                <div class="small" id="missionLog"></div>
                <div class="mission-actions" id="missionActions"></div>
              </div>
              <div class="command-card" id="missionRewardsCard">
                <div class="command-title">Mission rewards</div>
                <div id="missionRewardDetail" class="command-hint">Complete a mission to review rewards.</div>
                <div class="action-grid" id="missionRewardActions"></div>
                <div id="missionRewardList" class="item-grid"></div>
              </div>
            </section>
          </div>
        </div>
      </div>
      <div id="tab-inventory" class="tab-content">
        <section class="panel">
          <h3>Backpack & Loadout</h3>
          <div class="subtabs" id="inventoryNav">
            <button data-inv-screen="backpack" class="active">Backpack</button>
            <button data-inv-screen="loadout">Loadout</button>
            <button data-inv-screen="crafting">Crafting</button>
          </div>
          <div class="inventory-layout">
            <div>
              <div id="inventoryBackpack" class="subscreen active">
                <h4>Backpack Contents <span class="small" id="backpackCount"></span></h4>
                <div class="item-grid" id="inventory"></div>
              </div>
              <div id="inventoryLoadout" class="subscreen">
                <h4>Equipped Loadout <span class="small" id="loadoutCount"></span></h4>
                <div class="item-grid" id="equipment"></div>
              </div>
              <div id="inventoryCrafting" class="subscreen">
                <h4>Field Crafting</h4>
                <div class="command-hint">Combine junk stacks into quick survival tools.</div>
                <div id="crafting"></div>
              </div>
            </div>
            <div class="command-card">
              <div class="command-title">Selected item</div>
              <div id="itemDetail" class="command-hint">Select gear to view stats, uses, and actions.</div>
              <div class="action-grid" id="itemActions"></div>
            </div>
          </div>
          <div class="small" id="codex"></div>
        </section>
      </div>
      <div id="tab-field" class="tab-content">
        <section class="panel">
          <h3 id="stashTitle">Stash Vault</h3>
          <div class="subtabs" id="stashNav">
            <button data-stash-screen="vault" class="active">Vault</button>
          </div>
          <div class="inventory-layout">
            <div>
              <div id="stashVault" class="subscreen active">
                <h4 id="stashSubtitle">Vault Inventory <span class="small" id="stashCount"></span></h4>
                <div id="stash"></div>
                <div class="market-section">
                  <h4>Vendor stock</h4>
                  <div class="command-hint" id="marketHint">Visit a shop in your current location to access vendors.</div>
                  <div id="marketInventory" class="market-grid"></div>
                </div>
              </div>
            </div>
            <div class="command-card">
              <div class="command-title">Vault Command Card</div>
              <div id="stashDetail" class="command-hint">Select stash items to transfer, scrap, or sell.</div>
              <div class="action-grid" id="stashItemActions"></div>
            </div>
          </div>
          <p class="small">Move rewards into long-term storage, or liquidate overflow for credits.</p>
        </section>
      </div>
    </div>
  </div>

  <script>
    /* ================= STATE & CONSTANTS ================= */
    const SAVE_KEY='zeroLuxSave';
    const SAVE_VERSION=1;
    const createDefaultState=()=>({
      hp:92,maxHp:100,
      stamina:90,maxStamina:100,
      morale:62,maxMorale:100,
      hunger:15,maxHunger:100,
      thirst:20,maxThirst:100,
      energy:72,maxEnergy:100,
      rads:0,
      bodyTemp:98,maxBodyTemp:104,
      scrap:6,
      credits:50,
      keys:1,
      level:1,xp:0,nextLevelXp:80,
      day:1,timeMinutes:6*60,
      backpackLimit:0,
      stashLimit:40,
      stashUpgradeLevel:0,
      craftingPage:0,
      inventoryPage:0,
      stashPage:0,
      loadoutPage:0,
      inventory:["rusty flashlight","ration bar","scrap wiring"],
      equipped:['basic backpack'],
      codex:["Hub online. Reward bays clear."],
      stash:{name:'Vault Stash',items:[]},
      marketAccess:{active:false,zoneId:null},
      idleOps:{active:false,id:null,startedAt:null,durationMs:0,etaMinutes:0,completed:false,statusMessage:'',rewards:[]},
      flags:new Set(),
      zone:{id:'drift-yard',name:'Drift Yard',risk:'low',desc:'Low-risk salvage corridor. Ideal for stocking up on scrap and common gear.',sceneId:null},
      screen:'main',
      travel:{active:false,endsAt:null,target:null},
      mission:{active:false,type:null,raid:null,startedAt:null,endsAt:null,completed:false,success:null,summary:'',rewards:[],statusMessage:'',location:null,fleeing:false,fleeEndsAt:null,pendingResolution:null,xpReward:0,rewardEffects:{success:'',fail:''},questMeta:null,combat:null,sceneTarget:null},
      inventoryScreen:'backpack',
      stashScreen:'vault',
      selected:{source:null,item:null}
    });
    const hydrateState=(saved)=>{
      const base=createDefaultState();
      if(!saved || typeof saved!=='object') return base;
      const merged={...base,...saved};
      merged.flags=new Set(saved.flags || []);
      merged.stash={...base.stash,...(saved.stash||{})};
      merged.marketAccess={...base.marketAccess,...(saved.marketAccess||{})};
      merged.idleOps={...base.idleOps,...(saved.idleOps||{})};
      merged.zone={...base.zone,...(saved.zone||{})};
      merged.travel={...base.travel,...(saved.travel||{})};
      merged.mission={...base.mission,...(saved.mission||{})};
      merged.selected={...base.selected,...(saved.selected||{})};
      return merged;
    };
    const loadSavedState=()=>{
      try{
        const raw=localStorage.getItem(SAVE_KEY);
        if(!raw) return null;
        return hydrateState(JSON.parse(raw));
      }catch(err){
        console.warn('Save load failed.',err);
        return null;
      }
    };
    let pendingSave=null;
    let lastSaveAt=0;
    const saveGame=()=>{
      try{
        const payload={...state,flags:Array.from(state.flags||[]),saveVersion:SAVE_VERSION};
        localStorage.setItem(SAVE_KEY,JSON.stringify(payload));
        lastSaveAt=Date.now();
      }catch(err){
        console.warn('Save failed.',err);
      }
    };
    const savedState=loadSavedState();
    let state=createDefaultState();
    let allowAutosave=!savedState;
    const MISSION_OVERRUN_MULTIPLIER=2;
    const SAVE_DEBOUNCE_MS=1500;
    const SAVE_MIN_INTERVAL_MS=8000;
    const queueSave=({force=false}={})=>{
      if(!allowAutosave) return;
      if(force){
        if(pendingSave){
          clearTimeout(pendingSave);
          pendingSave=null;
        }
        saveGame();
        return;
      }
      if(pendingSave) return;
      const now=Date.now();
      const elapsed=now-lastSaveAt;
      const delay=Math.max(0,elapsed>=SAVE_MIN_INTERVAL_MS ? SAVE_DEBOUNCE_MS : SAVE_MIN_INTERVAL_MS-elapsed);
      pendingSave=setTimeout(()=>{
        pendingSave=null;
        saveGame();
      },delay);
    };

    const ITEM_CATALOG={
      'basic backpack':{type:'armor',slot:'backpack',rarity:'common',value:6,mods:{carryBonus:6,insulation:0.1}},
      'rusty flashlight':{type:'tool',slot:'tool',rarity:'common',value:6,mods:{riskMod:-0.02}},
      'cargo pants':{type:'armor',slot:'pants',rarity:'common',value:7,mods:{insulation:0.4}},
      'field backpack':{type:'armor',slot:'backpack',rarity:'uncommon',value:14,mods:{carryBonus:9,insulation:0.2}},
      'flare':{type:'tool',slot:'tool',rarity:'uncommon',value:10,mods:{lootBonus:0.04}},
      'patch kit':{type:'tool',slot:'tool',rarity:'uncommon',value:12,mods:{riskMod:-0.04}},
      'patch-kit':{type:'tool',slot:'tool',rarity:'uncommon',value:12,mods:{riskMod:-0.04}},
      'utility coat':{type:'armor',slot:'chest',rarity:'uncommon',value:12,mods:{staminaBonus:1,insulation:0.8}},
      'microcell':{type:'tool',slot:'tool',rarity:'rare',value:22,mods:{idleSpeed:0.15,energyRegen:1,staminaBonus:2}},
      'rigged backpack':{type:'armor',slot:'backpack',rarity:'rare',value:24,mods:{carryBonus:12,insulation:0.3}},
      'bandage':{type:'consumable',rarity:'common',value:4,effect:'hp+8'},
      'ration bar':{type:'consumable',rarity:'common',value:3,effect:'hunger-12,morale+2'},
      'water flask':{type:'consumable',rarity:'common',value:4,effect:'thirst-12'},
      'spark tonic':{type:'consumable',rarity:'uncommon',value:8,effect:'energy+18,stamina+6'},
      'scrap wiring':{type:'junk',rarity:'common',value:2,salvage:2,stackable:true},
      'scrap bundle':{type:'junk',rarity:'common',value:1,salvage:1,stackable:true},
      'wire spool':{type:'junk',rarity:'common',value:2,salvage:2,stackable:true},
      'cloth scraps':{type:'junk',rarity:'common',value:1,salvage:1,stackable:true},
      'plastic shards':{type:'junk',rarity:'common',value:1,salvage:1,stackable:true},
      'electronics bits':{type:'junk',rarity:'common',value:3,salvage:2,stackable:true},
      'old coin':{type:'junk',rarity:'uncommon',value:6,salvage:1},
      'lockbox key':{type:'key',rarity:'rare',value:18},
      'echo prism':{type:'junk',rarity:'rare',value:20,salvage:6},
      'drone core':{type:'tool',slot:'tool',rarity:'epic',value:32,mods:{lootBonus:0.08,energyRegen:2}},
      'relic shard':{type:'junk',rarity:'legendary',value:60,salvage:12},
      'rust town crown':{type:'armor',slot:'helmet',rarity:'legendary',value:85,mods:{moraleBonus:4,insulation:0.6}},
      'iron crown':{type:'armor',slot:'helmet',rarity:'legendary',value:85,mods:{moraleBonus:4,insulation:0.6}},
      'safehouse warden coat':{type:'armor',slot:'chest',rarity:'legendary',value:90,mods:{staminaBonus:4,insulation:1}},
      'forest monolith sigil':{type:'tool',slot:'tool',rarity:'legendary',value:95,mods:{lootBonus:0.12,energyRegen:2}},
      'neon riot jacket':{type:'armor',slot:'chest',rarity:'legendary',value:88,mods:{insulation:0.9,moraleBonus:2}},
      'field rations':{type:'consumable',rarity:'common',value:5,effect:'hunger-16,stamina+4'},
      'water canister':{type:'consumable',rarity:'common',value:5,effect:'thirst-18,temp-1'},
      'painkillers':{type:'consumable',rarity:'uncommon',value:11,effect:'hp+12,morale+2'},
      'glowing herbs':{type:'consumable',rarity:'uncommon',value:10,effect:'rads-4,temp+1'},
      'military rations':{type:'consumable',rarity:'uncommon',value:12,effect:'hunger-22,stamina+6'},
      'coil battery':{type:'tool',slot:'tool',rarity:'uncommon',value:13,mods:{energyRegen:1}},
      'spare filter':{type:'tool',slot:'tool',rarity:'uncommon',value:12,mods:{riskMod:-0.03}},
      'copper wire':{type:'junk',rarity:'common',value:4,salvage:3,stackable:true},
      'reactor shard':{type:'junk',rarity:'rare',value:34,salvage:10},
      'exo brace':{type:'armor',slot:'gloves',rarity:'rare',value:28,mods:{staminaBonus:4,insulation:0.4}},
      'neon sneakers':{type:'armor',slot:'shoes',rarity:'uncommon',value:16,mods:{staminaBonus:2}},
      'underground map':{type:'tool',slot:'tool',rarity:'uncommon',value:15,mods:{riskMod:-0.05,lootBonus:0.03}},
      'meme-drive':{type:'tool',slot:'tool',rarity:'rare',value:26,mods:{lootBonus:0.06}},
      'holo wristband':{type:'tool',slot:'tool',rarity:'uncommon',value:14,mods:{moraleBonus:2}},
      'riot shield':{type:'weapon',slot:'weapon',rarity:'rare',value:30,mods:{riskMod:-0.06,insulation:0.5}},
      'flare paint':{type:'tool',slot:'tool',rarity:'uncommon',value:13,mods:{lootBonus:0.05}},
      'flashbang':{type:'tool',slot:'tool',rarity:'rare',value:24,mods:{combatBonus:5}},
      'foam canister':{type:'tool',slot:'tool',rarity:'uncommon',value:15,mods:{combatBonus:3,riskMod:-0.02}},
      'viral clip drive':{type:'junk',rarity:'rare',value:28,salvage:7},
      'limited hoodie':{type:'armor',slot:'chest',rarity:'rare',value:27,mods:{moraleBonus:3,insulation:0.6}},
      'payload crate':{type:'junk',rarity:'uncommon',value:18,salvage:5},
      'stun baton':{type:'weapon',slot:'weapon',rarity:'rare',value:29,mods:{combatBonus:6}},
      'mystery supply':{type:'junk',rarity:'rare',value:25,salvage:6},
      'salvaged tech':{type:'junk',rarity:'rare',value:27,salvage:8},
      'shock gel':{type:'consumable',rarity:'uncommon',value:12,effect:'hp+10,temp+1'},
      'overclock chip':{type:'tool',slot:'tool',rarity:'rare',value:31,mods:{energyRegen:2,combatBonus:4}},
      'insulated cloak':{type:'armor',slot:'chest',rarity:'rare',value:26,mods:{insulation:1.1,riskMod:-0.02}},
      'scavenger harness':{type:'armor',slot:'chest',rarity:'uncommon',value:17,mods:{staminaBonus:2}},
      'hardened canteen':{type:'consumable',rarity:'uncommon',value:9,effect:'thirst-16,stamina+3'},
      'ember ration':{type:'consumable',rarity:'common',value:6,effect:'hunger-14,temp+2'},
      'signal jammer':{type:'tool',slot:'tool',rarity:'rare',value:33,mods:{riskMod:-0.07,combatBonus:2}},

      /* base items */
      'pocket pack':{type:'armor',slot:'backpack',rarity:'common',value:18,mods:{carryBonus:7}},
      'scout daypack':{type:'armor',slot:'backpack',rarity:'uncommon',value:26,mods:{carryBonus:8}},
      'salvage tote':{type:'armor',slot:'backpack',rarity:'uncommon',value:24,mods:{carryBonus:9}},
      'expedition frame pack':{type:'armor',slot:'backpack',rarity:'rare',value:44,mods:{carryBonus:14}},
      'jury-rigged blade':{type:'weapon',slot:'weapon',rarity:'common',value:9,mods:{combatBonus:3}},
      'scrap spear':{type:'weapon',slot:'weapon',rarity:'uncommon',value:18,mods:{combatBonus:5,lootBonus:0.01}},
      'pipe rifle':{type:'weapon',slot:'weapon',rarity:'rare',value:32,mods:{combatBonus:7,riskMod:-0.01}},
      'compact medkit':{type:'consumable',rarity:'uncommon',value:14,effect:'hp+18'},
      'filtered water pack':{type:'consumable',rarity:'uncommon',value:13,effect:'thirst-20,rads-2'},
      'morale patch':{type:'consumable',rarity:'common',value:7,effect:'morale+8,stamina+2'},

      /* iron ward */
      'ledger-etched compass':{type:'tool',slot:'tool',rarity:'uncommon',value:19,mods:{riskMod:-0.04,lootBonus:0.02}},
      'clocktower chime':{type:'junk',rarity:'uncommon',value:16,salvage:4},
      'iron ward seals':{type:'junk',rarity:'common',value:3,salvage:2,stackable:true},
      'market shock knife':{type:'weapon',slot:'weapon',rarity:'rare',value:34,mods:{combatBonus:6,lootBonus:0.02}},
      'tarpaulin roll':{type:'junk',rarity:'common',value:4,salvage:2,stackable:true},

      /* cold shelter */
      'thermal wrap':{type:'consumable',rarity:'common',value:6,effect:'temp+3,stamina+4'},
      'bunker schematics':{type:'tool',slot:'tool',rarity:'uncommon',value:21,mods:{riskMod:-0.02}},
      'lantern oil':{type:'junk',rarity:'common',value:2,salvage:1,stackable:true},
      'stabilizer brace':{type:'armor',slot:'gloves',rarity:'uncommon',value:20,mods:{staminaBonus:3,insulation:0.3}},
      'cache latch':{type:'junk',rarity:'uncommon',value:10,salvage:3},

      /* blackwood expanse */
      'spore lantern':{type:'tool',slot:'tool',rarity:'uncommon',value:22,mods:{riskMod:-0.03,lootBonus:0.03}},
      'rad moss poultice':{type:'consumable',rarity:'uncommon',value:15,effect:'hp+10,rads-5,temp+1'},
      'hardened bark plate':{type:'armor',slot:'chest',rarity:'uncommon',value:18,mods:{insulation:0.7,riskMod:-0.02}},
      'monsoon canteen':{type:'consumable',rarity:'rare',value:23,effect:'thirst-24,temp+1'},
      'feral talon':{type:'junk',rarity:'rare',value:24,salvage:7},

      /* downtown portland */
      'floodgate keycard':{type:'key',rarity:'rare',value:22},
      'signal flare rack':{type:'tool',slot:'tool',rarity:'uncommon',value:20,mods:{lootBonus:0.05,moraleBonus:1}},
      'riot-line tape':{type:'junk',rarity:'common',value:3,salvage:2,stackable:true},
      'bridge-runner pack':{type:'armor',slot:'backpack',rarity:'uncommon',value:28,mods:{carryBonus:10}},
      'arc pistol':{type:'weapon',slot:'weapon',rarity:'rare',value:38,mods:{combatBonus:8,energyRegen:1}}
    };

    const LOOT_BY_RARITY={
      common:['bandage','ration bar','water flask','scrap wiring','scrap bundle','wire spool','cloth scraps','plastic shards','electronics bits','rusty flashlight','cargo pants','field rations','water canister','copper wire','ember ration','morale patch','pocket pack','jury-rigged blade','iron ward seals','tarpaulin roll','lantern oil','thermal wrap','riot-line tape'],
      uncommon:['flare','patch kit','patch-kit','old coin','spark tonic','utility coat','field backpack','coil battery','spare filter','neon sneakers','underground map','holo wristband','flare paint','foam canister','scavenger harness','hardened canteen','shock gel','salvage tote','scout daypack','scrap spear','compact medkit','filtered water pack','ledger-etched compass','clocktower chime','bunker schematics','stabilizer brace','cache latch','spore lantern','rad moss poultice','hardened bark plate','signal flare rack','bridge-runner pack'],
      rare:['microcell','lockbox key','echo prism','rigged backpack','exo brace','reactor shard','meme-drive','riot shield','flashbang','limited hoodie','stun baton','mystery supply','salvaged tech','overclock chip','insulated cloak','signal jammer','viral clip drive','expedition frame pack','pipe rifle','market shock knife','monsoon canteen','feral talon','floodgate keycard','arc pistol'],
      epic:['drone core'],
      legendary:['relic shard','rust town crown','iron crown','safehouse warden coat','forest monolith sigil','neon riot jacket']
    };

    const RAID_TEMPLATES=[
      {id:'quick',label:'Quick Grab',desc:'Fast sweep for low-tier gear.',time:6,energy:8,loot:2,risk:'low'},
      {id:'deep',label:'Deep Sweep',desc:'Longer push with higher-value crates.',time:12,energy:14,loot:3,risk:'medium'},
      {id:'hazard',label:'Hazard Drift',desc:'Pressurized route for rare tech.',time:16,energy:18,loot:4,risk:'high'},
      {id:'vault',label:'Lockbox Crack',desc:'Spend a key to crack sealed cache.',time:10,energy:10,loot:3,risk:'high',key:1}
    ];

    const ACTION_TIMES={camp:10};
    const riskTable={low:0.08,medium:0.2,high:0.32,deadly:0.45};
    const riskRank={low:1,medium:2,high:3,deadly:4};
    const expansions={};
    const EXPANSION_MANIFEST=[
      {id:'town',name:'Iron Ward',file:'expansions/town.txt'},
      {id:'safehouse',name:'Cold Shelter',file:'expansions/safehouse.txt'},
      {id:'forest',name:'Blackwood Expanse',file:'expansions/forest.txt'},
      {id:'portland_slums',name:'Downtown Portland',file:'expansions/portland_slums.txt'}
    ];
    let expansionsExpected=0;
    let expansionsLoaded=0;
    let expansionsAttempted=0;
    const idleOperations=[
      {id:'salvage',label:'Drone salvage',desc:'Remote drones bring back scrap and junk.',duration:7,cost:{credits:8},reward:'scrap+3,item:scrap wiring'},
      {id:'survey',label:'Cartography sweep',desc:'Low-risk sweep for new routes and caches.',duration:5,cost:{credits:5},reward:'credits+4,item:old coin'},
      {id:'resupply',label:'Supply errand',desc:'Courier route for field medicine.',duration:9,cost:{credits:10,scrap:1},reward:'item:bandage,item:water flask'}
    ];

    const IDLE_DURATION_MULTIPLIER=1.65;
    const formatMinutesPrecise=(minutes)=>minutes>=1?`${minutes.toFixed(1)} min`:`${Math.max(5,Math.round(minutes*60))}s`;
    const getIdleDurationMinutes=(op,gearMods=getGearMods())=>{
      const base=Math.max(4,op.duration*IDLE_DURATION_MULTIPLIER);
      return Math.max(3,base*(1-(gearMods.idleSpeed||0)));
    };

    const CRAFTING_PAGE_SIZE=4;
    const CRAFTING_RECIPES=[
      {id:'bandage',label:'Bandage',desc:'Quick field wrap to stabilize wounds.',cost:{'cloth scraps':5}},
      {id:'water flask',label:'Water flask',desc:'Patch together a reusable hydration pouch.',cost:{'plastic shards':6,'cloth scraps':3}},
      {id:'ration bar',label:'Ration bar',desc:'Compress salvageable nutrients into a meal.',cost:{'scrap bundle':7,'plastic shards':2}},
      {id:'patch kit',label:'Patch kit',desc:'Bundle wire and electronics into repair gear.',cost:{'wire spool':8,'electronics bits':4}},
      {id:'morale patch',label:'Morale patch',desc:'Stitch a bright patch that steadies nerves.',cost:{'cloth scraps':4,'plastic shards':2}},
      {id:'compact medkit',label:'Compact medkit',desc:'Upgrade basic wraps into a full trauma pack.',cost:{'bandage':2,'cloth scraps':6,'electronics bits':3}},
      {id:'filtered water pack',label:'Filtered water pack',desc:'Pair a flask with a fresh filter for clean water.',cost:{'water flask':1,'spare filter':1,'plastic shards':4}},
      {id:'jury-rigged blade',label:'Jury-rigged blade',desc:'Sharpen scrap into a brutal close-range tool.',cost:{'scrap wiring':4,'wire spool':3}},
      {id:'scrap spear',label:'Scrap spear',desc:'Bind rods and scrap into a reach advantage.',cost:{'copper wire':3,'scrap bundle':6,'cloth scraps':5}},
      {id:'pocket pack',label:'Pocket pack',desc:'Add extra compartments without adding weight.',cost:{'cloth scraps':6,'plastic shards':3}},
      {id:'salvage tote',label:'Salvage tote',desc:'Reinforce a tote for hauling extra salvage.',cost:{'cloth scraps':8,'plastic shards':5,'wire spool':4}},
      {id:'scout daypack',label:'Scout daypack',desc:'Build a balanced daypack for longer routes.',cost:{'salvage tote':1,'wire spool':4,'cloth scraps':6}},
      {id:'bridge-runner pack',label:'Bridge-runner pack',desc:'Tethered pack tuned for wet transit lanes.',cost:{'salvage tote':1,'riot-line tape':4,'wire spool':4}},
      {id:'ledger-etched compass',label:'Ledger-etched compass',desc:'Etch trade routes into a compass that never lies.',cost:{'old coin':2,'electronics bits':4,'wire spool':3}}
    ];

    const MARKET_STOCK=[
      {id:'pocket pack',cost:26,tag:'Backpack'},
      {id:'scout daypack',cost:38,tag:'Backpack'},
      {id:'expedition frame pack',cost:68,tag:'Backpack'},
      {id:'jury-rigged blade',cost:18,tag:'Weapon'},
      {id:'scrap spear',cost:32,tag:'Weapon'},
      {id:'pipe rifle',cost:70,tag:'Weapon'},
      {id:'arc pistol',cost:82,tag:'Weapon'},
      {id:'compact medkit',cost:30,tag:'Medical'},
      {id:'filtered water pack',cost:28,tag:'Hydration'},
      {id:'morale patch',cost:16,tag:'Morale'},
      {id:'spare filter',cost:24,tag:'Gear mod'},
      {id:'coil battery',cost:26,tag:'Gear mod'},
      {id:'bunker schematics',cost:44,tag:'Route intel'}
    ];

    const dom={
      introModal:document.getElementById('introModal'),
      introTitle:document.getElementById('introTitle'),
      introMessage:document.getElementById('introMessage'),
      introActions:document.getElementById('introActions'),
      stats:document.getElementById('stats'),
      meta:document.getElementById('meta'),
      excursionStatus:document.getElementById('excursionStatus'),
      tempoHint:document.getElementById('tempoHint'),
      doors:document.getElementById('doors'),
      doorsHint:document.getElementById('doorsHint'),
      zoneTitle:document.getElementById('zoneTitle'),
      zoneDesc:document.getElementById('zoneDesc'),
      zoneBadge:document.getElementById('zoneBadge'),
      raidActions:document.getElementById('raidActions'),
      inventory:document.getElementById('inventory'),
      equipment:document.getElementById('equipment'),
      crafting:document.getElementById('crafting'),
      backpackCount:document.getElementById('backpackCount'),
      loadoutCount:document.getElementById('loadoutCount'),
      codex:document.getElementById('codex'),
      idleOps:document.getElementById('idleOps'),
      hubLock:document.getElementById('hubLock'),
      screenNav:document.getElementById('screenNav'),
      screens:{
        main:document.getElementById('screen-main'),
        locations:document.getElementById('screen-locations'),
        mission:document.getElementById('screen-mission')
      },
      screenButtons:Array.from(document.querySelectorAll('#screenNav button')),
      enterLocations:document.getElementById('enterLocations'),
      returnMain:document.getElementById('returnMain'),
      travelStatus:document.getElementById('travelStatus'),
      missionTitle:document.getElementById('missionTitle'),
      missionMeta:document.getElementById('missionMeta'),
      missionProgress:document.getElementById('missionProgress'),
      missionLog:document.getElementById('missionLog'),
      missionActions:document.getElementById('missionActions'),
      missionRewardsCard:document.getElementById('missionRewardsCard'),
      missionRewardDetail:document.getElementById('missionRewardDetail'),
      missionRewardActions:document.getElementById('missionRewardActions'),
      missionRewardList:document.getElementById('missionRewardList'),
      stash:document.getElementById('stash'),
      stashActions:document.getElementById('stashActions'),
      stashDetail:document.getElementById('stashDetail'),
      stashItemActions:document.getElementById('stashItemActions'),
      stashCount:document.getElementById('stashCount'),
      stashTitle:document.getElementById('stashTitle'),
      stashSubtitle:document.getElementById('stashSubtitle'),
      marketInventory:document.getElementById('marketInventory'),
      marketHint:document.getElementById('marketHint'),
      itemDetail:document.getElementById('itemDetail'),
      itemActions:document.getElementById('itemActions'),
      inventoryNav:Array.from(document.querySelectorAll('#inventoryNav button')),
      inventoryScreens:{
        backpack:document.getElementById('inventoryBackpack'),
        loadout:document.getElementById('inventoryLoadout'),
        crafting:document.getElementById('inventoryCrafting')
      },
      stashNav:Array.from(document.querySelectorAll('#stashNav button')),
      stashScreens:{
        vault:document.getElementById('stashVault')
      },
      tabs:document.querySelector('.tabs'),
      tabButtons:Array.from(document.querySelectorAll('.tab-buttons button')),
      tabContents:{
        hub:document.getElementById('tab-hub'),
        inventory:document.getElementById('tab-inventory'),
        field:document.getElementById('tab-field')
      }
    };

    let activeTab='hub';

    /* ================= UTILITIES ================= */
    const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
    const pct=(v,max)=>Math.round((v/max)*100);
    const NORMAL_BODY_TEMP=98;
    const BODY_TEMP_MIN=70;
    const BODY_TEMP_MAX=104;
    const moveToward=(value,target,amount)=>{
      if(value<target) return Math.min(target,value+amount);
      if(value>target) return Math.max(target,value-amount);
      return value;
    };
    const fmtTime=(mins)=>{
      const m=mins%60;const h=Math.floor(mins/60)%24;const suffix=h>=12?"PM":"AM";
      const hour=((h+11)%12+1);return `${hour}:${m.toString().padStart(2,'0')} ${suffix}`;
    }
    const setCodex=(msg)=>{ state.codex=[msg]; };
    const canAccessVault=()=>state.zone.id==='safehouse' && !state.mission.active && !state.travel.active;
    const canAccessMarket=()=>state.marketAccess.active && state.marketAccess.zoneId===state.zone.id && !state.mission.active && !state.travel.active;
    const isHubZone=(zone=state.zone)=>{
      if(!zone) return false;
      const name=(zone.name||'').toLowerCase();
      return zone.id==='safehouse' || zone.id==='drift-yard' || name.includes('safehouse') || name.includes('hub') || name.includes('drift yard');
    };
    const isMarketZone=(zone=state.zone)=>{
      if(!zone) return false;
      return zone.id==='town' || (zone.name||'').toLowerCase().includes('market');
    };
    const ensureZoneScene=(zone=state.zone)=>{
      const exp=expansions[zone.id];
      if(!exp) return null;
      const availableSceneId=zone.sceneId || exp.door?.target || Object.keys(exp.scenes || {})[0];
      if(availableSceneId && zone.sceneId!==availableSceneId){
        zone.sceneId=availableSceneId;
      }
      if(!availableSceneId) return null;
      const scene=exp.scenes?.[availableSceneId];
      return scene ? {id:availableSceneId,...scene} : null;
    };
    const clearMarketAccess=()=>{
      if(state.marketAccess.active){
        state.marketAccess={active:false,zoneId:null};
      }
    };
    const vaultBlockedMessage='Return to the Cold Shelter hatch to access the vault.';
    const logMsg=(msg)=>{
      const stamp=`[Day ${state.day} // ${fmtTime(state.timeMinutes)}] ${msg}`;
      if(state.mission.active && !state.mission.completed){
        state.mission.statusMessage=stamp;
        state.mission.summary=stamp;
        renderMissionStatus();
        return;
      }
      if(state.idleOps.active && !state.idleOps.completed){
        state.idleOps.statusMessage=stamp;
        renderIdleOps();
        return;
      }
      setCodex(msg);
    }
    let travelResolveTimer=null;
    const scheduleTravelResolution=()=>{
      if(travelResolveTimer){
        clearTimeout(travelResolveTimer);
        travelResolveTimer=null;
      }
      if(!state.travel.active) return;
      const endsAt=Number(state.travel.endsAt);
      if(!Number.isFinite(endsAt)) return;
      const delay=Math.max(0,endsAt-Date.now())+60;
      travelResolveTimer=setTimeout(()=>{
        if(state.travel.active){
          renderTravelStatus();
        }
      },delay);
    };

    const GRID_PAGE_SIZE=18;
    const STACK_LIMIT=25;
    const STACKABLE_CHUNK_RANGE={min:5,max:20};
    const STACKABLE_ITEMS=new Set(['scrap bundle','wire spool','cloth scraps','plastic shards','electronics bits','scrap wiring','copper wire']);
    const isStackable=(id)=>STACKABLE_ITEMS.has(id);
    const getItemCount=(arr,id)=>arr.reduce((acc,item)=>acc+(item===id?1:0),0);
    const slotUsageFor=(id,count)=>isStackable(id)?Math.ceil(count/STACK_LIMIT):count;
    const getSlotUsage=(arr)=>{
      const tally={};
      arr.forEach(item=>{tally[item]=(tally[item]||0)+1;});
      return Object.entries(tally).reduce((total,[id,count])=>total+slotUsageFor(id,count),0);
    };
    const hasCapacityFor=(arr,limit,id,count=1)=>{
      const currentSlots=getSlotUsage(arr);
      const existingCount=getItemCount(arr,id);
      const currentItemSlots=slotUsageFor(id,existingCount);
      const nextItemSlots=slotUsageFor(id,existingCount+count);
      const projected=currentSlots-currentItemSlots+nextItemSlots;
      return projected<=limit;
    };
    const removeItem=(arr,item)=>{const idx=arr.indexOf(item); if(idx>=0) arr.splice(idx,1);};
    const removeItems=(arr,item,count)=>{
      for(let i=0;i<count;i++){
        const idx=arr.indexOf(item);
        if(idx<0) return i===count;
        arr.splice(idx,1);
      }
      return true;
    };
    const addItemCopies=(arr,item,count=1)=>{for(let i=0;i<count;i++) arr.push(item);};
    const routeItemGain=(item)=>{
      if(hasCapacityFor(state.inventory,getBackpackLimit(),item,1)){
        state.inventory.push(item);
        return 'inventory';
      }
      if(canAccessVault() && hasCapacityFor(state.stash.items,state.stashLimit,item,1)){
        state.stash.items.push(item);
        return 'vault';
      }
      return 'lost';
    };
    const getItem=(id)=>ITEM_CATALOG[id] || {type:'junk',rarity:'common',value:1};
    const formatMods=(mods)=>{
      if(!mods) return [];
      return Object.entries(mods).map(([key,val])=>{
        const label=key.replace(/([A-Z])/g,' $1').toLowerCase();
        const sign=val>0?'+':'';
        return `${label} ${sign}${val}`;
      });
    };
    const rarityLabel=(rarity)=>rarity ? `${rarity[0].toUpperCase()}${rarity.slice(1)}` : '';
    const formatEffects=(effect)=>{
      if(!effect) return [];
      const labels={temp:'body temp',backpack:'backpack slots'};
      return effect.split(',').map(token=>token.trim()).filter(Boolean).map(token=>{
        if(token.startsWith('item:')) return `Adds item: ${token.slice(5).trim()}`;
        if(token.startsWith('note:')) return token.slice(5).trim();
        if(token.startsWith('log:')) return token.slice(4).trim();
        if(token.startsWith('flag:')) return `Flags ${token.slice(5).trim()}`;
        const match=token.match(/([a-zA-Z]+)([+-]\d+)/);
        if(match){
          const stat=match[1];
          const delta=match[2];
          const label=labels[stat] || stat;
          return `${label} ${delta}`;
        }
        return token;
      });
    };
    const groupItems=(items)=>{
      const tally=items.reduce((acc,item)=>{
        acc[item]=(acc[item]||0)+1;
        return acc;
      },{});
      return Object.entries(tally).map(([id,count])=>({id,count,data:getItem(id)}));
    };
    const rollLootItem=(risk,bonus=0)=>{
      const roll=Math.random();
      const bias={
        low:{common:0.7,uncommon:0.22,rare:0.07,epic:0.009,legendary:0.001},
        medium:{common:0.55,uncommon:0.28,rare:0.13,epic:0.035,legendary:0.005},
        high:{common:0.4,uncommon:0.3,rare:0.18,epic:0.09,legendary:0.03},
        deadly:{common:0.3,uncommon:0.28,rare:0.2,epic:0.14,legendary:0.08}
      };
      const dist=bias[risk] || bias.low;
      const adjusted={
        common:Math.max(0.05,dist.common-(bonus*0.5)),
        uncommon:dist.uncommon+(bonus*0.2),
        rare:dist.rare+(bonus*0.2),
        epic:dist.epic+(bonus*0.08),
        legendary:dist.legendary+(bonus*0.02)
      };
      const rollTable=[
        ['common',adjusted.common],
        ['uncommon',adjusted.uncommon],
        ['rare',adjusted.rare],
        ['epic',adjusted.epic],
        ['legendary',adjusted.legendary]
      ];
      let cursor=0;
      for(const [rarity,weight] of rollTable){
        cursor+=weight;
        if(roll<=cursor){
          const pool=LOOT_BY_RARITY[rarity];
          return pool[Math.floor(Math.random()*pool.length)];
        }
      }
      return 'scrap wiring';
    };
    const rollStackableChunk=()=>STACKABLE_CHUNK_RANGE.min+Math.floor(Math.random()*(STACKABLE_CHUNK_RANGE.max-STACKABLE_CHUNK_RANGE.min+1));
    const rollLootDrop=(risk,bonus=0)=>{
      const id=rollLootItem(risk,bonus);
      const count=isStackable(id)?rollStackableChunk():1;
      return {id,count};
    };
    const getGearMods=(excludeItem)=>{
      return state.equipped.reduce((acc,item)=>{
        if(excludeItem && item===excludeItem) return acc;
        const mod=getItem(item).mods;
        if(!mod) return acc;
        Object.entries(mod).forEach(([key,val])=>{
          acc[key]=(acc[key]||0)+val;
        });
        return acc;
      },{});
    };
    const getBackpackLimit=(excludeItem)=>state.backpackLimit+(getGearMods(excludeItem).carryBonus||0);
    const getBackpackUsage=()=>getSlotUsage(state.inventory);
    const getStashUsage=()=>getSlotUsage(state.stash.items);
    const canUnequipItem=(item)=>hasCapacityFor(state.inventory,getBackpackLimit(item),item,1);
    const XP_BASE=80;
    const XP_GROWTH=20;
    const xpToNextLevel=(level)=>XP_BASE+(XP_GROWTH*(level-1));
    const EQUIPMENT_SLOTS={
      backpack:1,
      gloves:1,
      helmet:1,
      eyewear:1,
      pants:1,
      shoes:1,
      chest:1,
      weapon:2,
      tool:3
    };
    const EQUIPMENT_SLOT_LABELS={
      backpack:'Backpack',
      gloves:'Gloves',
      helmet:'Helmet',
      eyewear:'Eyewear',
      pants:'Pants',
      shoes:'Shoes',
      chest:'Chest',
      weapon:'Weapon',
      tool:'Tool'
    };
    const getEquipmentSlotUsage=()=>{
      const usage=Object.keys(EQUIPMENT_SLOTS).reduce((acc,key)=>{acc[key]=0;return acc;},{});
      state.equipped.forEach(item=>{
        const slot=getItem(item).slot;
        if(slot && usage.hasOwnProperty(slot)){
          usage[slot]+=1;
        }
      });
      return usage;
    };
    const getEquipmentUsageCount=()=>{
      const usage=getEquipmentSlotUsage();
      return Object.values(usage).reduce((sum,val)=>sum+val,0);
    };
    const getEquipmentSlotTotal=()=>Object.values(EQUIPMENT_SLOTS).reduce((sum,val)=>sum+val,0);
    const slotLabel=(slot)=>EQUIPMENT_SLOT_LABELS[slot] || slot;
    const canEquipItem=(item)=>{
      const data=getItem(item);
      if(!data.slot) return {ok:false,reason:'This item cannot be equipped.'};
      const usage=getEquipmentSlotUsage();
      const limit=EQUIPMENT_SLOTS[data.slot] || 0;
      if((usage[data.slot]||0) >= limit){
        return {ok:false,reason:`${slotLabel(data.slot)} slot full.`};
      }
      return {ok:true,reason:''};
    };
    function awardXp(amount,sourceLabel){
      if(amount<=0) return;
      state.xp+=amount;
      let leveled=false;
      while(state.xp>=state.nextLevelXp){
        state.xp-=state.nextLevelXp;
        state.level+=1;
        state.maxHp+=6;
        state.maxStamina+=4;
        state.maxMorale+=3;
        state.nextLevelXp=xpToNextLevel(state.level);
        state.hp=clamp(state.hp+10,0,state.maxHp);
        state.stamina=clamp(state.stamina+8,0,state.maxStamina);
        state.morale=clamp(state.morale+6,0,state.maxMorale);
        leveled=true;
      }
      if(leveled){
        logMsg(`Level up! You are now level ${state.level}.`);
      }else if(sourceLabel){
        logMsg(`+${amount} XP from ${sourceLabel}.`);
      }
    }
    const STASH_UPGRADE_STEP=6;
    const STASH_UPGRADE_BASE_COST={credits:32,scrap:4};
    const STASH_UPGRADE_GROWTH={credits:24,scrap:3};
    const getStashUpgradeCost=()=>{
      const level=state.stashUpgradeLevel;
      return {
        credits:STASH_UPGRADE_BASE_COST.credits+(STASH_UPGRADE_GROWTH.credits*level),
        scrap:STASH_UPGRADE_BASE_COST.scrap+(STASH_UPGRADE_GROWTH.scrap*level)
      };
    };
    const upgradeStash=()=>{
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      const cost=getStashUpgradeCost();
      if(!canAfford(cost)){
        setCodex('Not enough resources to expand the stash.');
        return;
      }
      applyCost(cost);
      state.stashLimit+=STASH_UPGRADE_STEP;
      state.stashUpgradeLevel+=1;
      setCodex(`Vault expanded by ${STASH_UPGRADE_STEP} slots.`);
      logMsg(`Vault expansion complete. Capacity now ${state.stashLimit}.`);
      renderAll();
    };
    const formatCost=(cost)=>Object.entries(cost).map(([k,v])=>`${v} ${k}`).join(' · ');
    const canAfford=(cost)=>Object.entries(cost).every(([k,v])=>state[k]>=v);
    const applyCost=(cost)=>{
      Object.entries(cost).forEach(([k,v])=>{
        state[k]=Math.max(0,state[k]-v);
      });
    };
    const addToArray=(arr,item)=>{arr.push(item);};
    function equipItem(item){
      if(state.equipped.includes(item)) return;
      const data=getItem(item);
      const check=canEquipItem(item);
      if(!check.ok){
        setCodex(check.reason || 'No open slots for that item.');
        return;
      }
      removeItem(state.inventory,item);
      state.equipped.push(item);
      state.selected={source:'equipped',item};
      setCodex(`${item} equipped.`);
      logMsg(`Equipped ${item}.`);
      renderAll();
    }
    function unequipItem(item){
      if(!canUnequipItem(item)){
        setCodex('Backpack full. Make space before unequipping.');
        return;
      }
      removeItem(state.equipped,item);
      state.inventory.push(item);
      state.selected={source:'inventory',item};
      setCodex(`${item} stowed.`);
      logMsg(`Unequipped ${item}.`);
      renderAll();
    }
    function consumeItem(item){
      const data=getItem(item);
      if(data.type!=='consumable'){
        setCodex('That item cannot be used like a consumable.');
        return;
      }
      if(data.effect){
        applyEffects(data.effect,'success');
      }
      removeItem(state.inventory,item);
      state.selected={source:null,item:null};
      logMsg(`Consumed ${item}.`);
      setCodex(`${item} used.`);
      renderAll();
    }
    function stashItem(item){
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      if(!hasCapacityFor(state.stash.items,state.stashLimit,item,1)){
        setCodex('Stash is full.');
        return;
      }
      removeItem(state.inventory,item);
      state.stash.items.push(item);
      state.selected={source:'stash',item};
      setCodex(`${item} stored in ${state.stash.name}.`);
      logMsg(`Stored ${item} in ${state.stash.name}.`);
      renderAll();
    }
    function unstashItem(item){
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      if(!hasCapacityFor(state.inventory,getBackpackLimit(),item,1)){
        setCodex('Backpack full.');
        return;
      }
      removeItem(state.stash.items,item);
      state.inventory.push(item);
      state.selected={source:'inventory',item};
      setCodex(`${item} withdrawn from ${state.stash.name}.`);
      logMsg(`Retrieved ${item} from ${state.stash.name}.`);
      renderAll();
    }
    function sellItem(item){
      if(!canAccessMarket()){
        setCodex('Visit a shop to sell items.');
        return;
      }
      const data=getItem(item);
      removeItem(state.inventory,item);
      state.credits+=data.value || 1;
      state.selected={source:null,item:null};
      logMsg(`Sold ${item} for ${data.value || 1} credits.`);
      renderAll();
    }
    function dismantleItem(item){
      const data=getItem(item);
      removeItem(state.inventory,item);
      const salvage=data.salvage || Math.max(1,Math.floor((data.value || 1)/2));
      state.scrap+=salvage;
      state.selected={source:null,item:null};
      logMsg(`Dismantled ${item} for ${salvage} scrap.`);
      renderAll();
    }

    function resetIdleOpsState(){
      state.idleOps={active:false,id:null,startedAt:null,durationMs:0,etaMinutes:0,completed:false,statusMessage:'',rewards:[]};
    }
    function closeIdleOp(){
      resetIdleOpsState();
      state.selected={source:null,item:null};
      setCodex('Idle operation closed. Ready for another dispatch.');
      renderAll();
    }

    function startIdleOp(opId){
      if(state.idleOps.active){
        setCodex('An idle operation is already underway.');
        return;
      }
      if(state.idleOps.completed){
        if((state.idleOps.rewards?.length||0)>0){
          setCodex('Resolve idle rewards before dispatching a new operation.');
          return;
        }
        resetIdleOpsState();
      }
      const op=idleOperations.find(entry=>entry.id===opId);
      if(!op) return;
      if(!canAfford(op.cost)){
        setCodex('Insufficient resources for this operation.');
        return;
      }
      applyCost(op.cost);
      const gearMods=getGearMods();
      const duration=getIdleDurationMinutes(op,gearMods);
      state.idleOps={
        active:true,
        id:opId,
        startedAt:Date.now(),
        durationMs:duration*60000,
        etaMinutes:duration,
        completed:false,
        statusMessage:`Idle op launched: ${op.label}.`,
        rewards:[]
      };
      logMsg(`Idle op launched: ${op.label}. ETA ${formatMinutesPrecise(duration)}.`);
      renderAll();
    }

    function completeIdleOp(){
      const op=idleOperations.find(entry=>entry.id===state.idleOps.id);
      if(!op) return;
      const rewards=[];
      applyEffects(op.reward,'success',{deferItemsTo:rewards});
      state.idleOps={
        active:false,
        id:op.id,
        startedAt:null,
        durationMs:0,
        etaMinutes:0,
        completed:true,
        statusMessage:`Idle op complete: ${op.label}. Rewards ready.`,
        rewards
      };
      state.selected={source:null,item:null};
      setCodex('Idle operation complete. Review rewards.');
      renderAll();
    }

    /* ================= RENDERING ================= */
    function renderBars(){
      const rows=[
        ['HP','hp','maxHp','hp'],
        ['Stamina','stamina','maxStamina','stamina'],
        ['Morale','morale','maxMorale','morale'],
        ['Energy','energy','maxEnergy','stamina'],
        ['Hunger','hunger','maxHunger','hunger'],
        ['Hydration','thirst','maxThirst','thirst'],
        ['Radiation','rads',100,'rads'],
        ['Body Temp','bodyTemp','maxBodyTemp','temp']
      ];
      dom.stats.innerHTML=rows.map(([label,key,maxKey,cls])=>{
        const val=state[key];const max=(typeof maxKey==='string')?state[maxKey]:maxKey;
        const percent=clamp(pct(val,max),0,200);
        return `<div class="statline"><div>${label}</div><div class="bar ${cls}"><span style="width:${percent}%;"></span></div><div>${Math.round(val)}/${max}</div></div>`;
      }).join('');
    dom.meta.innerHTML=`<span class="pill-inline"><b>Credits</b>${state.credits}</span>`+
        `<span class="pill-inline"><b>Scrap</b>${state.scrap}</span>`+
        `<span class="pill-inline"><b>Keys</b>${state.keys}</span>`+
        `<span class="pill-inline"><b>Level</b>${state.level}</span>`+
        `<span class="pill-inline"><b>XP</b>${state.xp}/${state.nextLevelXp}</span>`+
        `<span class="pill-inline"><b>Time</b>${fmtTime(state.timeMinutes)}</span>`+
        `<span class="pill-inline"><b>Day</b>${state.day}</span>`+
        `<span class="pill-inline"><b>Backpack</b>${getBackpackUsage()}/${getBackpackLimit()}</span>`;
    }

    const rewardSources={
      mission:{
        key:'missionReward',
        getItems:()=>state.mission.rewards || [],
        clear:()=>{ state.mission.rewards=[]; }
      },
      idle:{
        key:'idleReward',
        getItems:()=>state.idleOps.rewards || [],
        clear:()=>{ state.idleOps.rewards=[]; }
      }
    };
    const getRewardConfig=(source)=>Object.values(rewardSources).find(cfg=>cfg.key===source) || null;
    const rewardHasItem=(source,item)=>{
      const cfg=getRewardConfig(source);
      if(!cfg) return false;
      return cfg.getItems().includes(item);
    };
    const removeRewardItem=(source,item)=>{
      const cfg=getRewardConfig(source);
      if(!cfg) return false;
      const bucket=cfg.getItems();
      const idx=bucket.indexOf(item);
      if(idx<0) return false;
      bucket.splice(idx,1);
      return true;
    };
    const salvageValue=(item)=>{
      const data=getItem(item);
      return data.salvage || Math.max(1,Math.floor((data.value || 1)/2));
    };
    const isMissionResolved=()=>state.mission.active && state.mission.completed && (state.mission.rewards?.length||0)===0;
    function autoCloseMissionIfResolved(){
      if(isMissionResolved()){
        closeMission({auto:true});
      }
    }
    function claimRewardToInventory(source,item){
      if(!hasCapacityFor(state.inventory,getBackpackLimit(),item,1)){
        setCodex('Backpack full. Make room first.');
        return;
      }
      if(!removeRewardItem(source,item)) return;
      state.inventory.push(item);
      state.selected={source:'inventory',item};
      setCodex(`${item} packed into your backpack.`);
      autoCloseMissionIfResolved();
      renderAll();
    }
    function claimRewardToVault(source,item){
      if(source==='missionReward'){
        setCodex('Mission rewards can only be packed, equipped, scrapped, or left behind.');
        return;
      }
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      if(!hasCapacityFor(state.stash.items,state.stashLimit,item,1)){
        setCodex('Stash full. Sell or scrap to clear space.');
        return;
      }
      if(!removeRewardItem(source,item)) return;
      state.stash.items.push(item);
      state.selected={source:'stash',item};
      setCodex(`${item} routed into the vault.`);
      renderAll();
    }
    function equipRewardItem(source,item){
      const data=getItem(item);
      const check=canEquipItem(item);
      if(!check.ok){
        setCodex(check.reason || 'No open slots for that item.');
        return;
      }
      if(!removeRewardItem(source,item)) return;
      state.equipped.push(item);
      state.selected={source:'equipped',item};
      setCodex(`${item} equipped from rewards.`);
      autoCloseMissionIfResolved();
      renderAll();
    }
    function scrapRewardItem(source,item){
      if(!removeRewardItem(source,item)) return;
      const salvage=salvageValue(item);
      state.scrap+=salvage;
      state.selected={source:null,item:null};
      setCodex(`${item} scrapped for ${salvage} scrap.`);
      autoCloseMissionIfResolved();
      renderAll();
    }
    function leaveRewardItem(source,item){
      if(!removeRewardItem(source,item)) return;
      state.selected={source:null,item:null};
      setCodex(`${item} left behind.`);
      autoCloseMissionIfResolved();
      renderAll();
    }
    function clearRewardSource(source){
      const cfg=getRewardConfig(source);
      if(!cfg) return;
      cfg.clear();
      state.selected={source:null,item:null};
      setCodex(source==='missionReward' ? 'Mission rewards left behind.' : 'Idle rewards dismissed.');
      autoCloseMissionIfResolved();
      renderAll();
    }

    const hasCraftingMaterials=(recipe)=>Object.entries(recipe.cost).every(([id,count])=>getItemCount(state.inventory,id)>=count);
    const craftingCostLabel=(recipe)=>Object.entries(recipe.cost).map(([id,count])=>`${count} ${id}`).join(' · ');
    function craftRecipe(recipeId){
      const recipe=CRAFTING_RECIPES.find(entry=>entry.id===recipeId);
      if(!recipe) return;
      if(!hasCraftingMaterials(recipe)) {
        setCodex('Missing crafting materials.');
        return;
      }
      if(!hasCapacityFor(state.inventory,getBackpackLimit(),recipe.id,1)){
        setCodex('Backpack capacity reached. Crafting would overflow.');
        return;
      }
      Object.entries(recipe.cost).forEach(([id,count])=>removeItems(state.inventory,id,count));
      state.inventory.push(recipe.id);
      state.selected={source:'inventory',item:recipe.id};
      logMsg(`Crafted ${recipe.label} from salvage.`);
      renderAll();
    }

    function buyMarketItem(itemId){
      const stock=MARKET_STOCK.find(entry=>entry.id===itemId);
      if(!stock) return;
      if(!canAccessMarket()){
        setCodex('Visit a shop to buy items.');
        return;
      }
      if(state.credits<stock.cost){
        setCodex('Not enough credits for this purchase.');
        return;
      }
      if(!hasCapacityFor(state.inventory,getBackpackLimit(),itemId,1)){
        setCodex('Backpack full. Make room before purchasing.');
        return;
      }
      state.credits-=stock.cost;
      state.inventory.push(itemId);
      state.selected={source:'inventory',item:itemId};
      logMsg(`Purchased ${itemId} for ${stock.cost} credits.`);
      renderAll();
    }

    function buildItemRow({id,count,data,source}){
      const row=document.createElement('div');
      row.className='item-row selectable';
      if(state.selected.source===source && state.selected.item===id){
        row.classList.add('selected');
      }
      row.onclick=()=>selectItem(source,id);
      const name=document.createElement('div');
      name.className='item-name';
      name.textContent=`${id} ×${count}`;
      const meta=document.createElement('div');
      meta.className='item-meta';
      const slotTag=data.slot ? `${slotLabel(data.slot)} · ` : '';
      meta.textContent=`${data.type} · ${slotTag}${data.value || 1} cr`;
      const chip=document.createElement('span');
      chip.className=`chip ${data.rarity}`;
      chip.textContent=data.rarity;
      row.appendChild(name);
      row.appendChild(chip);
      row.appendChild(meta);
      return row;
    }

    function buildItemTile({id,count,data,source}){
      const tile=document.createElement('button');
      tile.type='button';
      tile.className='icon-tile';
      if(state.selected.source===source && state.selected.item===id){
        tile.classList.add('selected');
      }
      tile.onclick=()=>selectItem(source,id);
      tile.title=`${id} ×${count}`;
      const name=document.createElement('div');
      name.className='icon-name';
      name.textContent=id;
      const meta=document.createElement('div');
      meta.className='icon-meta';
      const metaParts=[];
      if(data.slot) metaParts.push(slotLabel(data.slot));
      metaParts.push(rarityLabel(data.rarity) || data.type);
      meta.textContent=metaParts.filter(Boolean).join(' · ');
      const countEl=document.createElement('div');
      countEl.className='icon-count';
      countEl.textContent=`×${count}`;
      tile.appendChild(name);
      tile.appendChild(meta);
      tile.appendChild(countEl);
      return tile;
    }

    function buildEmptySlotTile(label){
      const tile=document.createElement('button');
      tile.type='button';
      tile.disabled=true;
      tile.className='icon-tile empty';
      const name=document.createElement('div');
      name.className='icon-name';
      name.textContent=label;
      const meta=document.createElement('div');
      meta.className='icon-meta';
      meta.textContent='Empty slot';
      tile.appendChild(name);
      tile.appendChild(meta);
      return tile;
    }

    function paginateEntries(entries,pageKey,pageSize){
      const totalPages=Math.max(1,Math.ceil(entries.length/pageSize));
      const safePage=clamp(state[pageKey] || 0,0,totalPages-1);
      state[pageKey]=safePage;
      const start=safePage*pageSize;
      return {entries:entries.slice(start,start+pageSize),page:safePage,totalPages};
    }

    function renderPager({page,totalPages,onPrev,onNext,label}){
      if(totalPages<=1) return null;
      const pager=document.createElement('div');
      pager.className='icon-pager';
      const prev=document.createElement('button');
      prev.textContent=label ? `Prev ${label}` : 'Prev';
      prev.disabled=page<=0;
      prev.onclick=onPrev;
      const info=document.createElement('div');
      info.className='page-info';
      info.textContent=`Page ${page+1} of ${totalPages}`;
      const next=document.createElement('button');
      next.textContent=label ? `Next ${label}` : 'Next';
      next.disabled=page>=totalPages-1;
      next.onclick=onNext;
      pager.appendChild(prev);
      pager.appendChild(info);
      pager.appendChild(next);
      return pager;
    }

    function renderItemDetails(){
      let {source,item}=state.selected;
      const sourceHasItem=()=>{
        if(!source || !item) return false;
        if(source==='inventory') return state.inventory.includes(item);
        if(source==='equipped') return state.equipped.includes(item);
        if(source==='stash') return state.stash.items.includes(item);
        if(source==='missionReward' || source==='idleReward') return rewardHasItem(source,item);
        return false;
      };
      if(source && item && !sourceHasItem()){
        state.selected={source:null,item:null};
        source=null;
        item=null;
      }
      const data=item?getItem(item):null;
      const vaultAccess=canAccessVault();
      const marketActive=canAccessMarket();
      const missionRewardsReady=state.mission.active && state.mission.completed && (state.mission.rewards?.length||0)>0;
      const missionRewardDefault=missionRewardsReady
        ? 'Use the inline pack/equip buttons on each reward for faster routing.'
        : 'Complete a mission to review rewards.';
      const targets=[
        {detail:dom.itemDetail,actions:dom.itemActions,default:'Select gear to view stats, uses, and actions.'},
        {detail:dom.stashDetail,actions:dom.stashItemActions,default:'Select stash items to transfer, scrap, or sell.'},
        {detail:dom.missionRewardDetail,actions:dom.missionRewardActions,default:missionRewardDefault}
      ];
      targets.forEach(target=>{
        if(!target.detail || !target.actions) return;
        if(!item || !data){
          target.detail.innerHTML=`<div class="command-hint">${target.default}</div>`;
        }else{
          const mods=formatMods(data.mods);
          const effects=formatEffects(data.effect);
          const uses=[];
          if(data.type==='consumable') uses.push('Consume for field boost.');
          if(data.slot) uses.push('Equip to gain passive bonuses.');
          if(data.type==='junk') uses.push('Break down for scrap.');
          if(data.type==='key') uses.push('Unlocks lockbox raids.');
          target.detail.innerHTML=`
            <div class="command-title">${item}</div>
            <div class="stat-list">
              <div>Type</div><span>${data.type}</span>
              <div>Rarity</div><span>${data.rarity}</span>
              <div>Value</div><span>${data.value || 1} credits</span>
              ${data.slot ? `<div>Slot</div><span>${slotLabel(data.slot)}</span>` : ''}
              ${data.salvage ? `<div>Salvage</div><span>${data.salvage} scrap</span>` : ''}
            </div>
            ${uses.length ? `<div class="small">${uses.join(' ')}</div>` : ''}
            ${effects.length ? `<div class="small"><b>Effects:</b> ${effects.join(' · ')}</div>` : ''}
            ${mods.length ? `<div class="small"><b>Mods:</b> ${mods.join(' · ')}</div>` : ''}
          `;
        }
        target.actions.innerHTML='';
      });
      if(!item || !data) return;

      const actionConfigs=[];
      if(source==='inventory'){
        if(data.slot){
          const check=canEquipItem(item);
          actionConfigs.push({
            label:'Deploy to loadout',
            action:()=>equipItem(item),
            disabled:!check.ok,
            blockedHint:check.ok ? '' : check.reason
          });
        }
        if(data.type==='consumable'){
          actionConfigs.push({label:'Use item',action:()=>consumeItem(item)});
        }
        if(vaultAccess){
          actionConfigs.push({
            label:'Route to vault',
            action:()=>stashItem(item),
            disabled:!hasCapacityFor(state.stash.items,state.stashLimit,item,1),
            blockedHint:''
          });
        }
        actionConfigs.push({label:'Break down for scrap',action:()=>dismantleItem(item)});
        if(marketActive){
          actionConfigs.push({label:'Sell to market',action:()=>sellItem(item)});
        }
      }else if(source==='equipped'){
        actionConfigs.push({label:'Return to backpack',action:()=>unequipItem(item),disabled:!canUnequipItem(item)});
      }else if(source==='stash'){
        actionConfigs.push({
          label:'Withdraw to backpack',
          action:()=>unstashItem(item),
          disabled:!vaultAccess || !hasCapacityFor(state.inventory,getBackpackLimit(),item,1),
          blockedHint:!vaultAccess ? vaultBlockedMessage : ''
        });
        actionConfigs.push({
          label:'Break down for scrap',
          action:()=>scrapStashItem(item),
          disabled:!vaultAccess,
          blockedHint:!vaultAccess ? vaultBlockedMessage : ''
        });
        if(marketActive && vaultAccess){
          actionConfigs.push({
            label:'Sell to market',
            action:()=>sellStashItem(item)
          });
        }
      }else if(source==='missionReward' && missionRewardsReady){
        actionConfigs.push({label:'Pack into backpack',action:()=>claimRewardToInventory(source,item),disabled:!hasCapacityFor(state.inventory,getBackpackLimit(),item,1)});
        if(data.slot){
          const check=canEquipItem(item);
          actionConfigs.push({label:'Equip now',action:()=>equipRewardItem(source,item),disabled:!check.ok,blockedHint:check.reason});
        }
        actionConfigs.push({label:`Scrap for ${salvageValue(item)}`,action:()=>scrapRewardItem(source,item)});
        actionConfigs.push({label:'Leave item',action:()=>leaveRewardItem(source,item)});
      }
      targets.forEach(target=>{
        if(!target.actions) return;
        actionConfigs.forEach(cfg=>{
          const btn=document.createElement('button');
          btn.textContent=cfg.label;
          if(cfg.disabled){
            btn.disabled=true;
            if(cfg.blockedHint){
              btn.title=cfg.blockedHint;
            }
          }
          btn.onclick=cfg.action;
          target.actions.appendChild(btn);
        });
        if(!actionConfigs.length){
          const msg=document.createElement('div');
          msg.className='command-hint';
          msg.textContent='No actions available.';
          target.actions.appendChild(msg);
        }
      });
    }

    function renderInventory(){
      dom.inventory.innerHTML='';
      dom.equipment.innerHTML='';
      if(!state.inventory.length){
        const empty=document.createElement('div');
        empty.className='muted-box';
        empty.textContent='Backpack empty. Run raids to pull more loot.';
        dom.inventory.appendChild(empty);
      }else{
        const grid=document.createElement('div');
        grid.className='icon-grid';
        const grouped=groupItems(state.inventory);
        const {entries,page,totalPages}=paginateEntries(grouped,'inventoryPage',GRID_PAGE_SIZE);
        entries.forEach(({id,count,data})=>{
          grid.appendChild(buildItemTile({id,count,data,source:'inventory'}));
        });
        dom.inventory.appendChild(grid);
        const pager=renderPager({
          page,
          totalPages,
          label:'items',
          onPrev:()=>{state.inventoryPage=Math.max(0,page-1); renderInventory();},
          onNext:()=>{state.inventoryPage=Math.min(totalPages-1,page+1); renderInventory();}
        });
        if(pager) dom.inventory.appendChild(pager);
      }
      const equipmentGrid=document.createElement('div');
      equipmentGrid.className='icon-grid';
      const equippedBySlot=Object.keys(EQUIPMENT_SLOTS).reduce((acc,key)=>{acc[key]=[];return acc;},{});
      state.equipped.forEach(item=>{
        const slot=getItem(item).slot;
        if(slot && equippedBySlot[slot]){
          equippedBySlot[slot].push(item);
        }
      });
      Object.entries(EQUIPMENT_SLOTS).forEach(([slot,count])=>{
        for(let i=0;i<count;i++){
          const item=equippedBySlot[slot].shift();
          if(item){
            equipmentGrid.appendChild(buildItemTile({id:item,count:1,data:getItem(item),source:'equipped'}));
          }else{
            equipmentGrid.appendChild(buildEmptySlotTile(slotLabel(slot)));
          }
        }
      });
      dom.equipment.appendChild(equipmentGrid);
      if(dom.backpackCount){
        dom.backpackCount.textContent=`(${getBackpackUsage()}/${getBackpackLimit()})`;
      }
      if(dom.loadoutCount){
        dom.loadoutCount.textContent=`(${getEquipmentUsageCount()}/${getEquipmentSlotTotal()})`;
      }
      dom.codex.textContent = state.codex[state.codex.length-1] || '';
    }

    function changeCraftingPage(delta){
      const totalPages=Math.max(1,Math.ceil(CRAFTING_RECIPES.length/CRAFTING_PAGE_SIZE));
      state.craftingPage=clamp(state.craftingPage+delta,0,totalPages-1);
      renderCrafting();
    }

    function renderCrafting(){
      if(!dom.crafting) return;
      dom.crafting.innerHTML='';
      if(!CRAFTING_RECIPES.length){
        const empty=document.createElement('div');
        empty.className='muted-box';
        empty.textContent='No recipes available yet.';
        dom.crafting.appendChild(empty);
        return;
      }
      const totalPages=Math.max(1,Math.ceil(CRAFTING_RECIPES.length/CRAFTING_PAGE_SIZE));
      state.craftingPage=clamp(state.craftingPage,0,totalPages-1);
      const start=state.craftingPage*CRAFTING_PAGE_SIZE;
      const visibleRecipes=CRAFTING_RECIPES.slice(start,start+CRAFTING_PAGE_SIZE);
      const grid=document.createElement('div');
      grid.className='recipe-grid';
      visibleRecipes.forEach(recipe=>{
        const card=document.createElement('div');
        card.className='recipe-card';
        const titleRow=document.createElement('div');
        titleRow.className='title-row';
        titleRow.innerHTML=`<span>${recipe.label}</span><span class="small">craft</span>`;
        const desc=document.createElement('div');
        desc.className='small';
        desc.textContent=recipe.desc;
        const reqs=document.createElement('div');
        reqs.className='reqs';
        const reqParts=Object.entries(recipe.cost).map(([id,count])=>{
          const have=getItemCount(state.inventory,id);
          const status=have>=count?'✓':'•';
          return `${status} ${id} ${have}/${count}`;
        });
        reqs.textContent=reqParts.join(' · ');
        const craftBtn=document.createElement('button');
        craftBtn.textContent=`Craft ${recipe.label}`;
        const canCraft=hasCraftingMaterials(recipe) && hasCapacityFor(state.inventory,getBackpackLimit(),recipe.id,1);
        craftBtn.disabled=!canCraft;
        if(!hasCraftingMaterials(recipe)) craftBtn.title='Missing materials.';
        else if(!hasCapacityFor(state.inventory,getBackpackLimit(),recipe.id,1)) craftBtn.title='Backpack capacity reached.';
        craftBtn.onclick=()=>craftRecipe(recipe.id);
        card.appendChild(titleRow);
        card.appendChild(desc);
        card.appendChild(reqs);
        card.appendChild(craftBtn);
        grid.appendChild(card);
      });
      dom.crafting.appendChild(grid);
      if(totalPages>1){
        const pager=document.createElement('div');
        pager.className='pager';
        const prev=document.createElement('button');
        prev.textContent='Previous recipes';
        prev.disabled=state.craftingPage===0;
        prev.onclick=()=>changeCraftingPage(-1);
        const info=document.createElement('div');
        info.className='page-info';
        const end=Math.min(CRAFTING_RECIPES.length,start+visibleRecipes.length);
        info.textContent=`Showing recipes ${start+1}-${end} of ${CRAFTING_RECIPES.length}`;
        const next=document.createElement('button');
        next.textContent='More recipes';
        next.disabled=state.craftingPage>=totalPages-1;
        next.onclick=()=>changeCraftingPage(1);
        pager.appendChild(prev);
        pager.appendChild(info);
        pager.appendChild(next);
        dom.crafting.appendChild(pager);
      }
    }

    function renderMarketStock(){
      if(!dom.marketInventory) return;
      dom.marketInventory.innerHTML='';
      const marketActive=canAccessMarket();
      if(dom.marketHint){
        dom.marketHint.textContent=marketActive
          ? 'Market vendors are online. Trade while the shop is open.'
          : 'Visit a shop in your current location to access vendors.';
      }
      MARKET_STOCK.forEach(stock=>{
        const data=getItem(stock.id);
        const card=document.createElement('div');
        card.className='market-card';
        const titleRow=document.createElement('div');
        titleRow.className='title-row';
        titleRow.innerHTML=`<span>${stock.id}</span><span class="small">${stock.tag}</span>`;
        const desc=document.createElement('div');
        desc.className='small';
        desc.textContent=`${rarityLabel(data.rarity)} · ${data.type}`;
        const cost=document.createElement('div');
        cost.className='cost';
        cost.textContent=`${stock.cost} credits`;
        const btn=document.createElement('button');
        btn.textContent=`Buy ${stock.id}`;
        const canBuy=marketActive && state.credits>=stock.cost && hasCapacityFor(state.inventory,getBackpackLimit(),stock.id,1);
        btn.disabled=!canBuy;
        if(!marketActive) btn.title='Visit a shop to buy.';
        else if(!hasCapacityFor(state.inventory,getBackpackLimit(),stock.id,1)) btn.title='Backpack full.';
        else if(state.credits<stock.cost) btn.title='Not enough credits.';
        btn.onclick=()=>buyMarketItem(stock.id);
        card.appendChild(titleRow);
        card.appendChild(desc);
        card.appendChild(cost);
        card.appendChild(btn);
        dom.marketInventory.appendChild(card);
      });
    }

    function renderIdleOps(){
      dom.idleOps.innerHTML='';
      const gearMods=getGearMods();
      const vaultAccess=canAccessVault();
      if(state.idleOps.active){
        const op=idleOperations.find(entry=>entry.id===state.idleOps.id);
        const elapsed=Math.max(0,(Date.now()-state.idleOps.startedAt)/1000);
        const total=state.idleOps.durationMs/1000;
        const pctDone=clamp((elapsed/total)*100,0,100);
        const card=document.createElement('div');
        card.className='op-card';
        const title=document.createElement('div');
        title.innerHTML=`<b>${op.label}</b> · in progress`;
        const progress=document.createElement('div');
        progress.className='progress';
        progress.innerHTML=`<span style="width:${pctDone}%;"></span>`;
        const meta=document.createElement('div');
        meta.className='op-meta';
        const remainingMinutes=Math.max(0,(total-elapsed)/60);
        meta.textContent=`ETA ${formatMinutesPrecise(remainingMinutes)} · ${op.desc}`;
        const signal=document.createElement('div');
        signal.className='op-meta';
        signal.textContent=state.idleOps.statusMessage || 'Operation underway.';
        card.appendChild(title);
        card.appendChild(progress);
        card.appendChild(meta);
        card.appendChild(signal);
        dom.idleOps.appendChild(card);
        return;
      }
      if(state.idleOps.completed){
        const op=idleOperations.find(entry=>entry.id===state.idleOps.id);
        const card=document.createElement('div');
        card.className='op-card';
        const title=document.createElement('div');
        title.innerHTML=`<b>${op?.label || 'Idle operation'}</b> · complete`;
        const meta=document.createElement('div');
        meta.className='op-meta';
        meta.textContent=state.idleOps.statusMessage || 'Rewards ready to review.';
        card.appendChild(title);
        card.appendChild(meta);
        const rewardsWrap=document.createElement('div');
        rewardsWrap.className='item-grid';
        const rewards=state.idleOps.rewards || [];
        if(rewards.length){
          rewards.forEach(item=>{
            const data=getItem(item);
            const row=buildItemRow({id:item,count:1,data,source:'idleReward'});
            rewardsWrap.appendChild(row);
            const actions=document.createElement('div');
            actions.className='inline-actions';
            const packBtn=document.createElement('button');
            packBtn.textContent='Pack';
            packBtn.disabled=!hasCapacityFor(state.inventory,getBackpackLimit(),item,1);
            packBtn.onclick=()=>claimRewardToInventory('idleReward',item);
            actions.appendChild(packBtn);
            if(data.slot){
              const equipBtn=document.createElement('button');
              equipBtn.textContent='Equip';
              equipBtn.disabled=!canEquipItem(item).ok;
              equipBtn.onclick=()=>equipRewardItem('idleReward',item);
              actions.appendChild(equipBtn);
            }
            const vaultBtn=document.createElement('button');
            vaultBtn.textContent='Vault';
            vaultBtn.disabled=!vaultAccess || !hasCapacityFor(state.stash.items,state.stashLimit,item,1);
            vaultBtn.title=vaultAccess ? '' : vaultBlockedMessage;
            vaultBtn.onclick=()=>claimRewardToVault('idleReward',item);
            actions.appendChild(vaultBtn);
            const scrapBtn=document.createElement('button');
            scrapBtn.textContent=`Scrap ${salvageValue(item)}`;
            scrapBtn.onclick=()=>scrapRewardItem('idleReward',item);
            actions.appendChild(scrapBtn);
            const leaveBtn=document.createElement('button');
            leaveBtn.textContent='Leave';
            leaveBtn.onclick=()=>leaveRewardItem('idleReward',item);
            actions.appendChild(leaveBtn);
            rewardsWrap.appendChild(actions);
          });
        }else{
          const empty=document.createElement('div');
          empty.className='muted-box';
          empty.textContent='Rewards resolved. Close the operation to dispatch again.';
          rewardsWrap.appendChild(empty);
        }
        card.appendChild(rewardsWrap);
        const footer=document.createElement('div');
        footer.className='op-actions';
        if(rewards.length){
          const leaveAll=document.createElement('button');
          leaveAll.textContent='Leave all rewards';
          leaveAll.onclick=()=>clearRewardSource('idleReward');
          footer.appendChild(leaveAll);
        }
        const closeBtn=document.createElement('button');
        closeBtn.textContent='Close operation';
        closeBtn.disabled=rewards.length>0;
        closeBtn.onclick=closeIdleOp;
        footer.appendChild(closeBtn);
        card.appendChild(footer);
        dom.idleOps.appendChild(card);
      }
      const blockedDispatch=state.idleOps.active || state.idleOps.completed;
      idleOperations.forEach(op=>{
        const card=document.createElement('div');
        card.className='op-card';
        const title=document.createElement('div');
        title.innerHTML=`<b>${op.label}</b>`;
        const meta=document.createElement('div');
        meta.className='op-meta';
        const duration=getIdleDurationMinutes(op,gearMods);
        meta.textContent=`${op.desc} · ${formatMinutesPrecise(duration)}`;
        const cost=document.createElement('div');
        cost.className='op-meta';
        cost.textContent=`Cost: ${formatCost(op.cost)} · Reward: ${op.reward}`;
        const actions=document.createElement('div');
        actions.className='op-actions';
        const btn=document.createElement('button');
        btn.textContent='Dispatch';
        btn.onclick=()=>startIdleOp(op.id);
        if(blockedDispatch || !canAfford(op.cost)) btn.disabled=true;
        if(state.idleOps.completed && (state.idleOps.rewards?.length||0)>0){
          btn.title='Resolve idle rewards before dispatching again.';
        }
        actions.appendChild(btn);
        card.appendChild(title);
        card.appendChild(meta);
        card.appendChild(cost);
        card.appendChild(actions);
        dom.idleOps.appendChild(card);
      });
    }

    function setActiveTab(tab){
      activeTab=tab;
      syncTabs();
    }

    function syncTabs(){
      dom.tabButtons.forEach(btn=>{
        const target=btn.dataset.tab;
        btn.classList.toggle('active',target===activeTab);
        btn.disabled=false;
      });
      if(state.mission.active){
        const stashBtn=dom.tabButtons.find(btn=>btn.dataset.tab==='field');
        if(stashBtn) stashBtn.disabled=true;
      }
      Object.entries(dom.tabContents).forEach(([id,el])=>{
        el.classList.toggle('active',id===activeTab);
      });
    }

    dom.tabButtons.forEach(btn=>{
      btn.onclick=()=>{ activeTab=btn.dataset.tab; syncTabs(); };
    });

    function setInventoryScreen(screen){
      const changed=state.inventoryScreen!==screen;
      state.inventoryScreen=screen;
      dom.inventoryNav.forEach(btn=>{
        btn.classList.toggle('active',btn.dataset.invScreen===screen);
      });
      Object.entries(dom.inventoryScreens).forEach(([id,el])=>{
        el.classList.toggle('active',id===screen);
      });
      if(changed){
        clearSelection();
      }
    }

    function setStashScreen(screen){
      state.stashScreen=screen;
      dom.stashNav.forEach(btn=>{
        btn.classList.toggle('active',btn.dataset.stashScreen===screen);
      });
      Object.entries(dom.stashScreens).forEach(([id,el])=>{
        el.classList.toggle('active',id===screen);
      });
    }

    dom.inventoryNav.forEach(btn=>{
      btn.onclick=()=>setInventoryScreen(btn.dataset.invScreen);
    });

    dom.stashNav.forEach(btn=>{
      btn.onclick=()=>setStashScreen(btn.dataset.stashScreen);
    });

    function clearSelection(){
      if(!state.selected.source) return;
      state.selected={source:null,item:null};
      renderItemDetails();
      renderInventory();
      renderStash();
      renderMissionStatus();
      renderIdleOps();
    }

    function selectItem(source,item){
      state.selected={source,item};
      renderItemDetails();
      renderInventory();
      renderStash();
      renderMissionStatus();
      renderIdleOps();
    }

    function setScreen(screen){
      if(screen==='locations' && state.mission.active){
        setCodex('Mission in progress. Locations hub locked.');
        return;
      }
      if(screen==='main' && state.mission.active){
        setCodex('Mission in progress. Stay on the raid feed.');
        return;
      }
      if(screen==='mission' && !state.mission.active){
        setCodex('No mission active.');
        return;
      }
      state.screen=screen;
      if(screen==='locations'){
        ensureExpansionsLoaded();
      }
      renderScreens();
    }

    function renderScreens(){
      dom.screenButtons.forEach(btn=>{
        const target=btn.dataset.screen;
        const isLocked=target==='mission' && !state.mission.active;
        const isLocationsLocked=target==='locations' && state.mission.active;
        const isMainLocked=target==='main' && state.mission.active;
        btn.classList.toggle('active',target===state.screen);
        btn.disabled=isLocked || isLocationsLocked || isMainLocked;
      });
      if(dom.enterLocations){
        dom.enterLocations.disabled=state.mission.active;
      }
      Object.entries(dom.screens).forEach(([id,el])=>{
        el.classList.toggle('active',id===state.screen);
      });
    }

    dom.screenButtons.forEach(btn=>{
      btn.onclick=()=>setScreen(btn.dataset.screen);
    });
    dom.enterLocations.onclick=()=>setScreen('locations');
    dom.returnMain.onclick=()=>setScreen('main');

    function renderExcursionStatus(){
      const scene=ensureZoneScene(state.zone);
      const locationLabel=scene?.title ? `${state.zone.name} · ${scene.title}` : state.zone.name;
      dom.excursionStatus.innerHTML=`<b>Loop status:</b> Location ${locationLabel} · Energy ${state.energy}/${state.maxEnergy} · Backpack ${getBackpackUsage()}/${getBackpackLimit()} · Stash ${getStashUsage()}/${state.stashLimit} · Loadout ${getEquipmentUsageCount()}/${getEquipmentSlotTotal()}.`;
      dom.tempoHint.textContent='Run missions to earn XP, then review rewards and swap in better gear.';
    }

    function renderHubAccess(){
      dom.hubLock.textContent=state.mission.active
        ? 'Mission underway. Await extraction clearance before entering locations hub.'
        : 'Ops bay is live. Step into the locations hub to pick a gate and launch a raid.';
    }

    function renderZone(){
      const scene=ensureZoneScene(state.zone);
      dom.zoneTitle.textContent=scene?.title ? `${state.zone.name} · ${scene.title}` : state.zone.name;
      dom.zoneDesc.textContent=scene?.desc || state.zone.desc;
      dom.zoneBadge.textContent=`${state.zone.risk} risk`;
    }

    function renderRaidActions(){
      dom.raidActions.innerHTML='';
      const exp=expansions[state.zone.id];
      const scene=ensureZoneScene(state.zone);
      if(scene && scene.options && scene.options.length){
        scene.options.forEach(option=>{
          const btn=document.createElement('button');
          const label=option.label || 'Local action';
          btn.innerHTML=`<span>${label}</span><span class="small">${option.risk} · ${option.time} min</span>`;
          btn.onclick=()=>startSceneAction(option);
          if(state.mission.active || state.travel.active) btn.disabled=true;
          if(option.risk==='high') btn.classList.add('danger');
          dom.raidActions.appendChild(btn);
        });
      }
      const vendorEligible=isMarketZone() || state.zone.id==='safehouse';
      if(vendorEligible){
        const shopBtn=document.createElement('button');
        shopBtn.innerHTML=`<span>Visit shop</span><span class="small">trade · vendors</span>`;
        shopBtn.onclick=()=>openMarketAccess();
        if(state.mission.active || state.travel.active) shopBtn.disabled=true;
        dom.raidActions.appendChild(shopBtn);
      }
      if(isHubZone() && !dom.raidActions.children.length){
        const blocked=document.createElement('div');
        blocked.className='muted-box';
        blocked.textContent='Hub zone secure. Use the transit console to select a field site.';
        dom.raidActions.appendChild(blocked);
        return;
      }
      if(!isHubZone()){
        RAID_TEMPLATES.forEach(raid=>{
          const btn=document.createElement('button');
          const costParts=[`${raid.energy} energy`];
          if(raid.key) costParts.push(`${raid.key} key`);
          btn.innerHTML=`<span>${raid.label}</span><span class="small">${raid.risk} · ${raid.time} min · ${costParts.join(' · ')}</span>`;
          btn.onclick=()=>startMission(raid);
          if(state.mission.active || state.travel.active || !canAfford({energy:raid.energy,keys:raid.key||0})) btn.disabled=true;
          if(raid.risk==='high') btn.classList.add('danger');
          dom.raidActions.appendChild(btn);
        });
        if(exp && exp.quests && exp.quests.length){
          exp.quests.forEach(quest=>{
            const btn=document.createElement('button');
            const questFlag=quest.flag || quest.id;
            const completed=quest.once && questFlag && state.flags.has(questFlag);
            const label=quest.title || 'Local contract';
            const time=quest.time || 10;
            const risk=quest.risk || state.zone.risk;
            const energy=quest.energy ?? 12;
            const keyCost=quest.key || 0;
            const costParts=[`${energy} energy`];
            if(keyCost) costParts.push(`${keyCost} key`);
            btn.innerHTML=`<span>${label}</span><span class="small">${risk} · ${time} min · ${costParts.join(' · ')}</span>`;
            btn.onclick=()=>runQuest(quest);
            if(completed){
              btn.disabled=true;
              btn.title='Contract complete.';
            }else if(state.mission.active || state.travel.active || !canAfford({energy,keys:keyCost})){
              btn.disabled=true;
            }
            if(risk==='high') btn.classList.add('danger');
            dom.raidActions.appendChild(btn);
          });
        }
        const combatBtn=document.createElement('button');
        combatBtn.innerHTML=`<span>Engage hostiles</span><span class="small">${state.zone.risk} · ${getCombatProfile(state.zone.risk).time} min · 10 energy</span>`;
        combatBtn.onclick=startCombatMission;
        if(state.mission.active || state.travel.active || !canAfford({energy:10})) combatBtn.disabled=true;
        combatBtn.classList.add('danger');
        dom.raidActions.appendChild(combatBtn);
        const canCamp=state.screen==='locations' && state.zone.id!=='safehouse';
        if(canCamp){
          const rest=document.createElement('button');
          rest.innerHTML=`<span>Make camp</span><span class="small">recover · ${ACTION_TIMES.camp} min</span>`;
          rest.onclick=runCamp;
          if(state.mission.active || state.travel.active) rest.disabled=true;
          dom.raidActions.appendChild(rest);
        }
      }
    }

    function openMarketAccess(){
      if(state.mission.active || state.travel.active){
        setCodex('Finish current operations before visiting vendors.');
        return;
      }
      if(!(isMarketZone() || state.zone.id==='safehouse')){
        setCodex('No vendors are set up here.');
        return;
      }
      state.marketAccess={active:true,zoneId:state.zone.id};
      setCodex('Vendor bay open. Trade out of your active pack while the shop is live.');
      setActiveTab('field');
      renderAll();
    }

    function startSceneAction(option){
      if(state.mission.active){
        setCodex('Mission already underway.');
        return;
      }
      if(state.travel.active){
        setCodex('Finish travel before taking local action.');
        return;
      }
      startLoops();
      const label=option.label || 'Local action';
      const risk=option.risk || state.zone.risk;
      const time=option.time || 8;
      const durationMs=computeMissionDurationMs({risk,time,loot:option.loot});
      const raidLike={
        id:`scene-${Date.now()}`,
        label,
        desc:'',
        time,
        energy:0,
        loot:0,
        risk
      };
      const now=Date.now();
      state.mission={
        active:true,
        type:'scene',
        raid:raidLike,
        startedAt:now,
        endsAt:now+durationMs,
        completed:false,
        success:null,
        summary:'',
        rewards:[],
        statusMessage:`Action underway: ${label}.`,
        location:{...state.zone},
        fleeing:false,
        fleeEndsAt:null,
        pendingResolution:null,
        xpReward:computeMissionXp(risk,time),
        rewardEffects:{success:option.success||'',fail:option.fail||''},
        questMeta:null,
        combat:null,
        sceneTarget:option.target || null
      };
      setCodex(`Action launched: ${label}.`);
      logMsg(`Local action: ${label} (${time} min).`);
      setActiveTab('hub');
      setScreen('mission');
      normalizeMissionTiming(Date.now());
      renderAll();
    }

    function resolveTravelIfComplete(){
      if(!state.travel.active) return false;
      if(!state.travel.target || !state.travel.endsAt){
        state.travel={active:false,endsAt:null,target:null};
        setCodex('Transit data lost. Select a zone gate to reroute.');
        logMsg('Transit data lost. Zone selection reset.');
        if(travelResolveTimer){
          clearTimeout(travelResolveTimer);
          travelResolveTimer=null;
        }
        return true;
      }
      if(Date.now()<state.travel.endsAt) return false;
      state.zone=state.travel.target;
      clearMarketAccess();
      state.travel={active:false,endsAt:null,target:null};
      setCodex(`Arrived at ${state.zone.name}.`);
      logMsg(`Transit complete: ${state.zone.name}.`);
      saveGame();
      if(travelResolveTimer){
        clearTimeout(travelResolveTimer);
        travelResolveTimer=null;
      }
      return true;
    }

    function renderTravelStatus(){
      if(resolveTravelIfComplete()){
        return renderTravelStatus();
      }
      const doorButtons=dom.doors.querySelectorAll('button');
      doorButtons.forEach(btn=>{
        btn.disabled=state.mission.active || state.travel.active;
      });
      if(state.travel.active){
        scheduleTravelResolution();
        const targetName=state.travel.target?.name || 'unknown gate';
        dom.travelStatus.innerHTML=`<span class="spinner"></span><span>Routing to ${targetName}… hold tight.</span>`;
      }else{
        dom.travelStatus.textContent='Transit clear. Select a zone gate to jump.';
      }
    }

    function renderMissionStatus(){
      if(!state.mission.active){
        dom.missionTitle.textContent='No mission active.';
        dom.missionMeta.textContent='Launch a raid from the locations hub to enter the field.';
        dom.missionProgress.querySelector('span').style.width='0%';
        dom.missionLog.textContent='';
        dom.missionActions.innerHTML='';
        if(dom.missionRewardsCard) dom.missionRewardsCard.style.display='none';
        if(dom.missionRewardList) dom.missionRewardList.innerHTML='';
        if(dom.missionRewardActions) dom.missionRewardActions.innerHTML='';
        if(dom.missionRewardDetail) dom.missionRewardDetail.textContent='Complete a mission to review rewards.';
        return;
      }
      const raid=state.mission.raid;
      const remainingMs=Math.max(0,state.mission.endsAt-Date.now());
      const totalMs=Math.max(1,state.mission.endsAt-state.mission.startedAt);
      const percent=clamp(((totalMs-remainingMs)/totalMs)*100,0,100);
      dom.missionProgress.querySelector('span').style.width=`${state.mission.completed ? 100 : percent}%`;
      const remainingSec=Math.ceil(remainingMs/1000);
      const labelPrefix=state.mission.type==='combat'
        ? 'In combat'
        : (state.mission.type==='contract'
          ? 'In contract'
          : (state.mission.type==='scene' ? 'In action' : 'In raid'));
      dom.missionTitle.textContent=state.mission.completed
        ? `Mission complete: ${raid.label}`
        : `${labelPrefix}: ${raid.label}`;
      const etaLabel=state.mission.fleeing ? 'Escaping…' : `ETA ${remainingSec}s`;
      dom.missionMeta.textContent=`${raid.risk} risk · ${raid.time} min op · ${state.mission.location?.name || state.zone.name} · XP ${state.mission.xpReward || computeMissionXp(raid.risk,raid.time)} · ${state.mission.completed ? 'Rewards ready' : etaLabel}`;
      const liveMessage=state.mission.statusMessage || state.mission.summary;
      dom.missionLog.textContent=liveMessage || 'Stay sharp. Watch the feed for extraction clearance.';
      dom.missionActions.innerHTML='';
      const rewards=state.mission.rewards || [];
      const rewardsReady=state.mission.completed && rewards.length>0;
      if(state.mission.completed && rewards.length===0){
        autoCloseMissionIfResolved();
        if(!state.mission.active) return;
      }
      if(dom.missionRewardsCard){
        dom.missionRewardsCard.style.display=state.mission.completed ? 'flex' : 'none';
      }
      if(dom.missionRewardList){
        dom.missionRewardList.innerHTML='';
        if(rewardsReady){
          groupItems(rewards).forEach(({id,count,data})=>{
            const wrap=document.createElement('div');
            wrap.appendChild(buildItemRow({id,count,data,source:'missionReward'}));
            const actions=document.createElement('div');
            actions.className='inline-actions';
            const packBtn=document.createElement('button');
            packBtn.textContent=`Backpack (${count})`;
            packBtn.disabled=!hasCapacityFor(state.inventory,getBackpackLimit(),id,count);
            packBtn.onclick=()=>{
              const moveCount=Math.min(count,rewards.filter(entry=>entry===id).length);
              for(let i=0;i<moveCount;i++) claimRewardToInventory('missionReward',id);
            };
            actions.appendChild(packBtn);
            if(data.slot){
              const equipBtn=document.createElement('button');
              equipBtn.textContent='Equip';
              equipBtn.disabled=!canEquipItem(id).ok;
              equipBtn.onclick=()=>equipRewardItem('missionReward',id);
              actions.appendChild(equipBtn);
            }
            const scrapBtn=document.createElement('button');
            scrapBtn.textContent=`Scrap ${salvageValue(id)}`;
            scrapBtn.onclick=()=>scrapRewardItem('missionReward',id);
            actions.appendChild(scrapBtn);
            const leaveBtn=document.createElement('button');
            leaveBtn.textContent='Leave';
            leaveBtn.onclick=()=>leaveRewardItem('missionReward',id);
            actions.appendChild(leaveBtn);
            wrap.appendChild(actions);
            dom.missionRewardList.appendChild(wrap);
          });
        }else if(state.mission.completed){
          const empty=document.createElement('div');
          empty.className='muted-box';
          empty.textContent=state.mission.success ? 'No rewards remaining. Mission will close automatically.' : 'Mission failed. Mission will close automatically.';
          dom.missionRewardList.appendChild(empty);
        }
      }
      if(!state.mission.completed && state.mission.type==='combat'){
        const combat=state.mission.combat;
        if(combat){
          const hud=document.createElement('div');
          hud.className='combat-hud';
          const title=document.createElement('div');
          title.className='combat-title';
          title.textContent=`Signal log: ${raid.enemyName}`;
          const stats=document.createElement('div');
          stats.className='combat-stats';
          const consumeState=combat.consumable
            ? `Applying ${combat.consumable.item} (${Math.max(0,Math.ceil((combat.consumable.readyAt-Date.now())/1000))}s)`
            : 'No consumable in use';
          stats.innerHTML=`<div><b>Enemy HP</b> ${Math.max(0,Math.round(combat.enemyHp))}/${Math.round(combat.enemyMaxHp)}</div>`+
            `<div><b>Enemies left</b> ${combat.enemiesRemaining}/${combat.totalEnemies}</div>`+
            `<div><b>You dealt</b> ${Math.round(combat.totalDamageDealt)}</div>`+
            `<div><b>You took</b> ${Math.round(combat.totalDamageTaken)}</div>`+
            `<div><b>Consumable</b> ${consumeState}</div>`;
          hud.appendChild(title);
          hud.appendChild(stats);
          const consumables=document.createElement('div');
          consumables.className='combat-consumables';
          const consumableItems=groupItems(state.inventory.filter(item=>getItem(item).type==='consumable'));
          if(consumableItems.length){
            const hint=document.createElement('div');
            hint.className='small';
            hint.textContent='Backpack consumables (3s channel, one at a time):';
            consumables.appendChild(hint);
            consumableItems.forEach(({id,count})=>{
              const btn=document.createElement('button');
              btn.textContent=`Use ${id} ×${count}`;
              btn.disabled=Boolean(combat.consumable);
              btn.onclick=()=>applyCombatConsumable(id);
              consumables.appendChild(btn);
            });
          }else{
            const empty=document.createElement('div');
            empty.className='small';
            empty.textContent='No consumables in backpack.';
            consumables.appendChild(empty);
          }
          hud.appendChild(consumables);
          dom.missionActions.appendChild(hud);
        }
        const fleeBtn=document.createElement('button');
        fleeBtn.textContent=state.mission.fleeing ? 'Fleeing…' : 'Flee (5s)';
        fleeBtn.disabled=state.mission.fleeing;
        fleeBtn.onclick=attemptFlee;
        dom.missionActions.appendChild(fleeBtn);
      }
      if(state.mission.completed){
        if(rewardsReady){
          const leaveAll=document.createElement('button');
          leaveAll.textContent='Leave all rewards';
          leaveAll.onclick=()=>clearRewardSource('missionReward');
          dom.missionActions.appendChild(leaveAll);
        }
        const closeBtn=document.createElement('button');
        closeBtn.textContent='Close mission';
        closeBtn.disabled=rewards.length>0;
        closeBtn.onclick=closeMission;
        dom.missionActions.appendChild(closeBtn);
      }
    }

    function renderStash(){
      dom.stash.innerHTML='';
      dom.stashActions.innerHTML='';
      const vaultAccess=canAccessVault();
      const marketActive=canAccessMarket();
      const useShopInventory=marketActive && !vaultAccess;
      const items=useShopInventory ? state.inventory : state.stash.items;
      if(dom.stashTitle){
        dom.stashTitle.textContent=useShopInventory ? 'Trade Bay' : 'Stash Vault';
      }
      if(dom.stashSubtitle){
        dom.stashSubtitle.innerHTML=useShopInventory
          ? `Backpack Inventory <span class="small" id="stashCount"></span>`
          : `Vault Inventory <span class="small" id="stashCount"></span>`;
        dom.stashCount=document.getElementById('stashCount');
      }
      if(dom.stashCount){
        dom.stashCount.textContent=useShopInventory
          ? `(${getBackpackUsage()}/${getBackpackLimit()})`
          : `(${getStashUsage()}/${state.stashLimit})`;
      }
      if(!items.length){
        const empty=document.createElement('div');
        empty.className='muted-box';
        empty.textContent=useShopInventory
          ? 'Backpack is empty. Trade when you have gear on hand.'
          : 'Stash is empty. Move loot here for long-term storage.';
        dom.stash.appendChild(empty);
      }else{
        const grid=document.createElement('div');
        grid.className='icon-grid';
        const grouped=groupItems(items);
        const {entries,page,totalPages}=paginateEntries(grouped,'stashPage',GRID_PAGE_SIZE);
        entries.forEach(({id,count,data})=>{
          grid.appendChild(buildItemTile({id,count,data,source:useShopInventory ? 'inventory' : 'stash'}));
        });
        dom.stash.appendChild(grid);
        const pager=renderPager({
          page,
          totalPages,
          label:'items',
          onPrev:()=>{state.stashPage=Math.max(0,page-1); renderStash();},
          onNext:()=>{state.stashPage=Math.min(totalPages-1,page+1); renderStash();}
        });
        if(pager) dom.stash.appendChild(pager);
      }
      if(!vaultAccess){
        const blocked=document.createElement('div');
        blocked.className='muted-box';
        blocked.textContent=marketActive
          ? 'Trade bay open. Select backpack items to sell or break down.'
          : vaultBlockedMessage;
        dom.stashActions.appendChild(blocked);
        renderMarketStock();
        return;
      }
      const upgradesHeading=document.createElement('div');
      upgradesHeading.className='command-title';
      upgradesHeading.textContent='Safehouse upgrades';
      dom.stashActions.appendChild(upgradesHeading);
      const upgradesHint=document.createElement('div');
      upgradesHint.className='small';
      upgradesHint.textContent='Invest scrap and credits to expand storage capacity.';
      dom.stashActions.appendChild(upgradesHint);
      const upgradeCost=getStashUpgradeCost();
      const upgradeCard=document.createElement('div');
      upgradeCard.className='op-card';
      const upgradeTitle=document.createElement('div');
      upgradeTitle.innerHTML='<b>Safehouse storage</b>';
      const upgradeMeta=document.createElement('div');
      upgradeMeta.className='op-meta';
      upgradeMeta.textContent=`Increase vault capacity by ${STASH_UPGRADE_STEP} slots.`;
      const upgradeCostLine=document.createElement('div');
      upgradeCostLine.className='op-meta';
      upgradeCostLine.textContent=`Cost: ${formatCost(upgradeCost)} · Current capacity ${state.stashLimit}.`;
      const upgradeActions=document.createElement('div');
      upgradeActions.className='op-actions';
      const upgradeBtn=document.createElement('button');
      upgradeBtn.textContent=`Upgrade storage (+${STASH_UPGRADE_STEP})`;
      upgradeBtn.onclick=upgradeStash;
      if(!vaultAccess){
        upgradeBtn.disabled=true;
        upgradeBtn.title=vaultBlockedMessage;
      }else if(!canAfford(upgradeCost)){
        upgradeBtn.disabled=true;
        upgradeBtn.title='Need more credits or scrap.';
      }
      upgradeActions.appendChild(upgradeBtn);
      upgradeCard.appendChild(upgradeTitle);
      upgradeCard.appendChild(upgradeMeta);
      upgradeCard.appendChild(upgradeCostLine);
      upgradeCard.appendChild(upgradeActions);
      dom.stashActions.appendChild(upgradeCard);
      const bulk=document.createElement('div');
      bulk.className='inventory inline-actions';
      const sellAll=document.createElement('button');
      sellAll.textContent='Sell all stash';
      sellAll.onclick=bulkSellStash;
      if(!vaultAccess){
        sellAll.disabled=true;
        sellAll.title=vaultBlockedMessage;
      }else if(!canAccessMarket()){
        sellAll.disabled=true;
        sellAll.title='Visit a shop to sell.';
      }
      const scrapAll=document.createElement('button');
      scrapAll.textContent='Scrap all stash';
      scrapAll.onclick=bulkScrapStash;
      if(!vaultAccess){
        scrapAll.disabled=true;
        scrapAll.title=vaultBlockedMessage;
      }
      bulk.appendChild(sellAll);
      bulk.appendChild(scrapAll);
      dom.stashActions.appendChild(bulk);
      renderMarketStock();
    }

    /* ================= GAMEPLAY ================= */
    function computeFailChance(risk){
      const base=riskTable[risk] ?? 0.12;
      const gearMods=getGearMods();
      const radsPenalty=Math.min(0.08,state.rads*0.004);
      const hungerPenalty=state.hunger>70?0.05:0;
      const thirstPenalty=state.thirst>70?0.05:0;
      const fatiguePenalty=state.stamina<30?0.04:0;
      const energyPenalty=state.energy<25?0.06:0;
      const tempPenalty=state.bodyTemp<94?0.07:(state.bodyTemp>102?0.05:0);
      const total=base + hungerPenalty + thirstPenalty + fatiguePenalty + energyPenalty + radsPenalty + tempPenalty - (gearMods.riskMod||0);
      return clamp(total,0.05,0.75);
    }

    function tickTime(minutes){
      const total=state.timeMinutes+minutes;
      if(total>=24*60){
        state.timeMinutes=total%(24*60);
        advanceDay();
      }else{
        state.timeMinutes=total;
      }
    }

    function advanceDay(){
      state.day++;
      state.timeMinutes=6*60;
    }

    function rollComplication(source){
      const tension=computeFailChance(state.zone.risk) * 0.55;
      if(Math.random()>tension) return;
      const complications=[
        {desc:'A cold gust slips through your seals.',effects:'temp-2,stamina-2'},
        {desc:'An unseen stalker snatches some scrap.',effects:'scrap-2,temp-1'},
        {desc:'Hunger cramps slow you down.',effects:'stamina-6,hp-3'},
        {desc:'Static surge fries a component.',effects:'credits-6,temp-1'},
        {desc:'Radiation spike makes your skin crawl.',effects:'rads+2,hp-4'}
      ];
      const hit=complications[Math.floor(Math.random()*complications.length)];
      applyEffects(hit.effects,'fail');
      logMsg(`Complication (${source}): ${hit.desc}`);
    }

    function applyEffects(effectStr,outcome,options={}){
      if(!effectStr) return;
      const deferItemsTo=Array.isArray(options.deferItemsTo) ? options.deferItemsTo : null;
      effectStr.split(',').forEach(token=>{
        token=token.trim(); if(!token) return;
        if(token.startsWith('item:')){
          const item=token.slice(5).trim();
          if(deferItemsTo){
            deferItemsTo.push(item);
          }else{
            const routed=routeItemGain(item);
            if(routed==='lost'){
              logMsg(`${item} lost: no storage space available.`);
            }
          }
          return;
        }
        if(token.startsWith('flag:')){ state.flags.add(token.slice(5)); return; }
        if(token.startsWith('note:')){ setCodex(token.slice(5)); return; }
        if(token.startsWith('log:')){ logMsg(token.slice(4)); return; }
        const match=token.match(/([a-zA-Z]+)([+-]\d+)/);
        if(match){
          const stat=match[1]; const delta=Number(match[2]);
          if(stat==='hp') state.hp=clamp(state.hp+delta,0,state.maxHp);
          else if(stat==='stamina') state.stamina=clamp(state.stamina+delta,0,state.maxStamina);
          else if(stat==='morale') state.morale=clamp(state.morale+delta,0,state.maxMorale);
          else if(stat==='hunger') state.hunger=clamp(state.hunger+delta,0,state.maxHunger);
          else if(stat==='thirst') state.thirst=clamp(state.thirst+delta,0,state.maxThirst);
          else if(stat==='rads') state.rads=Math.max(0,state.rads+delta);
          else if(stat==='credits') state.credits=Math.max(0,state.credits+delta);
          else if(stat==='scrap') state.scrap=Math.max(0,state.scrap+delta);
          else if(stat==='energy') state.energy=clamp(state.energy+delta,0,state.maxEnergy);
          else if(stat==='keys') state.keys=Math.max(0,state.keys+delta);
          else if(stat==='temp') state.bodyTemp=clamp(state.bodyTemp+delta,BODY_TEMP_MIN,BODY_TEMP_MAX);
          else if(stat==='backpack') state.backpackLimit=Math.max(0,state.backpackLimit+delta);
        }
      });
      if(outcome==='fail' && state.hp<=0){
        logMsg('Emergency evac: you collapse and lose momentum.');
        state.hp=clamp(40,1,state.maxHp);
        state.morale=clamp(state.morale-12,0,state.maxMorale);
        state.energy=clamp(state.energy-20,0,state.maxEnergy);
      }
    }
    function runRaidInstant(raid,location,options={}){
      tickTime(raid.time);
      const gearMods=getGearMods();
      state.hunger=clamp(state.hunger+2,0,state.maxHunger);
      state.thirst=clamp(state.thirst+2,0,state.maxThirst);
      state.stamina=clamp(state.stamina-6+(gearMods.staminaBonus||0),0,state.maxStamina);
      const deferItemsTo=Array.isArray(options.deferItemsTo) ? options.deferItemsTo : null;
      const rewards=[];

      const locationRisk=location?.risk || state.zone.risk;
      const effectiveRisk=(riskRank[raid.risk] >= riskRank[locationRisk]) ? raid.risk : locationRisk;
      const failChance=computeFailChance(effectiveRisk);
      const roll=Math.random();
      const success=roll>failChance;
      state.bodyTemp=clamp(state.bodyTemp-1.1,BODY_TEMP_MIN,BODY_TEMP_MAX);
      if(success){
        const lootBonus=gearMods.lootBonus || 0;
        const pulls=Math.max(1,raid.loot+(Math.random()<0.35?1:0));
        for(let i=0;i<pulls;i++){
          const drop=rollLootDrop(effectiveRisk,lootBonus);
          addItemCopies(rewards,drop.id,drop.count);
        }
        if(deferItemsTo){
          deferItemsTo.push(...rewards);
        }else{
          rewards.forEach(item=>{
            const routed=routeItemGain(item);
            if(routed==='lost'){
              logMsg(`${item} lost: no storage space available.`);
            }
          });
        }
        logMsg(`✓ ${raid.label} succeeded. Rewards secured.`);
      }else{
        applyEffects('hp-6,morale-4,temp-2','fail');
        rollComplication('raid');
        logMsg(`✖ ${raid.label} failed. You limp back empty-handed.`);
      }
      return {success,rewards,effectiveRisk};
    }

    const getRiskIndex=(risk)=>riskRank[risk] || riskRank.low;
    const MIN_MISSION_SECONDS=4;
    const MAX_MISSION_SECONDS=30;
    const computeMissionDurationSeconds=({risk='low',time=8,loot=0}={})=>{
      const riskIdx=getRiskIndex(risk);
      const timeWeight=Math.max(1,time*0.45);
      const lootWeight=loot ? loot*1.4 : 0;
      const base=4+((riskIdx-1)*4)+timeWeight+lootWeight;
      return clamp(Math.round(base),MIN_MISSION_SECONDS,MAX_MISSION_SECONDS);
    };
    const computeMissionDurationMs=(params)=>computeMissionDurationSeconds(params)*1000;
    const computeMissionXp=(risk,time)=>{
      const riskIdx=getRiskIndex(risk);
      return Math.max(12,Math.round(18+(riskIdx*12)+(time*1.6)));
    };
    const computeCombatChance=(risk)=>{
      const riskIdx=getRiskIndex(risk);
      return clamp(0.12+(riskIdx*0.08),0.12,0.55);
    };
    function getCombatProfile(risk){
      const riskIdx=getRiskIndex(risk);
      return {
        id:`combat-${Date.now()}`,
        label:`Hostile contact (${risk})`,
        risk,
        time:Math.max(6,8+riskIdx*2),
        enemyName:['Scavenger pack','Rogue drone','Ambush crew','Rad-stalker'][riskIdx-1] || 'Hostiles',
        difficulty:1+(riskIdx*0.55)
      };
    }
    function shouldTriggerCombat(risk){
      const chance=computeCombatChance(risk);
      return Math.random()<chance;
    }
    function preparePendingResolution(pending,rewards){
      const pendingRewards=rewards || [];
      state.mission.pendingResolution={...pending,rewards:pendingRewards};
    }
    function launchCombatFromPending(pending){
      const combatProfile=getCombatProfile(pending.risk);
      const combatState=initCombatState(combatProfile);
      const now=Date.now();
      const estimatedMs=clamp(combatState.expectedRounds*COMBAT_ROUND_MS,MIN_MISSION_SECONDS*1000,MAX_MISSION_SECONDS*1000);
      state.mission={
        ...state.mission,
        type:'combat',
        raid:combatProfile,
        startedAt:now,
        endsAt:now+estimatedMs,
        completed:false,
        success:null,
        summary:`Combat engaged: ${combatProfile.enemyName}. ${describeCombatState(combatState)}`,
        rewards:[],
        statusMessage:`Combat engaged: ${combatProfile.enemyName}. ${describeCombatState(combatState)}`,
        fleeing:false,
        fleeEndsAt:null,
        xpReward:computeMissionXp(combatProfile.risk,combatProfile.time),
        rewardEffects:{success:'',fail:''},
        combat:combatState,
        sceneTarget:null
      };
      setCodex('Hostile contact! Hold out or flee.');
      logMsg(`Combat encounter triggered by ${pending.label}. ${describeCombatState(combatState)}`);
      setScreen('mission');
      normalizeMissionTiming(Date.now());
      renderAll();
    }
    function resolvePendingMission(outcomeOverride){
      const pending=state.mission.pendingResolution;
      if(!pending) return;
      const rewards=pending.rewards || [];
      const outcome=outcomeOverride || (pending.success ? 'success' : 'fail');
      const effects=outcome==='success' ? pending.successEffects : pending.failEffects;
      if(effects){
        if(outcome==='success') applyEffects(effects,outcome,{deferItemsTo:rewards});
        else applyEffects(effects,outcome);
      }
      if(outcome==='success' && pending.xpReward){
        awardXp(pending.xpReward,pending.label);
      }
      if(outcome==='success' && pending.flag && pending.once){
        state.flags.add(pending.flag);
      }
      state.mission.completed=true;
      state.mission.success=outcome==='success';
      state.mission.rewards=rewards;
      state.mission.summary=outcome==='success'
        ? 'Extraction secured. Review rewards before closing the mission.'
        : 'Extraction rough. Patch up before you re-deploy.';
      state.mission.statusMessage=outcome==='success'
        ? `Mission complete: ${pending.label}. Rewards ready.`
        : `Mission failed: ${pending.label}.`;
      state.mission.pendingResolution=null;
      setCodex(outcome==='success' ? 'Mission complete. Rewards ready to review.' : 'Mission failed. Recover and try again.');
      state.selected={source:null,item:null};
      renderAll();
    }
    const COMBAT_ROUND_MS=1200;
    const COMBAT_CONSUME_MS=3000;
    const combatVariance=(base,spread)=>Math.max(1,Math.round(base*(1-spread)+(Math.random()*base*spread*2)));
    const describeCombatState=(combat)=>`Enemy HP ${Math.max(0,Math.round(combat.enemyHp))}/${Math.round(combat.enemyMaxHp)} · Enemies left ${combat.enemiesRemaining}/${combat.totalEnemies}`;
    function initCombatState(profile){
      const gearMods=getGearMods();
      const riskIdx=getRiskIndex(profile.risk);
      const totalEnemies=Math.max(1,1+Math.max(0,riskIdx-1));
      const playerDamage=Math.max(6,Math.round(8+(state.level*1.8)+((gearMods.combatBonus||0)*1.4)+((gearMods.staminaBonus||0)*0.6)));
      const enemyDamage=Math.max(2,Math.round((3+(riskIdx*2.6))-(playerDamage*0.12)-((gearMods.riskMod||0)*18)));
      const enemyMaxHp=Math.max(28,Math.round(26+(riskIdx*12)+(profile.difficulty*8)));
      const totalEnemyHp=enemyMaxHp*totalEnemies;
      const expectedRounds=Math.max(4,Math.ceil(totalEnemyHp/Math.max(8,playerDamage*0.9)));
      return {
        riskIdx,
        enemyMaxHp,
        enemyHp:enemyMaxHp,
        totalEnemies,
        enemiesRemaining:totalEnemies,
        playerDamage,
        enemyDamage,
        round:0,
        totalDamageTaken:0,
        totalDamageDealt:0,
        nextTickAt:Date.now()+COMBAT_ROUND_MS,
        consumable:null,
        expectedRounds
      };
    }
    function runCombatEncounter(profile,{success,fleeing=false}={}){
      const gearMods=getGearMods();
      const combat=state.mission.combat || initCombatState(profile);
      const rewards=[];
      const lootPulls=success ? 2+Math.floor(profile.difficulty) : 1;
      for(let i=0;i<lootPulls;i++){
        const drop=rollLootDrop(profile.risk,gearMods.lootBonus||0);
        addItemCopies(rewards,drop.id,drop.count);
      }
      const creditReward=Math.max(6,Math.round((profile.difficulty*12)+(Math.random()*10)));
      const credited=success ? creditReward : Math.round(creditReward*(fleeing?0.6:0.5));
      state.credits+=credited;
      const xpBase=computeMissionXp(profile.risk,profile.time);
      const xpReward=success ? xpBase : Math.round(xpBase*(fleeing?0.7:0.6));
      awardXp(xpReward,profile.enemyName);
      const summary=success
        ? `Hostiles down. You dealt ${Math.round(combat.totalDamageDealt)} and took ${Math.round(combat.totalDamageTaken)} damage. ${credited} credits recovered.`
        : fleeing
          ? `You flee under fire after taking ${Math.round(combat.totalDamageTaken)} damage. Partial rewards recovered.`
          : `You are overrun after taking ${Math.round(combat.totalDamageTaken)} damage and pull back to survive.`;
      return {success,rewards,summary};
    }
    function applyCombatConsumable(item){
      if(!state.mission.active || state.mission.type!=='combat' || state.mission.completed) return;
      const combat=state.mission.combat;
      if(!combat) return;
      if(combat.consumable){
        setCodex(`Already applying ${combat.consumable.item}.`);
        return;
      }
      if(!state.inventory.includes(item)){
        setCodex('Consumable not found in backpack.');
        return;
      }
      const data=getItem(item);
      if(data.type!=='consumable'){
        setCodex('Only consumables can be used mid-combat.');
        return;
      }
      combat.consumable={item,readyAt:Date.now()+COMBAT_CONSUME_MS};
      state.mission.statusMessage=`Applying ${item}… 3s channel.`;
      renderMissionStatus();
    }
    function resolveCombatRound(){
      const combat=state.mission.combat;
      if(!combat) return;
      combat.round+=1;
      let roundLog='';
      if(!state.mission.fleeing){
        const dealt=combatVariance(combat.playerDamage,0.22);
        combat.enemyHp-=dealt;
        combat.totalDamageDealt+=dealt;
        roundLog=`You hit for ${dealt}.`;
        if(combat.enemyHp<=0){
          combat.enemiesRemaining-=1;
          roundLog+=` Target down.`;
          if(combat.enemiesRemaining>0){
            const nextHp=Math.round(combat.enemyMaxHp*(1+combat.riskIdx*0.04));
            combat.enemyMaxHp=nextHp;
            combat.enemyHp=nextHp;
            roundLog+=` ${combat.enemiesRemaining} hostiles remain.`;
          }
        }
      }else{
        roundLog='You focus on disengaging.';
      }
      const incoming=combatVariance(combat.enemyDamage,0.18);
      combat.totalDamageTaken+=incoming;
      state.hp=clamp(state.hp-incoming,0,state.maxHp);
      const staminaHit=Math.max(2,Math.round(incoming*0.6));
      state.stamina=clamp(state.stamina-staminaHit,0,state.maxStamina);
      roundLog+=` Incoming fire deals ${incoming}.`;
      const moraleHit=Math.max(1,Math.round(incoming*0.18));
      state.morale=clamp(state.morale-moraleHit,0,state.maxMorale);
      state.mission.statusMessage=`${roundLog} ${describeCombatState(combat)}`;
      logMsg(state.mission.statusMessage);
    }
    function combatTick(now){
      if(!state.mission.active || state.mission.type!=='combat' || state.mission.completed) return;
      const combat=state.mission.combat;
      if(!combat) return;
      if(combat.consumable && now>=combat.consumable.readyAt){
        const {item}=combat.consumable;
        const data=getItem(item);
        if(data.effect) applyEffects(data.effect,'success');
        removeItem(state.inventory,item);
        combat.consumable=null;
        state.selected={source:null,item:null};
        state.mission.statusMessage=`${item} applied. ${describeCombatState(combat)}`;
        logMsg(state.mission.statusMessage);
      }
      if(now<combat.nextTickAt) return;
      combat.nextTickAt=now+COMBAT_ROUND_MS;
      resolveCombatRound();
      if(combat.enemiesRemaining<=0){
        state.mission.endsAt=now;
        completeMission({combatResolved:true});
      }else if(state.hp<=0){
        state.mission.endsAt=now;
        completeMission({combatResolved:true,forcedFail:true});
      }
    }

    function attemptFlee(){
      if(!state.mission.active || state.mission.type!=='combat' || state.mission.completed) return;
      if(state.mission.fleeing) return;
      state.mission.fleeing=true;
      state.mission.fleeEndsAt=Date.now()+5000;
      state.mission.endsAt=state.mission.fleeEndsAt;
      state.mission.statusMessage=`Attempting to flee… hold for 5 seconds. ${describeCombatState(state.mission.combat)}`;
      logMsg('Escape attempt initiated. Incoming fire continues during the retreat.');
      renderMissionStatus();
    }
    function startCombatMission(){
      if(state.mission.active){
        setCodex('Mission already underway.');
        return;
      }
      if(state.travel.active){
        setCodex('Finish travel before engaging hostiles.');
        return;
      }
      if(isHubZone(state.zone)){
        setCodex('Hub zones are secure. Travel to a field site to engage hostiles.');
        return;
      }
      startLoops();
      const profile=getCombatProfile(state.zone.risk);
      const cost={energy:10};
      if(!canAfford(cost)){
        setCodex('Not enough energy to pick a fight.');
        return;
      }
      applyCost(cost);
      const combatState=initCombatState(profile);
      const now=Date.now();
      const estimatedMs=clamp(combatState.expectedRounds*COMBAT_ROUND_MS,MIN_MISSION_SECONDS*1000,MAX_MISSION_SECONDS*1000);
      state.mission={
        active:true,
        type:'combat',
        raid:profile,
        startedAt:now,
        endsAt:now+estimatedMs,
        completed:false,
        success:null,
        summary:`Combat engaged: ${profile.enemyName}. ${describeCombatState(combatState)}`,
        rewards:[],
        statusMessage:`Combat engaged: ${profile.enemyName}. ${describeCombatState(combatState)}`,
        location:{...state.zone},
        fleeing:false,
        fleeEndsAt:null,
        pendingResolution:null,
        xpReward:computeMissionXp(profile.risk,profile.time),
        rewardEffects:{success:'',fail:''},
        questMeta:null,
        combat:combatState,
        sceneTarget:null
      };
      setCodex('You move to engage hostile contacts.');
      logMsg(`Combat sortie launched against ${profile.enemyName}. ${describeCombatState(combatState)}`);
      setActiveTab('hub');
      setScreen('mission');
      normalizeMissionTiming(Date.now());
      renderAll();
    }
    function runQuest(quest){
      if(state.mission.active || state.travel.active){
        setCodex('Finish current operations before starting a contract.');
        return;
      }
      const questFlag=quest.flag || quest.id;
      if(quest.once && questFlag && state.flags.has(questFlag)){
        setCodex('That contract has already been completed.');
        return;
      }
      const energyCost=quest.energy ?? 12;
      const raidLike={
        id:quest.id,
        label:quest.title || 'Special contract',
        desc:quest.desc,
        time:quest.time || 10,
        energy:energyCost,
        loot:Math.max(2,Math.round((quest.time||10)/5)),
        risk:quest.risk || state.zone.risk,
        key:quest.key||0
      };
      const cost={energy:raidLike.energy,keys:raidLike.key||0};
      if(!canAfford(cost)){
        setCodex('Not enough resources for that contract.');
        return;
      }
      startLoops();
      applyCost(cost);
      const now=Date.now();
      const durationMs=computeMissionDurationMs({risk:raidLike.risk,time:raidLike.time,loot:raidLike.loot});
      state.mission={
        active:true,
        type:'contract',
        raid:raidLike,
        startedAt:now,
        endsAt:now+durationMs,
        completed:false,
        success:null,
        summary:'',
        rewards:[],
        statusMessage:`Contract launched: ${raidLike.label}.`,
        location:{...state.zone},
        fleeing:false,
        fleeEndsAt:null,
        pendingResolution:null,
        xpReward:computeMissionXp(raidLike.risk,raidLike.time),
        rewardEffects:{success:quest.success||'',fail:quest.fail||''},
        questMeta:{flag:questFlag,once:quest.once},
        combat:null,
        sceneTarget:null
      };
      setCodex(`Contract launched: ${raidLike.label}.`);
      logMsg(`Contract deployed: ${raidLike.label} (${raidLike.time} min op).`);
      setActiveTab('hub');
      setScreen('mission');
      normalizeMissionTiming(Date.now());
      renderAll();
    }

    function resetMissionState(){
      state.mission={active:false,type:null,raid:null,startedAt:null,endsAt:null,completed:false,success:null,summary:'',rewards:[],statusMessage:'',location:null,fleeing:false,fleeEndsAt:null,pendingResolution:null,xpReward:0,rewardEffects:{success:'',fail:''},questMeta:null,combat:null,sceneTarget:null};
    }
    function closeMission({auto=false}={}){
      resetMissionState();
      state.selected={source:null,item:null};
      state.screen='main';
      setCodex(auto ? 'All rewards routed. Mission auto-closed.' : 'Mission closed. Back on the command deck.');
      renderAll();
    }

    function startMission(raid){
      const cost={energy:raid.energy,keys:raid.key||0};
      if(state.mission.active){
        setCodex('Mission already underway.');
        return;
      }
      if(state.travel.active){
        setCodex('Finish travel before launching a mission.');
        return;
      }
      if(isHubZone(state.zone)){
        setCodex('Cannot launch raids from a hub zone. Travel to a field site.');
        return;
      }
      if(!canAfford(cost)){
        setCodex('Not enough resources for that raid.');
        return;
      }
      startLoops();
      applyCost(cost);
      const now=Date.now();
      const durationMs=computeMissionDurationMs({risk:raid.risk,time:raid.time,loot:raid.loot});
      state.mission={
        active:true,
        type:'raid',
        raid,
        startedAt:now,
        endsAt:now+durationMs,
        completed:false,
        success:null,
        summary:'',
        rewards:[],
        statusMessage:`Mission launched: ${raid.label}.`,
        location:{...state.zone},
        fleeing:false,
        fleeEndsAt:null,
        pendingResolution:null,
        xpReward:computeMissionXp(raid.risk,raid.time),
        rewardEffects:{success:'',fail:''},
        questMeta:null,
        combat:null,
        sceneTarget:null
      };
      setCodex(`Mission launched: ${raid.label}.`);
      logMsg(`Mission launched: ${raid.label} (${raid.time} min op).`);
      setActiveTab('hub');
      setScreen('mission');
      normalizeMissionTiming(Date.now());
      renderAll();
    }

    function completeMission({combatResolved=false,forcedFail=false}={}){
      if(!state.mission.active || state.mission.completed) return;
      const missionType=state.mission.type;
      const raid=state.mission.raid;
      if(missionType==='combat'){
        const combat=state.mission.combat;
        if(combat && !combatResolved && !state.mission.fleeing && state.hp>0 && combat.enemiesRemaining>0){
          combat.nextTickAt=Date.now();
          combatTick(Date.now());
          if(!state.mission.completed) return;
        }
        const success=forcedFail ? false : (!state.mission.fleeing && state.hp>0 && (combat?.enemiesRemaining||0)<=0);
        const result=runCombatEncounter(raid,{success,fleeing:state.mission.fleeing});
        state.mission.completed=true;
        state.mission.success=result.success;
        state.mission.rewards=result.rewards;
        state.mission.summary=result.summary;
        state.mission.statusMessage=result.summary;
        if(state.hp<=0){
          applyEffects('hp+35,morale-12,energy-18','fail');
          state.mission.success=false;
          state.mission.summary='You collapse during the fight and are dragged to safety. Rewards are lost.';
          state.mission.statusMessage=state.mission.summary;
          state.mission.rewards=[];
        }
        if(state.mission.pendingResolution){
          const pendingRewards=state.mission.pendingResolution.rewards || [];
          pendingRewards.push(...result.rewards);
          state.mission.pendingResolution.rewards=pendingRewards;
          resolvePendingMission(result.success ? 'success' : 'fail');
          return;
        }
        setCodex(result.success ? 'Combat resolved. Rewards ready to review.' : 'Combat resolved. Regroup before redeploying.');
        renderAll();
        return;
      }

      if(missionType==='scene'){
        const rewards=[];
        const effectiveRisk=raid.risk || state.zone.risk;
        const failChance=computeFailChance(effectiveRisk);
        const success=Math.random()>failChance;
        const pending={
          label:raid.label,
          success,
          risk:effectiveRisk,
          xpReward:state.mission.xpReward,
          successEffects:state.mission.rewardEffects.success,
          failEffects:state.mission.rewardEffects.fail,
          flag:null,
          once:false
        };
        preparePendingResolution(pending,rewards);
        if(state.mission.sceneTarget){
          state.zone.sceneId=state.mission.sceneTarget;
        }
        resolvePendingMission(success ? 'success' : 'fail');
        return;
      }

      const rewards=[];
      const raidResult=runRaidInstant(raid,state.mission.location,{deferItemsTo:rewards});
      const success=raidResult.success;
      const effectiveRisk=raidResult.effectiveRisk || raid.risk;
      const pending={
        label:raid.label,
        success,
        risk:effectiveRisk,
        xpReward:state.mission.xpReward,
        successEffects:missionType==='contract' ? state.mission.rewardEffects.success : '',
        failEffects:missionType==='contract' ? state.mission.rewardEffects.fail : '',
        flag:missionType==='contract' ? state.mission.questMeta?.flag : null,
        once:missionType==='contract' ? state.mission.questMeta?.once : false
      };
      preparePendingResolution(pending,rewards);
      if(shouldTriggerCombat(effectiveRisk)){
        launchCombatFromPending(pending);
        return;
      }
      resolvePendingMission(success ? 'success' : 'fail');
    }

    function sellStashItem(item){
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      if(!canAccessMarket()){
        setCodex('Visit a shop to sell items.');
        return;
      }
      const data=getItem(item);
      removeItem(state.stash.items,item);
      state.credits+=data.value || 1;
      state.selected={source:null,item:null};
      renderAll();
    }

    function scrapStashItem(item){
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      const data=getItem(item);
      removeItem(state.stash.items,item);
      const salvage=data.salvage || Math.max(1,Math.floor((data.value || 1)/2));
      state.scrap+=salvage;
      state.selected={source:null,item:null};
      renderAll();
    }

    function bulkSellStash(){
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      if(!canAccessMarket()){
        setCodex('Visit a shop to sell items.');
        return;
      }
      state.stash.items.forEach(item=>{
        const data=getItem(item);
        state.credits+=data.value || 1;
      });
      state.stash.items=[];
      state.selected={source:null,item:null};
      renderAll();
    }

    function bulkScrapStash(){
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      state.stash.items.forEach(item=>{
        const data=getItem(item);
        const salvage=data.salvage || Math.max(1,Math.floor((data.value || 1)/2));
        state.scrap+=salvage;
      });
      state.stash.items=[];
      state.selected={source:null,item:null};
      renderAll();
    }

    function runCamp(){
      tickTime(ACTION_TIMES.camp);
      const gearMods=getGearMods();
      state.stamina=clamp(state.stamina+14,0,state.maxStamina);
      state.hp=clamp(state.hp+4,0,state.maxHp);
      state.morale=clamp(state.morale+4+(gearMods.moraleBonus||0),0,state.maxMorale);
      state.energy=clamp(state.energy+18+(gearMods.energyRegen||0),0,state.maxEnergy);
      state.hunger=clamp(state.hunger+3,0,state.maxHunger);
      state.thirst=clamp(state.thirst+3,0,state.maxThirst);
      state.bodyTemp=moveToward(state.bodyTemp,NORMAL_BODY_TEMP,4);
      logMsg('You bunker down, warm up, and recover energy.');
      rollComplication('camp');
      renderAll();
    }

    /* ================= EXPANSION LOADING ================= */
    function ensureExpansionsLoaded(){
      const needsReload=expansionsAttempted===0 || (expansionsLoaded===0 && expansionsAttempted>=expansionsExpected);
      if(dom.doors.children.length>0 && !needsReload) return;
      dom.doors.innerHTML='';
      loadGames();
    }

    async function loadGames(){
      let manifest=EXPANSION_MANIFEST;
      try{
        const res=await fetch('games.json',{cache:'no-store'});
        if(res.ok){
          const data=await res.json();
          if(Array.isArray(data.expansions) && data.expansions.length){
            manifest=data.expansions;
          }
        }
      }catch(err){
        console.warn('games.json unavailable, falling back to embedded manifest.',err);
      }
      expansionsExpected=manifest.length;
      expansionsLoaded=0;
      expansionsAttempted=0;
      dom.doors.innerHTML='';
      dom.doorsHint.textContent=manifest.length ? 'Loading expansions…' : 'No expansions configured.';
      manifest.forEach(meta=>loadExpansion(meta));
    }

    async function loadExpansion(meta){
      try{
        const res=await fetch(meta.file,{cache:'no-store'});
        if(!res.ok){
          throw new Error(`Expansion fetch failed: ${meta.file}`);
        }
        const raw=await res.text();
        const expansion=parseExpansion(raw);
        expansion.meta.id=meta.id || expansion.meta.id;
        expansion.meta.name=meta.name || expansion.meta.name || meta.id;
        expansions[expansion.meta.id]=expansion;
        addDoor(expansion);
        expansionsLoaded+=1;
        dom.doorsHint.textContent='';
        logMsg(`Door bolted on: ${expansion.meta.name}`);
      }catch(err){
        logMsg(`Failed to load ${meta.id}`);
        console.error(err);
      }finally{
        expansionsAttempted+=1;
        if(expansionsLoaded===0 && expansionsAttempted>=expansionsExpected){
          dom.doorsHint.textContent='Unable to load expansions.';
        }
      }
    }

    function addDoor(exp){
      const btn=document.createElement('button');
      btn.innerHTML=`<span>${exp.door?.label||exp.meta.name}</span><span class="small">${exp.door?.hint||'Unknown contact'}</span>`;
      btn.onclick=()=>{
        if(state.mission.active){
          setCodex('Mission in progress. Cannot change locations.');
          return;
        }
        if(state.travel.active){
          setCodex('Already rerouting. Stand by.');
          return;
        }
        const targetScene=exp.door?.target || Object.keys(exp.scenes || {})[0] || null;
        const target={
          id:exp.meta.id,
          name:exp.meta.name,
          risk:exp.door?.risk || 'low',
          desc:exp.door?.desc || exp.door?.hint || 'Salvage zone marked by strange chatter.',
          sceneId:targetScene
        };
        state.travel={
          active:true,
          endsAt:Date.now(),
          target
        };
        if(exp.door?.note) setCodex(exp.door.note);
        renderAll();
      };
      dom.doors.appendChild(btn);
    }

    function parseOption(str){
      // Format: Label => target | risk:low | time:10 | success:hp+5,credits+10 | fail:hp-5 | rad:1 | temp:1
      const segments=str.split('|').map(s=>s.trim()).filter(Boolean);
      const [labelPart,...rest]=segments;
      const [label,target]=labelPart.split('=>').map(s=>s&&s.trim());
      const opt={label:label||'Action',target:target||null,risk:'low',time:8,success:'',fail:'',rad:0,temp:0};
      rest.forEach(seg=>{
        const [k,vRaw]=seg.split(':');
        const v=vRaw?.trim();
        if(!k) return;
        const key=k.trim().toLowerCase();
        if(key==='risk') opt.risk=v;
        else if(key==='time') opt.time=Number(v||8);
        else if(key==='success') opt.success=v;
        else if(key==='fail') opt.fail=v;
        else if(key==='rad') opt.rad=Number(v||0);
        else if(key==='temp') opt.temp=Number(v||0);
      });
      return opt;
    }

    function parseExpansion(raw){
      const exp={meta:{},door:{},scenes:{},quests:[]};
      let scope='meta';
      let currentScene=null;
      let currentQuest=null;
      raw.split(/\r?\n/).forEach(line=>{
        line=line.trim();
        if(!line || line.startsWith('#')) return;
        if(line.startsWith('@expansion')){scope='meta';currentScene=null;currentQuest=null;return;}
        if(line.startsWith('@door')){scope='door';currentScene=null;currentQuest=null;return;}
        if(line.startsWith('@scene')){
          scope='scene';
          currentQuest=null;
          const id=line.split(/\s+/)[1] || `scene-${Object.keys(exp.scenes).length+1}`;
          currentScene={id,title:'',desc:'',tags:'',options:[]};
          exp.scenes[id]=currentScene;return;
        }
        if(line.startsWith('@quest')){
          scope='quest';
          currentScene=null;
          currentQuest={
            id:`quest-${exp.quests.length+1}`,
            title:'Special contract',
            desc:'',
            risk:'medium',
            time:10,
            success:'',
            fail:'',
            once:true,
            flag:''
          };
          exp.quests.push(currentQuest);
          return;
        }
        const [key,...rest]=line.split(':');
        const value=rest.join(':').trim();
        if(scope==='meta') exp.meta[key]=value;
        else if(scope==='door') exp.door[key]=value;
        else if(scope==='scene' && currentScene){
          if(key==='option') currentScene.options.push(parseOption(value));
          else if(key==='desc') currentScene.desc += (currentScene.desc?' ':'') + value;
          else currentScene[key]=value;
        }else if(scope==='quest' && currentQuest){
          if(key==='desc') currentQuest.desc += (currentQuest.desc?' ':'') + value;
          else if(key==='time') currentQuest.time=Number(value || 10);
          else if(key==='once') currentQuest.once=value !== 'false';
          else currentQuest[key]=value;
        }
      });
      return exp;
    }

    function renderAll(){
      renderBars();
      renderInventory();
      renderCrafting();
      renderExcursionStatus();
      renderHubAccess();
      renderTravelStatus();
      renderMissionStatus();
      renderIdleOps();
      renderZone();
      renderRaidActions();
      renderStash();
      renderItemDetails();
      setInventoryScreen(state.inventoryScreen);
      setStashScreen(state.stashScreen);
      renderScreens();
      syncTabs();
      queueSave();
    }

    function hideIntroModal(){
      if(!dom.introModal) return;
      dom.introModal.classList.add('hidden');
    }

    function showIntroModal({returning=false}={}){
      if(!dom.introModal || !dom.introActions || !dom.introMessage || !dom.introTitle) return;
      dom.introActions.innerHTML='';
      if(returning){
        dom.introTitle.textContent='Welcome back, runner';
        dom.introMessage.textContent='Your autosave is ready. Continue from your last loop or start fresh.';
        const continueBtn=document.createElement('button');
        continueBtn.textContent='Continue autosave';
        continueBtn.onclick=()=>{
          const latestState=loadSavedState();
          if(latestState) state=latestState;
          allowAutosave=true;
          hideIntroModal();
          renderAll();
          queueSave({force:true});
        };
        const restartBtn=document.createElement('button');
        restartBtn.textContent='Start fresh';
        restartBtn.classList.add('danger');
        restartBtn.onclick=()=>{
          localStorage.removeItem(SAVE_KEY);
          state=createDefaultState();
          allowAutosave=true;
          renderAll();
          queueSave({force:true});
          hideIntroModal();
        };
        dom.introActions.appendChild(continueBtn);
        dom.introActions.appendChild(restartBtn);
      }else{
        dom.introTitle.textContent='Fight, loot, survive.';
        dom.introMessage.textContent='Start a fresh loop or purge storage to reset everything.';
        const startBtn=document.createElement('button');
        startBtn.textContent='Start fresh';
        startBtn.onclick=()=>{
          allowAutosave=true;
          queueSave({force:true});
          hideIntroModal();
        };
        const resetBtn=document.createElement('button');
        resetBtn.textContent='Clear saves';
        resetBtn.classList.add('danger');
        resetBtn.onclick=()=>{
          localStorage.removeItem(SAVE_KEY);
          state=createDefaultState();
          allowAutosave=true;
          renderAll();
          queueSave({force:true});
          hideIntroModal();
        };
        dom.introActions.appendChild(startBtn);
        dom.introActions.appendChild(resetBtn);
      }
      dom.introModal.classList.remove('hidden');
    }

    /* ================= INIT ================= */
    let loopsStarted=false;
    function startLoops(){
      if(loopsStarted) return;
      loopsStarted=true;
      setInterval(ambientTick,6500);
      setInterval(updateTimers,250);
      setInterval(saveGame,60000);
      window.addEventListener('beforeunload',saveGame);
    }

    function initGame(){
      renderAll();
      loadGames();
      showIntroModal({returning:Boolean(savedState)});
      startLoops();
    }

    if(document.readyState==='loading'){
      document.addEventListener('DOMContentLoaded',initGame);
    }else{
      initGame();
    }

    function normalizeMissionTiming(now){
      if(!state.mission.active || state.mission.completed) return;
      const startedAt=Number.isFinite(state.mission.startedAt) ? state.mission.startedAt : now;
      if(!Number.isFinite(state.mission.endsAt)){
        state.mission.startedAt=startedAt;
        state.mission.endsAt=now+(MIN_MISSION_SECONDS*1000);
      }
      const maxDuration=MAX_MISSION_SECONDS*1000*MISSION_OVERRUN_MULTIPLIER;
      if(now-startedAt>maxDuration){
        state.mission.endsAt=now;
      }
    }

    function updateTimers(){
      if(resolveTravelIfComplete()){
        renderAll();
      }
      if(state.mission.active && !state.mission.completed){
        const now=Date.now();
        normalizeMissionTiming(now);
        if(state.mission.type==='combat'){
          combatTick(now);
          if(state.mission.fleeing && now>=state.mission.endsAt){
            completeMission({combatResolved:true});
          }else if(!state.mission.completed && !state.mission.fleeing && now>=state.mission.endsAt){
            completeMission({combatResolved:true,forcedFail:true});
          }
        }else if(now>=state.mission.endsAt){
          completeMission();
        }
      }
      if(state.mission.active){
        renderMissionStatus();
      }
      if(state.travel.active){
        renderTravelStatus();
      }
    }

    function ambientTick(){
      tickTime(4);
      if(state.idleOps.active){
        const elapsed=Date.now()-state.idleOps.startedAt;
        if(elapsed>=state.idleOps.durationMs){
          completeIdleOp();
          return;
        }
      }
      const gearMods=getGearMods();
      state.energy=clamp(state.energy+4+(gearMods.energyRegen||0),0,state.maxEnergy);
      state.hunger=clamp(state.hunger+1,0,state.maxHunger);
      state.thirst=clamp(state.thirst+1,0,state.maxThirst);
      const inHub=state.screen==='main' || state.screen==='locations';
      if(inHub){
        state.bodyTemp=moveToward(state.bodyTemp,NORMAL_BODY_TEMP,1.6);
      }else{
        const insulation=gearMods.insulation || 0;
        const loss=Math.max(0.4,1.3-insulation);
        state.bodyTemp=clamp(state.bodyTemp-loss,BODY_TEMP_MIN,BODY_TEMP_MAX);
      }
      if(state.hunger>=90){
        applyEffects('hp-3,morale-2','fail');
        logMsg('Starvation gnaws at you while you hesitate.');
      }
      if(state.thirst>=90){
        applyEffects('hp-4,stamina-5','fail');
        logMsg('Dehydration blurs your vision.');
      }
      if(state.bodyTemp<=92){
        applyEffects('hp-2,stamina-3','fail');
        if(state.timeMinutes%60===0){
          logMsg('Cold seeps into your limbs. Find shelter or warm up soon.');
        }
      }
      if(state.bodyTemp>=103){
        applyEffects('hp-2,morale-2','fail');
        if(state.timeMinutes%60===0){
          logMsg('Heat haze clouds your focus. Cool down before it worsens.');
        }
      }
      rollComplication('idle time');
      renderAll();
    }

  </script>
</body>
</html>
