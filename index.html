<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Zero Lux - Salvage Loop</title>
  <style>
    :root{
      color-scheme: dark;
      --bg:#0c0c0f;
      --panel:#121219;
      --panel-2:#191925;
      --accent:#5bd1ff;
      --accent-2:#8fffa3;
      --danger:#ff6b6b;
      --muted:#a7b0c0;
      --border:#202232;
      --shadow:0 10px 40px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box;}
    body{
      margin:0;min-height:100vh;background:radial-gradient(circle at 20% 20%, rgba(70,120,255,.08), transparent 35%),
      radial-gradient(circle at 80% 0%, rgba(80,255,200,.06), transparent 30%),
      var(--bg);
      color:#e8edf7;font-family:"Inter",system-ui,-apple-system,sans-serif;
      line-height:1.45;
      padding:12px;
    }
    #app{max-width:1200px;margin:auto;display:flex;flex-direction:column;gap:12px;}
    header{display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between;padding:14px 16px;background:var(--panel);border:1px solid var(--border);border-radius:12px;box-shadow:var(--shadow);position:sticky;top:0;z-index:3;backdrop-filter:blur(6px);}
    .title{font-size:20px;font-weight:700;letter-spacing:0.5px;display:flex;align-items:center;gap:8px;}
    .tagline{font-size:13px;color:var(--muted);}
    .pill{border:1px solid var(--border);border-radius:999px;padding:6px 10px;font-size:12px;color:var(--muted);background:rgba(255,255,255,0.02);}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:14px 16px;box-shadow:var(--shadow);}
    .panel h3{margin:0 0 6px;font-size:15px;letter-spacing:0.4px;}
    .grid-two{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:10px;}
    .statline{display:grid;grid-template-columns:110px 1fr 60px;align-items:center;font-size:13px;gap:8px;padding:6px 0;border-bottom:1px solid rgba(255,255,255,0.03);}    
    .bar{height:8px;background:#0f111a;border-radius:999px;overflow:hidden;border:1px solid #16182a;}
    .bar span{display:block;height:100%;border-radius:999px;}
    .bar.hp span{background:linear-gradient(90deg,#ff7a7a,#ffb36b);}    
    .bar.stamina span{background:linear-gradient(90deg,#71d2ff,#82ffa4);}    
    .bar.morale span{background:linear-gradient(90deg,#8aa9ff,#c3a1ff);}    
    .bar.rads span{background:linear-gradient(90deg,#80ffd3,#fffd8a);}    
    .bar.hunger span{background:linear-gradient(90deg,#ffc46a,#ff8c8c);}    
    .bar.thirst span{background:linear-gradient(90deg,#6ad8ff,#7f9cff);}    
    .rows{display:flex;flex-direction:column;gap:8px;}
    .meta{color:var(--muted);font-size:13px;display:flex;flex-wrap:wrap;gap:10px;}
    .meta b{color:#e8edf7;margin-right:4px;}
    .pill-inline{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;border:1px solid var(--border);background:rgba(255,255,255,0.03);font-size:12px;color:var(--muted);}    
    button{appearance:none;border:1px solid var(--border);background:var(--panel-2);color:#f6f7ff;border-radius:10px;padding:10px 12px;font-size:14px;text-align:left;cursor:pointer;transition:transform .05s ease, border .15s ease;display:flex;justify-content:space-between;align-items:center;gap:6px;min-height:46px;}
    button:hover{transform:translateY(-1px);border-color:var(--accent);}    
    button:active{transform:translateY(0);}
    .btn-secondary{background:#0f111a;}
    .danger{border-color:rgba(255,107,107,.6);color:#ffc2c2;}
    #doors,#raidActions{display:flex;flex-direction:column;gap:8px;}
    .log{white-space:pre-wrap;font-size:13px;color:#d8e1ff;line-height:1.35;max-height:320px;overflow:auto;padding:10px;background:#0f111a;border:1px solid var(--border);border-radius:12px;box-shadow:inset 0 0 0 1px rgba(255,255,255,0.02);}
    .small{font-size:12px;color:var(--muted);}
    .scene-title{font-size:17px;margin:0;color:#e8f1ff;}
    .scene-desc{margin:6px 0 10px;color:#cfd8ec;font-size:14px;}
    .badge{font-size:12px;border-radius:8px;padding:2px 8px;background:rgba(91,209,255,.08);border:1px solid rgba(91,209,255,.45);color:var(--accent-2);display:inline-flex;gap:6px;align-items:center;}
    .inline{display:flex;flex-wrap:wrap;gap:8px;align-items:center;}
    .inventory{display:flex;flex-wrap:wrap;gap:6px;margin-bottom:8px;}
    .inventory button{border:1px solid var(--border);padding:8px 10px;border-radius:10px;background:rgba(255,255,255,0.02);font-size:13px;cursor:pointer;}
    .inventory button:hover{border-color:var(--accent);}
    .inventory h4{margin:4px 0;font-size:13px;color:#cfd8ec;width:100%;}
    .inventory .pill-inline{margin-top:4px;}
    .inventory .inline-actions{width:100%;display:flex;flex-wrap:wrap;gap:6px;align-items:center;}
    .two-col{display:grid;grid-template-columns:1.1fr 1fr;gap:12px;}
    .tabs{background:var(--panel);border:1px solid var(--border);border-radius:12px;box-shadow:var(--shadow);}
    .tab-buttons{display:flex;gap:8px;padding:10px 12px;border-bottom:1px solid var(--border);flex-wrap:wrap;background:rgba(255,255,255,0.02);border-radius:12px 12px 0 0;}
    .tab-buttons button{flex:1 1 120px;text-align:center;justify-content:center;border-radius:10px;padding:10px 12px;border:1px solid var(--border);background:#0f111a;color:#e8edf7;min-height:40px;}
    .tab-buttons button.active{border-color:var(--accent);background:rgba(91,209,255,0.08);}
    .tab-buttons button:disabled{opacity:0.35;cursor:not-allowed;border-style:dashed;}
    .tab-content{display:none;padding:12px;}
    .tab-content.active{display:block;}
    .muted-box{padding:14px 16px;border-radius:10px;border:1px dashed var(--border);color:var(--muted);background:rgba(255,255,255,0.03);}
    .stack{display:flex;flex-direction:column;gap:12px;}
    .excursion-status{font-size:13px;color:var(--muted);display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
    .excursion-status b{color:#e8edf7;}
    .progress{height:10px;border-radius:999px;background:#0f111a;border:1px solid #1c1f32;overflow:hidden;}
    .progress span{display:block;height:100%;background:linear-gradient(90deg,#5bd1ff,#8fffa3);border-radius:999px;transition:width .2s ease;}
    .op-card{border:1px solid var(--border);border-radius:12px;padding:12px;background:rgba(255,255,255,0.02);display:flex;flex-direction:column;gap:8px;}
    .op-meta{display:flex;flex-wrap:wrap;gap:8px;color:var(--muted);font-size:12px;}
    .op-actions{display:flex;gap:8px;flex-wrap:wrap;}
    .item-grid{display:flex;flex-direction:column;gap:10px;}
    .item-row{display:flex;flex-wrap:wrap;align-items:center;gap:8px;padding:10px;border:1px solid var(--border);border-radius:10px;background:rgba(255,255,255,0.02);}
    .item-name{font-weight:600;}
    .item-meta{font-size:12px;color:var(--muted);}
    .item-actions{display:flex;flex-wrap:wrap;gap:6px;margin-left:auto;}
    .chip{border:1px solid var(--border);border-radius:999px;padding:2px 8px;font-size:11px;color:var(--muted);}
    .chip.common{color:#cfd8ec;}
    .chip.uncommon{color:#8fffa3;}
    .chip.rare{color:#5bd1ff;}
    .chip.epic{color:#c3a1ff;}
    .chip.legendary{color:#ffcf6a;}
    @media(max-width:900px){header{position:static;} .two-col{grid-template-columns:1fr;} .tab-buttons button{flex:1 1 100%;}}
  </style>
</head>
<body>
  <div id="app">
    <header>
      <div>
        <div class="title">Zero Lux Salvage Loop <span class="pill">inventory / looter / idle</span></div>
        <div class="tagline">Pick zones, run salvage loops, and sort haul into gear, stash, or scrap.</div>
      </div>
      <div class="pill">Build #: 0.2b — inventory-focused loop</div>
    </header>

    <section class="panel">
      <div class="two-col">
        <div>
          <h3>Status Board</h3>
          <div id="stats"></div>
          <div class="meta" id="meta"></div>
        </div>
        <div class="rows">
          <div class="excursion-status" id="excursionStatus"></div>
          <div class="muted-box" id="tempoHint"></div>
        </div>
      </div>
    </section>

    <div class="tabs">
      <div class="tab-buttons">
        <button data-tab="hub" class="active">Operations</button>
        <button data-tab="inventory">Backpack</button>
        <button data-tab="field">Stash</button>
        <button data-tab="log">Signal Log</button>
      </div>
      <div id="tab-hub" class="tab-content active">
        <div class="stack">
          <section class="panel">
            <h3>Zone Gates</h3>
            <div id="doors"></div>
            <div class="small" id="doorsHint">Loading expansions…</div>
          </section>
          <section class="panel">
            <div class="inline" style="justify-content:space-between;align-items:center;">
              <div>
                <p class="scene-title" id="zoneTitle">Drift Yard</p>
                <p class="scene-desc" id="zoneDesc">Low-risk salvage corridor. Ideal for stocking up on scrap and common gear.</p>
              </div>
              <span class="badge" id="zoneBadge">Low risk</span>
            </div>
            <div id="raidActions"></div>
          </section>
          <section class="panel">
            <h3>Incoming Haul</h3>
            <div id="haul"></div>
          </section>
          <section class="panel">
            <h3>Idle Operations</h3>
            <div id="idleOps"></div>
          </section>
          <div class="muted-box" id="hubLock"></div>
        </div>
      </div>
      <div id="tab-inventory" class="tab-content">
        <section class="panel">
          <h3>Backpack & Loadout</h3>
          <div class="inventory" id="inventory"></div>
          <div class="small" id="codex"></div>
        </section>
      </div>
      <div id="tab-field" class="tab-content">
        <section class="panel">
          <h3>Stash Vault</h3>
          <div id="stash"></div>
          <div id="stashActions"></div>
          <p class="small">Move loot from the haul into long-term storage, or liquidate overflow for credits.</p>
        </section>
      </div>
      <div id="tab-log" class="tab-content">
        <section class="panel">
          <h3>Signal Log</h3>
          <div id="log" class="log"></div>
        </section>
      </div>
    </div>
  </div>

  <script>
    /* ================= STATE & CONSTANTS ================= */
    const state={
      hp:92,maxHp:100,
      stamina:90,maxStamina:100,
      morale:62,maxMorale:100,
      hunger:15,maxHunger:100,
      thirst:20,maxThirst:100,
      energy:72,maxEnergy:100,
      rads:0,heat:0,
      signal:12,maxSignal:120,
      scrap:6,
      credits:50,
      fuel:4,
      keys:1,
      day:1,timeMinutes:6*60,
      backpackLimit:12,
      stashLimit:40,
      inventory:["rusty flashlight","ration bar","scrap wiring"],
      equipped:[],
      codex:["Hub online. Haul bays clear."],
      stash:{name:'Vault Stash',items:[]},
      lootQueue:[],
      autoSalvage:false,
      idleOps:{active:false,id:null,startedAt:null,durationMs:0,etaMinutes:0},
      flags:new Set(),
      log:["Systems cold-started. Zones awaiting tether…"],
      zone:{id:'drift-yard',name:'Drift Yard',risk:'low',desc:'Low-risk salvage corridor. Ideal for stocking up on scrap and common gear.'}
    };

    const ITEM_CATALOG={
      'rusty flashlight':{type:'tool',rarity:'common',value:6,mods:{riskMod:-0.02,signalBonus:1}},
      'flare':{type:'tool',rarity:'uncommon',value:10,mods:{lootBonus:0.04}},
      'patch kit':{type:'tool',rarity:'uncommon',value:12,mods:{riskMod:-0.04}},
      'microcell':{type:'tool',rarity:'rare',value:22,mods:{idleSpeed:0.15,energyRegen:1,staminaBonus:2}},
      'bandage':{type:'consumable',rarity:'common',value:4,effect:'hp+8'},
      'ration bar':{type:'consumable',rarity:'common',value:3,effect:'hunger-12,morale+2'},
      'water flask':{type:'consumable',rarity:'common',value:4,effect:'thirst-12'},
      'spark tonic':{type:'consumable',rarity:'uncommon',value:8,effect:'energy+18,stamina+6'},
      'scrap wiring':{type:'junk',rarity:'common',value:2,salvage:2},
      'old coin':{type:'junk',rarity:'uncommon',value:6,salvage:1},
      'lockbox key':{type:'key',rarity:'rare',value:18},
      'signal prism':{type:'junk',rarity:'rare',value:20,salvage:6},
      'drone core':{type:'tool',rarity:'epic',value:32,mods:{lootBonus:0.08,energyRegen:2}},
      'relic shard':{type:'junk',rarity:'legendary',value:60,salvage:12}
    };

    const LOOT_BY_RARITY={
      common:['bandage','ration bar','water flask','scrap wiring','rusty flashlight'],
      uncommon:['flare','patch kit','old coin','spark tonic'],
      rare:['microcell','lockbox key','signal prism'],
      epic:['drone core'],
      legendary:['relic shard']
    };

    const RAID_TEMPLATES=[
      {id:'quick',label:'Quick Grab',desc:'Fast sweep for low-tier gear.',time:6,energy:8,loot:2,risk:'low'},
      {id:'deep',label:'Deep Sweep',desc:'Longer push with higher-value crates.',time:12,energy:14,loot:3,risk:'medium'},
      {id:'hazard',label:'Hazard Drift',desc:'Pressurized route for rare tech.',time:16,energy:18,loot:4,risk:'high'},
      {id:'vault',label:'Lockbox Crack',desc:'Spend a key to crack sealed cache.',time:10,energy:10,loot:3,risk:'high',key:1}
    ];

    const ACTION_TIMES={camp:10,trade:8};
    const riskTable={low:0.08,medium:0.2,high:0.32,deadly:0.45};
    const riskRank={low:1,medium:2,high:3,deadly:4};
    const expansions={};
    const idleOperations=[
      {id:'salvage',label:'Drone salvage',desc:'Remote drones bring back scrap and junk.',duration:7,cost:{credits:8},reward:'scrap+3,item:scrap wiring'},
      {id:'survey',label:'Signal sweep',desc:'Low-risk sweep for signals and maps.',duration:5,cost:{credits:5},reward:'signal+8,credits+2'},
      {id:'resupply',label:'Supply errand',desc:'Courier route for field medicine.',duration:9,cost:{credits:10,scrap:1},reward:'item:bandage,item:water flask'}
    ];

    const dom={
      stats:document.getElementById('stats'),
      meta:document.getElementById('meta'),
      excursionStatus:document.getElementById('excursionStatus'),
      tempoHint:document.getElementById('tempoHint'),
      doors:document.getElementById('doors'),
      doorsHint:document.getElementById('doorsHint'),
      zoneTitle:document.getElementById('zoneTitle'),
      zoneDesc:document.getElementById('zoneDesc'),
      zoneBadge:document.getElementById('zoneBadge'),
      raidActions:document.getElementById('raidActions'),
      haul:document.getElementById('haul'),
      inventory:document.getElementById('inventory'),
      codex:document.getElementById('codex'),
      log:document.getElementById('log'),
      idleOps:document.getElementById('idleOps'),
      hubLock:document.getElementById('hubLock'),
      stash:document.getElementById('stash'),
      stashActions:document.getElementById('stashActions'),
      tabs:document.querySelector('.tabs'),
      tabButtons:Array.from(document.querySelectorAll('.tab-buttons button')),
      tabContents:{
        hub:document.getElementById('tab-hub'),
        inventory:document.getElementById('tab-inventory'),
        field:document.getElementById('tab-field'),
        log:document.getElementById('tab-log')
      }
    };

    let activeTab='hub';

    /* ================= UTILITIES ================= */
    const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
    const pct=(v,max)=>Math.round((v/max)*100);
    const fmtTime=(mins)=>{
      const m=mins%60;const h=Math.floor(mins/60)%24;const suffix=h>=12?"PM":"AM";
      const hour=((h+11)%12+1);return `${hour}:${m.toString().padStart(2,'0')} ${suffix}`;
    }
    const setCodex=(msg)=>{ state.codex=[msg]; };
    const logMsg=(msg)=>{
      const stamp=`[Day ${state.day} // ${fmtTime(state.timeMinutes)}] ${msg}`;
      state.log.unshift(stamp);
      state.log=state.log.slice(0,14);
      renderLog();
    }

    const removeItem=(arr,item)=>{const idx=arr.indexOf(item); if(idx>=0) arr.splice(idx,1);};
    const getItem=(id)=>ITEM_CATALOG[id] || {type:'junk',rarity:'common',value:1};
    const groupItems=(items)=>{
      const tally=items.reduce((acc,item)=>{
        acc[item]=(acc[item]||0)+1;
        return acc;
      },{});
      return Object.entries(tally).map(([id,count])=>({id,count,data:getItem(id)}));
    };
    const rollLootItem=(risk,bonus=0)=>{
      const roll=Math.random();
      const bias={
        low:{common:0.7,uncommon:0.22,rare:0.07,epic:0.009,legendary:0.001},
        medium:{common:0.55,uncommon:0.28,rare:0.13,epic:0.035,legendary:0.005},
        high:{common:0.4,uncommon:0.3,rare:0.18,epic:0.09,legendary:0.03},
        deadly:{common:0.3,uncommon:0.28,rare:0.2,epic:0.14,legendary:0.08}
      };
      const dist=bias[risk] || bias.low;
      const adjusted={
        common:Math.max(0.05,dist.common-(bonus*0.5)),
        uncommon:dist.uncommon+(bonus*0.2),
        rare:dist.rare+(bonus*0.2),
        epic:dist.epic+(bonus*0.08),
        legendary:dist.legendary+(bonus*0.02)
      };
      const rollTable=[
        ['common',adjusted.common],
        ['uncommon',adjusted.uncommon],
        ['rare',adjusted.rare],
        ['epic',adjusted.epic],
        ['legendary',adjusted.legendary]
      ];
      let cursor=0;
      for(const [rarity,weight] of rollTable){
        cursor+=weight;
        if(roll<=cursor){
          const pool=LOOT_BY_RARITY[rarity];
          return pool[Math.floor(Math.random()*pool.length)];
        }
      }
      return 'scrap wiring';
    };
    const getGearMods=()=>{
      return state.equipped.reduce((acc,item)=>{
        const mod=getItem(item).mods;
        if(!mod) return acc;
        Object.entries(mod).forEach(([key,val])=>{
          acc[key]=(acc[key]||0)+val;
        });
        return acc;
      },{});
    };
    const formatCost=(cost)=>Object.entries(cost).map(([k,v])=>`${v} ${k}`).join(' · ');
    const canAfford=(cost)=>Object.entries(cost).every(([k,v])=>state[k]>=v);
    const applyCost=(cost)=>{
      Object.entries(cost).forEach(([k,v])=>{
        state[k]=Math.max(0,state[k]-v);
      });
    };
    const addToArray=(arr,item)=>{arr.push(item);};
    const equipmentLimit=4;

    function equipItem(item){
      if(state.equipped.includes(item)) return;
      if(state.equipped.length>=equipmentLimit){
        setCodex('Loadout full. Unequip something first.');
        return;
      }
      const data=getItem(item);
      if(!['tool','armor'].includes(data.type)){
        setCodex('Only tools or armor can be equipped.');
        return;
      }
      removeItem(state.inventory,item);
      state.equipped.push(item);
      setCodex(`${item} equipped.`);
      logMsg(`Equipped ${item}.`);
      renderAll();
    }
    function unequipItem(item){
      removeItem(state.equipped,item);
      state.inventory.push(item);
      setCodex(`${item} stowed.`);
      logMsg(`Unequipped ${item}.`);
      renderAll();
    }
    function consumeItem(item){
      const data=getItem(item);
      if(data.effect){
        applyEffects(data.effect,'success');
      }
      removeItem(state.inventory,item);
      logMsg(`Consumed ${item}.`);
      setCodex(`${item} used.`);
      renderAll();
    }
    function stashItem(item){
      if(state.stash.items.length>=state.stashLimit){
        setCodex('Stash is full.');
        return;
      }
      removeItem(state.inventory,item);
      state.stash.items.push(item);
      setCodex(`${item} stored in ${state.stash.name}.`);
      logMsg(`Stored ${item} in ${state.stash.name}.`);
      renderAll();
    }
    function unstashItem(item){
      if(state.inventory.length>=state.backpackLimit){
        setCodex('Backpack full.');
        return;
      }
      removeItem(state.stash.items,item);
      state.inventory.push(item);
      setCodex(`${item} withdrawn from ${state.stash.name}.`);
      logMsg(`Retrieved ${item} from ${state.stash.name}.`);
      renderAll();
    }
    function sellItem(item){
      const data=getItem(item);
      removeItem(state.inventory,item);
      state.credits+=data.value || 1;
      logMsg(`Sold ${item} for ${data.value || 1} credits.`);
      renderAll();
    }
    function dismantleItem(item){
      const data=getItem(item);
      removeItem(state.inventory,item);
      const salvage=data.salvage || Math.max(1,Math.floor((data.value || 1)/2));
      state.scrap+=salvage;
      logMsg(`Dismantled ${item} for ${salvage} scrap.`);
      renderAll();
    }

    function startIdleOp(opId){
      if(state.idleOps.active){
        setCodex('An idle operation is already underway.');
        return;
      }
      const op=idleOperations.find(entry=>entry.id===opId);
      if(!op) return;
      if(!canAfford(op.cost)){
        setCodex('Insufficient resources for this operation.');
        return;
      }
      applyCost(op.cost);
      const gearMods=getGearMods();
      const speedMod=gearMods.idleSpeed || 0;
      const duration=Math.max(3,op.duration*(1-speedMod));
      state.idleOps={
        active:true,
        id:opId,
        startedAt:Date.now(),
        durationMs:duration*60000,
        etaMinutes:duration
      };
      logMsg(`Idle op launched: ${op.label}. ETA ${duration.toFixed(1)} mins.`);
      renderAll();
    }

    function completeIdleOp(){
      const op=idleOperations.find(entry=>entry.id===state.idleOps.id);
      if(!op) return;
      applyEffects(op.reward,'success');
      state.idleOps={active:false,id:null,startedAt:null,durationMs:0,etaMinutes:0};
      logMsg(`Idle op complete: ${op.label}.`);
      setCodex(`Idle op returned with results: ${op.reward}.`);
      renderAll();
    }

    /* ================= RENDERING ================= */
    function renderBars(){
      const rows=[
        ['HP','hp','maxHp','hp'],
        ['Stamina','stamina','maxStamina','stamina'],
        ['Morale','morale','maxMorale','morale'],
        ['Energy','energy','maxEnergy','stamina'],
        ['Hunger','hunger','maxHunger','hunger'],
        ['Hydration','thirst','maxThirst','thirst'],
        ['Radiation','rads',100,'rads']
      ];
      dom.stats.innerHTML=rows.map(([label,key,maxKey,cls])=>{
        const val=state[key];const max=(typeof maxKey==='string')?state[maxKey]:maxKey;
        const percent=clamp(pct(val,max),0,200);
        return `<div class="statline"><div>${label}</div><div class="bar ${cls}"><span style="width:${percent}%;"></span></div><div>${Math.round(val)}/${max}</div></div>`;
      }).join('');
      dom.meta.innerHTML=`<span class="pill-inline"><b>Credits</b>${state.credits}</span>`+
        `<span class="pill-inline"><b>Scrap</b>${state.scrap}</span>`+
        `<span class="pill-inline"><b>Fuel</b>${state.fuel}</span>`+
        `<span class="pill-inline"><b>Keys</b>${state.keys}</span>`+
        `<span class="pill-inline"><b>Heat</b>${state.heat}</span>`+
        `<span class="pill-inline"><b>Pressure</b>${Math.round(calcPressure()*100)}%</span>`+
        `<span class="pill-inline"><b>Signal</b>${state.signal}/${state.maxSignal}</span>`+
        `<span class="pill-inline"><b>Time</b>${fmtTime(state.timeMinutes)}</span>`+
        `<span class="pill-inline"><b>Day</b>${state.day}</span>`;
    }

    function renderInventory(){
      dom.inventory.innerHTML='';
      const buildSection=(title,items,emptyText,actionsBuilder)=>{
        const wrap=document.createElement('div');
        wrap.className='item-grid';
        const heading=document.createElement('h4');
        heading.textContent=title;
        wrap.appendChild(heading);
        if(!items.length){
          const span=document.createElement('span');
          span.className='small';
          span.textContent=emptyText;
          wrap.appendChild(span);
        }else{
          groupItems(items).forEach(({id,count,data})=>{
            const row=document.createElement('div');
            row.className='item-row';
            const name=document.createElement('div');
            name.className='item-name';
            name.textContent=`${id} ×${count}`;
            const meta=document.createElement('div');
            meta.className='item-meta';
            meta.textContent=`${data.type} · ${data.value || 1} cr`;
            const chip=document.createElement('span');
            chip.className=`chip ${data.rarity}`;
            chip.textContent=data.rarity;
            const actions=document.createElement('div');
            actions.className='item-actions';
            actionsBuilder(id,data,actions);
            row.appendChild(name);
            row.appendChild(chip);
            row.appendChild(meta);
            row.appendChild(actions);
            wrap.appendChild(row);
          });
        }
        dom.inventory.appendChild(wrap);
      };

      buildSection(`Equipped Loadout (${state.equipped.length}/${equipmentLimit})`,state.equipped,'Nothing equipped yet.',(id,data,actions)=>{
        const btn=document.createElement('button');
        btn.textContent='Unequip';
        btn.onclick=()=>unequipItem(id);
        actions.appendChild(btn);
      });

      buildSection(`Backpack (${state.inventory.length}/${state.backpackLimit})`,state.inventory,'No gear collected.',(id,data,actions)=>{
        if(['tool','armor'].includes(data.type)){
          const equip=document.createElement('button');
          equip.textContent='Equip';
          equip.onclick=()=>equipItem(id);
          actions.appendChild(equip);
        }
        if(data.type==='consumable'){
          const use=document.createElement('button');
          use.textContent='Use';
          use.onclick=()=>consumeItem(id);
          actions.appendChild(use);
        }
        const stashBtn=document.createElement('button');
        stashBtn.textContent='Stash';
        stashBtn.onclick=()=>stashItem(id);
        actions.appendChild(stashBtn);
        const sell=document.createElement('button');
        sell.textContent='Sell';
        sell.onclick=()=>sellItem(id);
        actions.appendChild(sell);
        const dismantle=document.createElement('button');
        dismantle.textContent='Scrap';
        dismantle.onclick=()=>dismantleItem(id);
        actions.appendChild(dismantle);
      });

      dom.codex.textContent = state.codex[state.codex.length-1] || '';
    }

    function renderLog(){
      dom.log.textContent=state.log.join('\n');
    }

    function renderIdleOps(){
      dom.idleOps.innerHTML='';
      const gearMods=getGearMods();
      if(state.idleOps.active){
        const op=idleOperations.find(entry=>entry.id===state.idleOps.id);
        const elapsed=Math.max(0,(Date.now()-state.idleOps.startedAt)/1000);
        const total=state.idleOps.durationMs/1000;
        const pctDone=clamp((elapsed/total)*100,0,100);
        const card=document.createElement('div');
        card.className='op-card';
        const title=document.createElement('div');
        title.innerHTML=`<b>${op.label}</b> · in progress`;
        const progress=document.createElement('div');
        progress.className='progress';
        progress.innerHTML=`<span style="width:${pctDone}%;"></span>`;
        const meta=document.createElement('div');
        meta.className='op-meta';
        const remaining=Math.max(0,Math.ceil((total-elapsed)/60));
        meta.textContent=`ETA ${remaining} min · ${op.desc}`;
        card.appendChild(title);
        card.appendChild(progress);
        card.appendChild(meta);
        dom.idleOps.appendChild(card);
        return;
      }
      idleOperations.forEach(op=>{
        const card=document.createElement('div');
        card.className='op-card';
        const title=document.createElement('div');
        title.innerHTML=`<b>${op.label}</b>`;
        const meta=document.createElement('div');
        meta.className='op-meta';
        const duration=Math.max(3,op.duration*(1-(gearMods.idleSpeed||0)));
        meta.textContent=`${op.desc} · ${duration.toFixed(1)} min`;
        const cost=document.createElement('div');
        cost.className='op-meta';
        cost.textContent=`Cost: ${formatCost(op.cost)} · Reward: ${op.reward}`;
        const actions=document.createElement('div');
        actions.className='op-actions';
        const btn=document.createElement('button');
        btn.textContent='Dispatch';
        btn.onclick=()=>startIdleOp(op.id);
        if(!canAfford(op.cost)) btn.disabled=true;
        actions.appendChild(btn);
        card.appendChild(title);
        card.appendChild(meta);
        card.appendChild(cost);
        card.appendChild(actions);
        dom.idleOps.appendChild(card);
      });
    }

    function setActiveTab(tab){
      activeTab=tab;
      syncTabs();
    }

    function syncTabs(){
      dom.tabButtons.forEach(btn=>{
        const target=btn.dataset.tab;
        btn.classList.toggle('active',target===activeTab);
        btn.disabled=false;
      });
      Object.entries(dom.tabContents).forEach(([id,el])=>{
        el.classList.toggle('active',id===activeTab);
      });
    }

    dom.tabButtons.forEach(btn=>{
      btn.onclick=()=>{ activeTab=btn.dataset.tab; syncTabs(); };
    });

    function renderExcursionStatus(){
      dom.excursionStatus.innerHTML=`<b>Loop status:</b> Energy ${state.energy}/${state.maxEnergy} · Backpack ${state.inventory.length}/${state.backpackLimit} · Haul ${state.lootQueue.length} · Stash ${state.stash.items.length}/${state.stashLimit}.`;
      dom.tempoHint.textContent=state.autoSalvage
        ? 'Auto-salvage running. Energy drains into quick grabs every few ticks.'
        : 'Spend energy on raids, then sort the incoming haul into backpack or stash.';
    }

    function renderHubAccess(){
      dom.hubLock.textContent='Ops bay is live. Pick a zone gate, run raids, and keep the haul moving.';
    }

    function renderZone(){
      dom.zoneTitle.textContent=state.zone.name;
      dom.zoneDesc.textContent=state.zone.desc;
      dom.zoneBadge.textContent=`${state.zone.risk} risk`;
    }

    function renderRaidActions(){
      dom.raidActions.innerHTML='';
      const gearMods=getGearMods();
      RAID_TEMPLATES.forEach(raid=>{
        const btn=document.createElement('button');
        const costParts=[`${raid.energy} energy`];
        if(raid.key) costParts.push(`${raid.key} key`);
        btn.innerHTML=`<span>${raid.label}</span><span class="small">${raid.risk} · ${raid.time} min · ${costParts.join(' · ')}</span>`;
        btn.onclick=()=>runRaid(raid);
        if(!canAfford({energy:raid.energy,keys:raid.key||0})) btn.disabled=true;
        if(raid.risk==='high') btn.classList.add('danger');
        dom.raidActions.appendChild(btn);
      });
      const rest=document.createElement('button');
      rest.innerHTML=`<span>Make camp</span><span class="small">recover · ${ACTION_TIMES.camp} min</span>`;
      rest.onclick=runCamp;
      dom.raidActions.appendChild(rest);
      const trade=document.createElement('button');
      trade.innerHTML=`<span>Cash in signal</span><span class="small">trade · ${ACTION_TIMES.trade} min</span>`;
      trade.onclick=burnSignal;
      dom.raidActions.appendChild(trade);
      const fuel=document.createElement('button');
      fuel.innerHTML='<span>Burn fuel cell</span><span class="small">boost · instant</span>';
      fuel.onclick=burnFuel;
      if(state.fuel<=0) fuel.disabled=true;
      dom.raidActions.appendChild(fuel);
      const auto=document.createElement('button');
      auto.textContent=state.autoSalvage?'Disable auto-salvage':'Enable auto-salvage';
      auto.onclick=()=>{
        state.autoSalvage=!state.autoSalvage;
        logMsg(state.autoSalvage?'Auto-salvage engaged.':'Auto-salvage disabled.');
        renderAll();
      };
      dom.raidActions.appendChild(auto);
    }

    function renderHaul(){
      dom.haul.innerHTML='';
      if(!state.lootQueue.length){
        dom.haul.innerHTML='<div class="muted-box">No loot waiting. Run a raid to generate a haul.</div>';
        return;
      }
      const grid=document.createElement('div');
      grid.className='item-grid';
      groupItems(state.lootQueue).forEach(({id,count,data})=>{
        const row=document.createElement('div');
        row.className='item-row';
        const name=document.createElement('div');
        name.className='item-name';
        name.textContent=`${id} ×${count}`;
        const meta=document.createElement('div');
        meta.className='item-meta';
        meta.textContent=`${data.type} · ${data.value || 1} cr`;
        const chip=document.createElement('span');
        chip.className=`chip ${data.rarity}`;
        chip.textContent=data.rarity;
        const actions=document.createElement('div');
        actions.className='item-actions';
        const pack=document.createElement('button');
        pack.textContent='Pack';
        pack.onclick=()=>moveLootItem(id,'inventory');
        const stash=document.createElement('button');
        stash.textContent='Stash';
        stash.onclick=()=>moveLootItem(id,'stash');
        const sell=document.createElement('button');
        sell.textContent='Sell';
        sell.onclick=()=>sellLootItem(id);
        const scrap=document.createElement('button');
        scrap.textContent='Scrap';
        scrap.onclick=()=>scrapLootItem(id);
        actions.appendChild(pack);
        actions.appendChild(stash);
        actions.appendChild(sell);
        actions.appendChild(scrap);
        row.appendChild(name);
        row.appendChild(chip);
        row.appendChild(meta);
        row.appendChild(actions);
        grid.appendChild(row);
      });
      dom.haul.appendChild(grid);
      const bulk=document.createElement('div');
      bulk.className='inventory inline-actions';
      const packAll=document.createElement('button');
      packAll.textContent='Pack all';
      packAll.onclick=()=>bulkMoveLoot('inventory');
      const stashAll=document.createElement('button');
      stashAll.textContent='Stash all';
      stashAll.onclick=()=>bulkMoveLoot('stash');
      const sellAll=document.createElement('button');
      sellAll.textContent='Sell all';
      sellAll.onclick=bulkSellLoot;
      const scrapAll=document.createElement('button');
      scrapAll.textContent='Scrap all';
      scrapAll.onclick=bulkScrapLoot;
      bulk.appendChild(packAll);
      bulk.appendChild(stashAll);
      bulk.appendChild(sellAll);
      bulk.appendChild(scrapAll);
      dom.haul.appendChild(bulk);
    }

    function renderStash(){
      dom.stash.innerHTML='';
      dom.stashActions.innerHTML='';
      const wrap=document.createElement('div');
      wrap.className='item-grid';
      const items=state.stash.items;
      if(!items.length){
        wrap.innerHTML='<div class="muted-box">Stash is empty. Move loot here for long-term storage.</div>';
      }else{
        groupItems(items).forEach(({id,count,data})=>{
          const row=document.createElement('div');
          row.className='item-row';
          const name=document.createElement('div');
          name.className='item-name';
          name.textContent=`${id} ×${count}`;
          const meta=document.createElement('div');
          meta.className='item-meta';
          meta.textContent=`${data.type} · ${data.value || 1} cr`;
          const chip=document.createElement('span');
          chip.className=`chip ${data.rarity}`;
          chip.textContent=data.rarity;
          const actions=document.createElement('div');
          actions.className='item-actions';
          const pack=document.createElement('button');
          pack.textContent='Pack';
          pack.onclick=()=>unstashItem(id);
          const sell=document.createElement('button');
          sell.textContent='Sell';
          sell.onclick=()=>sellStashItem(id);
          const scrap=document.createElement('button');
          scrap.textContent='Scrap';
          scrap.onclick=()=>scrapStashItem(id);
          actions.appendChild(pack);
          actions.appendChild(sell);
          actions.appendChild(scrap);
          row.appendChild(name);
          row.appendChild(chip);
          row.appendChild(meta);
          row.appendChild(actions);
          wrap.appendChild(row);
        });
      }
      dom.stash.appendChild(wrap);
      const bulk=document.createElement('div');
      bulk.className='inventory inline-actions';
      const sellAll=document.createElement('button');
      sellAll.textContent='Sell all stash';
      sellAll.onclick=bulkSellStash;
      const scrapAll=document.createElement('button');
      scrapAll.textContent='Scrap all stash';
      scrapAll.onclick=bulkScrapStash;
      bulk.appendChild(sellAll);
      bulk.appendChild(scrapAll);
      dom.stashActions.appendChild(bulk);
    }

    /* ================= GAMEPLAY ================= */
    function calcPressure(){
      const hungerPressure=state.hunger>70?0.08:0;
      const thirstPressure=state.thirst>70?0.08:0;
      const fatiguePressure=state.stamina<30?0.06:0;
      const energyPressure=state.energy<25?0.08:0;
      const radiationPressure=state.rads*0.01;
      const heatPressure=state.heat*0.012;
      const base=0.06;
      return clamp(base+hungerPressure+thirstPressure+fatiguePressure+energyPressure+radiationPressure+heatPressure,0,0.85);
    }

    function computeFailChance(risk){
      const base=riskTable[risk] ?? 0.12;
      const pressure=calcPressure();
      const gearMods=getGearMods();
      const heatPenalty=Math.min(0.12,state.heat*0.002);
      const radsPenalty=Math.min(0.08,state.rads*0.004);
      const total=base + pressure*0.25 + heatPenalty + radsPenalty - (gearMods.riskMod||0);
      return clamp(total,0.05,0.75);
    }

    function tickTime(minutes){
      const total=state.timeMinutes+minutes;
      if(total>=24*60){
        state.timeMinutes=total%(24*60);
        advanceDay();
      }else{
        state.timeMinutes=total;
      }
    }

    function advanceDay(){
      state.day++;
      state.timeMinutes=6*60;
    }

    function rollComplication(source){
      const pressure=calcPressure();
      if(Math.random()>pressure) return;
      const complications=[
        {desc:'A distant tracker pings your heat signature.',effects:'heat+2,morale-2'},
        {desc:'An unseen stalker snatches some scrap.',effects:'scrap-2,heat+1'},
        {desc:'Hunger cramps slow you down.',effects:'stamina-6,hp-3'},
        {desc:'Static surge fries a component.',effects:'credits-6,heat+1'},
        {desc:'Radiation spike makes your skin crawl.',effects:'rads+2,hp-4'}
      ];
      const hit=complications[Math.floor(Math.random()*complications.length)];
      applyEffects(hit.effects,'fail');
      logMsg(`Complication (${source}): ${hit.desc}`);
    }

    function applyEffects(effectStr,outcome){
      if(!effectStr) return;
      effectStr.split(',').forEach(token=>{
        token=token.trim(); if(!token) return;
        if(token.startsWith('item:')){
          const item=token.slice(5).trim();
          if(state.inventory.length<state.backpackLimit) state.inventory.push(item);
          else state.lootQueue.push(item);
          return;
        }
        if(token.startsWith('flag:')){ state.flags.add(token.slice(5)); return; }
        if(token.startsWith('note:')){ setCodex(token.slice(5)); return; }
        if(token.startsWith('log:')){ logMsg(token.slice(4)); return; }
        const match=token.match(/([a-zA-Z]+)([+-]\d+)/);
        if(match){
          const stat=match[1]; const delta=Number(match[2]);
          if(stat==='hp') state.hp=clamp(state.hp+delta,0,state.maxHp);
          else if(stat==='stamina') state.stamina=clamp(state.stamina+delta,0,state.maxStamina);
          else if(stat==='morale') state.morale=clamp(state.morale+delta,0,state.maxMorale);
          else if(stat==='hunger') state.hunger=clamp(state.hunger+delta,0,state.maxHunger);
          else if(stat==='thirst') state.thirst=clamp(state.thirst+delta,0,state.maxThirst);
          else if(stat==='rads') state.rads=Math.max(0,state.rads+delta);
          else if(stat==='heat') state.heat=Math.max(0,state.heat+delta);
          else if(stat==='credits') state.credits=Math.max(0,state.credits+delta);
          else if(stat==='scrap') state.scrap=Math.max(0,state.scrap+delta);
          else if(stat==='energy') state.energy=clamp(state.energy+delta,0,state.maxEnergy);
          else if(stat==='fuel') state.fuel=Math.max(0,state.fuel+delta);
          else if(stat==='keys') state.keys=Math.max(0,state.keys+delta);
          else if(stat==='signal') state.signal=clamp(state.signal+delta,0,state.maxSignal);
        }
      });
      if(outcome==='fail' && state.hp<=0){
        logMsg('Emergency evac: you collapse and lose momentum.');
        state.hp=clamp(40,1,state.maxHp);
        state.morale=clamp(state.morale-12,0,state.maxMorale);
        state.energy=clamp(state.energy-20,0,state.maxEnergy);
      }
    }
    function runRaid(raid){
      const cost={energy:raid.energy,keys:raid.key||0};
      if(!canAfford(cost)){
        setCodex('Not enough resources for that raid.');
        return;
      }
      applyCost(cost);
      tickTime(raid.time);
      const gearMods=getGearMods();
      state.hunger=clamp(state.hunger+2,0,state.maxHunger);
      state.thirst=clamp(state.thirst+2,0,state.maxThirst);
      state.stamina=clamp(state.stamina-6+(gearMods.staminaBonus||0),0,state.maxStamina);

      const effectiveRisk=(riskRank[raid.risk] >= riskRank[state.zone.risk]) ? raid.risk : state.zone.risk;
      const failChance=computeFailChance(effectiveRisk);
      const roll=Math.random();
      const success=roll>failChance;
      if(success){
        const lootBonus=gearMods.lootBonus || 0;
        const pulls=Math.max(1,raid.loot+(Math.random()<0.35?1:0));
        for(let i=0;i<pulls;i++){
          state.lootQueue.push(rollLootItem(effectiveRisk,lootBonus));
        }
        state.signal=clamp(state.signal+4+(gearMods.signalBonus||0),0,state.maxSignal);
        state.heat=clamp(state.heat+1,0,999);
        logMsg(`✓ ${raid.label} succeeded. Haul inbound.`);
      }else{
        applyEffects('hp-6,morale-4,heat+2','fail');
        rollComplication('raid');
        logMsg(`✖ ${raid.label} failed. You limp back empty-handed.`);
      }
      renderAll();
    }

    function moveLootItem(item,target){
      removeItem(state.lootQueue,item);
      if(target==='inventory'){
        if(state.inventory.length>=state.backpackLimit){
          setCodex('Backpack full. Make room first.');
          state.lootQueue.push(item);
          return;
        }
        state.inventory.push(item);
      }else if(target==='stash'){
        if(state.stash.items.length>=state.stashLimit){
          setCodex('Stash full. Sell or scrap to clear space.');
          state.lootQueue.push(item);
          return;
        }
        state.stash.items.push(item);
      }
      renderAll();
    }

    function bulkMoveLoot(target){
      const items=[...state.lootQueue];
      state.lootQueue=[];
      items.forEach(item=>{
        if(target==='inventory' && state.inventory.length<state.backpackLimit){
          state.inventory.push(item);
        }else if(target==='stash' && state.stash.items.length<state.stashLimit){
          state.stash.items.push(item);
        }else{
          state.lootQueue.push(item);
        }
      });
      if(state.lootQueue.length){
        setCodex('Some loot could not be moved due to capacity.');
      }
      renderAll();
    }

    function sellLootItem(item){
      const data=getItem(item);
      removeItem(state.lootQueue,item);
      state.credits+=data.value || 1;
      renderAll();
    }

    function scrapLootItem(item){
      const data=getItem(item);
      removeItem(state.lootQueue,item);
      const salvage=data.salvage || Math.max(1,Math.floor((data.value || 1)/2));
      state.scrap+=salvage;
      renderAll();
    }

    function bulkSellLoot(){
      state.lootQueue.forEach(item=>{
        const data=getItem(item);
        state.credits+=data.value || 1;
      });
      state.lootQueue=[];
      renderAll();
    }

    function bulkScrapLoot(){
      state.lootQueue.forEach(item=>{
        const data=getItem(item);
        const salvage=data.salvage || Math.max(1,Math.floor((data.value || 1)/2));
        state.scrap+=salvage;
      });
      state.lootQueue=[];
      renderAll();
    }

    function sellStashItem(item){
      const data=getItem(item);
      removeItem(state.stash.items,item);
      state.credits+=data.value || 1;
      renderAll();
    }

    function scrapStashItem(item){
      const data=getItem(item);
      removeItem(state.stash.items,item);
      const salvage=data.salvage || Math.max(1,Math.floor((data.value || 1)/2));
      state.scrap+=salvage;
      renderAll();
    }

    function bulkSellStash(){
      state.stash.items.forEach(item=>{
        const data=getItem(item);
        state.credits+=data.value || 1;
      });
      state.stash.items=[];
      renderAll();
    }

    function bulkScrapStash(){
      state.stash.items.forEach(item=>{
        const data=getItem(item);
        const salvage=data.salvage || Math.max(1,Math.floor((data.value || 1)/2));
        state.scrap+=salvage;
      });
      state.stash.items=[];
      renderAll();
    }

    function runCamp(){
      tickTime(ACTION_TIMES.camp);
      const gearMods=getGearMods();
      state.stamina=clamp(state.stamina+14,0,state.maxStamina);
      state.hp=clamp(state.hp+4,0,state.maxHp);
      state.morale=clamp(state.morale+4,0,state.maxMorale);
      state.energy=clamp(state.energy+18+(gearMods.energyRegen||0),0,state.maxEnergy);
      state.hunger=clamp(state.hunger+3,0,state.maxHunger);
      state.thirst=clamp(state.thirst+3,0,state.maxThirst);
      state.heat=Math.max(0,state.heat-3);
      logMsg('You bunker down, reset power cells, and recover energy.');
      rollComplication('camp');
      renderAll();
    }

    function burnSignal(){
      if(state.signal<10){
        logMsg('Not enough signal to trade.');
        return;
      }
      tickTime(ACTION_TIMES.trade);
      const payout=5+Math.floor(state.signal/12);
      state.signal=Math.max(0,state.signal-10);
      state.credits+=payout;
      state.scrap=clamp(state.scrap+1,0,999);
      logMsg(`Signal monetized for ${payout} credits and salvage.`);
      renderAll();
    }

    function burnFuel(){
      if(state.fuel<=0){
        setCodex('No fuel cells left.');
        return;
      }
      state.fuel=Math.max(0,state.fuel-1);
      state.energy=clamp(state.energy+25,0,state.maxEnergy);
      state.stamina=clamp(state.stamina+6,0,state.maxStamina);
      logMsg('Fuel cell burned for a quick energy surge.');
      renderAll();
    }

    /* ================= EXPANSION LOADING ================= */
    async function loadGames(){
      try{
        const res=await fetch('games.json');
        const data=await res.json();
        dom.doorsHint.textContent='';
        data.expansions.forEach(meta=>loadExpansion(meta));
      }catch(err){
        dom.doorsHint.textContent='Unable to load games.json';
        console.error(err);
      }
    }

    async function loadExpansion(meta){
      try{
        const res=await fetch(meta.file);
        const raw=await res.text();
        const expansion=parseExpansion(raw);
        expansion.meta.id=meta.id || expansion.meta.id;
        expansion.meta.name=meta.name || expansion.meta.name || meta.id;
        expansions[expansion.meta.id]=expansion;
        addDoor(expansion);
        logMsg(`Door bolted on: ${expansion.meta.name}`);
      }catch(err){
        logMsg(`Failed to load ${meta.id}`);
        console.error(err);
      }
    }

    function addDoor(exp){
      const btn=document.createElement('button');
      btn.innerHTML=`<span>${exp.door?.label||exp.meta.name}</span><span class="small">${exp.door?.hint||'Unknown signal'}</span>`;
      btn.onclick=()=>{
        state.zone={
          id:exp.meta.id,
          name:exp.meta.name,
          risk:exp.door?.risk || 'low',
          desc:exp.door?.desc || exp.door?.hint || 'Signal-streaked salvage zone.'
        };
        if(exp.door?.note) setCodex(exp.door.note);
        renderAll();
      };
      dom.doors.appendChild(btn);
    }

    function parseOption(str){
      // Format: Label => target | risk:low | time:10 | success:hp+5,credits+10 | fail:hp-5 | rad:1 | heat:1
      const segments=str.split('|').map(s=>s.trim()).filter(Boolean);
      const [labelPart,...rest]=segments;
      const [label,target]=labelPart.split('=>').map(s=>s&&s.trim());
      const opt={label:label||'Action',target:target||null,risk:'low',time:8,success:'',fail:'',rad:0,heat:0};
      rest.forEach(seg=>{
        const [k,vRaw]=seg.split(':');
        const v=vRaw?.trim();
        if(!k) return;
        const key=k.trim().toLowerCase();
        if(key==='risk') opt.risk=v;
        else if(key==='time') opt.time=Number(v||8);
        else if(key==='success') opt.success=v;
        else if(key==='fail') opt.fail=v;
        else if(key==='rad') opt.rad=Number(v||0);
        else if(key==='heat') opt.heat=Number(v||0);
      });
      return opt;
    }

    function parseExpansion(raw){
      const exp={meta:{},door:{},scenes:{}};
      let scope='meta';
      let currentScene=null;
      raw.split(/\r?\n/).forEach(line=>{
        line=line.trim();
        if(!line || line.startsWith('#')) return;
        if(line.startsWith('@expansion')){scope='meta';currentScene=null;return;}
        if(line.startsWith('@door')){scope='door';currentScene=null;return;}
        if(line.startsWith('@scene')){
          scope='scene';
          const id=line.split(/\s+/)[1] || `scene-${Object.keys(exp.scenes).length+1}`;
          currentScene={id,title:'',desc:'',tags:'',options:[]};
          exp.scenes[id]=currentScene;return;
        }
        const [key,...rest]=line.split(':');
        const value=rest.join(':').trim();
        if(scope==='meta') exp.meta[key]=value;
        else if(scope==='door') exp.door[key]=value;
        else if(scope==='scene' && currentScene){
          if(key==='option') currentScene.options.push(parseOption(value));
          else if(key==='desc') currentScene.desc += (currentScene.desc?' ':'') + value;
          else currentScene[key]=value;
        }
      });
      return exp;
    }

    function renderAll(){
      renderBars();
      renderInventory();
      renderLog();
      renderExcursionStatus();
      renderHubAccess();
      renderIdleOps();
      renderZone();
      renderRaidActions();
      renderHaul();
      renderStash();
      syncTabs();
    }

    /* ================= INIT ================= */
    renderAll();
    loadGames();

    function ambientTick(){
      tickTime(4);
      if(state.idleOps.active){
        const elapsed=Date.now()-state.idleOps.startedAt;
        if(elapsed>=state.idleOps.durationMs){
          completeIdleOp();
          return;
        }
      }
      const gearMods=getGearMods();
      state.signal=clamp(state.signal+2+(gearMods.signalBonus||0),0,state.maxSignal);
      state.energy=clamp(state.energy+4+(gearMods.energyRegen||0),0,state.maxEnergy);
      state.hunger=clamp(state.hunger+1,0,state.maxHunger);
      state.thirst=clamp(state.thirst+1,0,state.maxThirst);
      if(state.autoSalvage && state.energy>=12 && state.lootQueue.length<16){
        runRaid(RAID_TEMPLATES[0]);
      }
      if(state.hunger>=90){
        applyEffects('hp-3,morale-2','fail');
        logMsg('Starvation gnaws at you while you hesitate.');
      }
      if(state.thirst>=90){
        applyEffects('hp-4,stamina-5','fail');
        logMsg('Dehydration blurs your vision.');
      }
      rollComplication('idle time');
      if(state.timeMinutes%60===0){
        logMsg('The hub crackles. Passive signal trickles in.');
      }
      renderAll();
    }

    setInterval(ambientTick,6500);
  </script>
</body>
</html>
