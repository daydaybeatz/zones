<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Zones - fight, loot, survive.</title>
<style>
  :root{
    color-scheme: dark;
    --tab-bar-height:52px;

    /* CORE TERMINAL PALETTE */
    --bg:#020202;
    --ink:#b8ffcf;
    --muted:#5cff8b;

    --green:#39ff14;
    --green-d:#0b5f1e;
    --red:#ff0033;
    --red-d:#5a0014;

    --amber:#ffb000;
    --orange:#ff6a00;
    --blue:#00b7ff;

    /* SURFACES */
    --panel:rgba(0, 0, 0, 0.78);
    --panel-2:rgba(8, 10, 8, 0.88);
    --panel-3:rgba(0, 0, 0, 0.55);

    --border:rgba(57,255,20,0.22);
    --border-strong:rgba(57,255,20,0.48);
    --border-red:rgba(255,0,51,0.45);

    --shadow:0 18px 60px rgba(0,0,0,.62);
    --inner:inset 0 0 0 1px rgba(57,255,20,0.08);

    --glow:0 0 18px rgba(57,255,20,.25), 0 0 48px rgba(57,255,20,.08);
    --glow-strong:0 0 10px rgba(57,255,20,.55), 0 0 28px rgba(57,255,20,.25), 0 0 80px rgba(57,255,20,.08);
    --glow-red:0 0 10px rgba(255,0,51,.55), 0 0 28px rgba(255,0,51,.25), 0 0 90px rgba(255,0,51,.10);

    --radius:12px;
    --visual-viewport-offset:0px;

    /* CRT FX */
    --scanlineA:rgba(0,0,0,0.32);
    --scanlineB:rgba(0,0,0,0.06);
    --noiseA:rgba(255,255,255,0.06);
    --vignette:rgba(0,0,0,0.0);

    /* TYPE */
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }

  *{box-sizing:border-box;}
  ::selection{background:rgba(255,0,51,0.28); color:#fff;}

  html, body{height:100%;}
  body{
    margin:0;
    min-height:100vh;
    padding:12px 12px calc(12px + var(--tab-bar-height));
    color:var(--ink);
    font-family:var(--mono);
    letter-spacing:0.2px;
    line-height:1.45;

    /* HELLGRID BACKDROP */
    background:
      radial-gradient(circle at 20% 20%, rgba(57,255,20,.10), transparent 40%),
      radial-gradient(circle at 80% 10%, rgba(255,0,51,.09), transparent 38%),
      radial-gradient(circle at 40% 90%, rgba(0,183,255,.06), transparent 45%),
      radial-gradient(circle at 10% 80%, rgba(255,176,0,.04), transparent 50%),
      repeating-linear-gradient(0deg, rgba(57,255,20,.04) 0, rgba(57,255,20,.04) 1px, transparent 1px, transparent 28px),
      repeating-linear-gradient(90deg, rgba(57,255,20,.03) 0, rgba(57,255,20,.03) 1px, transparent 1px, transparent 34px),
      var(--bg);

    text-shadow: 0 0 10px rgba(57,255,20,0.08);

    /* subtle CRT warp + flicker */
    animation: crtFlicker 6.5s infinite steps(1, end);
  }

  /* CRT overlays: scanlines + noise + vignette + chroma */
  body::before{
    content:"";
    position:fixed;
    inset:0;
    pointer-events:none;
    z-index:9999;
    background:
      /* scanlines */
      repeating-linear-gradient(
        180deg,
        var(--scanlineA) 0px,
        var(--scanlineA) 1px,
        var(--scanlineB) 2px,
        transparent 4px
      ),
      /* faint vertical mask */
      repeating-linear-gradient(
        90deg,
        rgba(0,0,0,0.18) 0px,
        rgba(0,0,0,0.18) 1px,
        transparent 3px,
        transparent 7px
      );
    mix-blend-mode: multiply;
    opacity:0.95;
  }
  body::after{
    content:"";
    position:fixed;
    inset:-20%;
    pointer-events:none;
    z-index:9998;
    background:
      /* noise grain */
      repeating-radial-gradient(circle at 20% 30%, rgba(255,255,255,0.05) 0 1px, transparent 2px 6px),
      repeating-radial-gradient(circle at 70% 60%, rgba(255,255,255,0.03) 0 1px, transparent 2px 7px),
      linear-gradient(90deg, rgba(255,0,51,0.03), rgba(0,183,255,0.02), rgba(57,255,20,0.03));
    opacity:0.18;
    filter: blur(0.2px);
    animation: noiseDrift 2.2s infinite linear;
  }

  .modal{
    position:fixed;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:24px;
    background:rgba(0,0,0,0.72);
    z-index:10000;
  }

  .modal.hidden{
    display:none;
  }

  .modal-card{
    width:min(520px, 92vw);
    padding:20px 22px;
    border-radius:var(--radius);
    border:1px solid var(--border-strong);
    background:var(--panel);
    box-shadow:var(--shadow), var(--inner), var(--glow);
  }

  .modal-actions{
    display:flex;
    flex-wrap:wrap;
    gap:12px;
    margin-top:16px;
  }

  /* app wrapper */
  #app{
    max-width:1200px;
    margin:auto;
    display:flex;
    flex-direction:column;
    gap:12px;
    position:relative;
    padding-bottom:72px;
  }

  /* HEADER = main terminal bar */
  header{
    display:flex;
    flex-wrap:wrap;
    gap:10px;
    align-items:center;
    justify-content:space-between;
    padding:14px 16px;

    background:
      linear-gradient(180deg, rgba(10,12,10,0.92), rgba(0,0,0,0.78)),
      radial-gradient(circle at 20% 50%, rgba(57,255,20,0.08), transparent 55%),
      radial-gradient(circle at 85% 40%, rgba(255,0,51,0.06), transparent 60%);

    border:1px solid var(--border-strong);
    border-radius: var(--radius);
    box-shadow: var(--shadow), var(--inner), var(--glow);
    position:relative;
    z-index:1;

    backdrop-filter: blur(6px);
    overflow:hidden;
  }
  header::before{
    content:"";
    position:absolute;
    inset:-2px;
    background:
      repeating-linear-gradient(135deg,
        rgba(255,0,51,0.12) 0 8px,
        rgba(255,0,51,0.00) 8px 16px);
    opacity:0.12;
    pointer-events:none;
    mix-blend-mode: screen;
  }
  header::after{
    content:"";
    position:absolute;
    left:-40%;
    top:0;
    width:50%;
    height:100%;
    background:linear-gradient(90deg, transparent, rgba(57,255,20,0.12), transparent);
    transform:skewX(-18deg);
    animation: sweep 4.8s infinite linear;
    opacity:0.35;
    pointer-events:none;
  }

  .title{
    font-size:18px;
    font-weight:800;
    letter-spacing:1.3px;
    display:flex;
    align-items:center;
    gap:10px;
    color:#dbffe8;
    text-transform:uppercase;
    text-shadow: 0 0 12px rgba(57,255,20,0.18), 0 0 2px rgba(255,255,255,0.10);
  }
  .title::before{
    content:"▮";
    color:var(--green);
    text-shadow: var(--glow-strong);
    animation: cursorBlink 0.9s infinite steps(1,end);
  }
  .title-row{
    display:flex;
    align-items:center;
    gap:12px;
    flex-wrap:wrap;
  }
  .pause-toggle{
    padding:6px 12px;
    font-size:12px;
    letter-spacing:0.08em;
    text-transform:uppercase;
  }
  .tagline{
    font-size:12px;
    color:rgba(184,255,207,0.75);
    letter-spacing:0.6px;
  }

  .pill{
    border:1px solid var(--border);
    border-radius:999px;
    padding:6px 10px;
    font-size:11px;
    color:rgba(184,255,207,0.76);
    background:
      linear-gradient(180deg, rgba(12,16,12,0.65), rgba(0,0,0,0.55));
    box-shadow: var(--inner);
    text-transform:uppercase;
    letter-spacing:0.8px;
  }
  .pill::before{
    content:"●";
    margin-right:8px;
    color:var(--amber);
    text-shadow: 0 0 10px rgba(255,176,0,0.45);
  }

  /* PANELS = terminal windows */
  .panel{
    background:
      linear-gradient(180deg, rgba(8,10,8,0.90), rgba(0,0,0,0.72)),
      radial-gradient(circle at 15% 30%, rgba(57,255,20,0.08), transparent 55%),
      radial-gradient(circle at 85% 20%, rgba(255,0,51,0.07), transparent 60%);
    border:1px solid var(--border);
    border-radius: var(--radius);
    padding:14px 16px;
    box-shadow: var(--shadow), var(--inner);
    position:relative;
    overflow:hidden;
  }
  .panel::before{
    content:"";
    position:absolute;
    inset:0;
    background:
      repeating-linear-gradient(0deg, rgba(57,255,20,0.04) 0 1px, transparent 1px 10px);
    opacity:0.30;
    pointer-events:none;
  }
  .panel::after{
    content:"";
    position:absolute;
    inset:-2px;
    border-radius: var(--radius);
    box-shadow:
      inset 0 0 0 1px rgba(57,255,20,0.12),
      inset 0 0 0 2px rgba(255,0,51,0.06);
    pointer-events:none;
  }

  .panel h3{
    margin:0 0 8px;
    font-size:14px;
    letter-spacing:1.2px;
    text-transform:uppercase;
    color:#e9fff2;
    text-shadow: 0 0 10px rgba(57,255,20,0.12);
  }
  .panel h3::after{
    content:" //";
    color:rgba(57,255,20,0.55);
  }

  .grid-two{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:10px;}
  .two-col{display:grid;grid-template-columns:1.1fr 1fr;gap:12px;}

  /* STATLINES */
  .statline{
    display:grid;
    grid-template-columns:110px 1fr 68px;
    align-items:center;
    font-size:12px;
    gap:10px;
    padding:7px 0;
    border-bottom:1px solid rgba(57,255,20,0.06);
  }
  .bar{
    height:10px;
    background:rgba(0,0,0,0.65);
    border-radius:999px;
    overflow:hidden;
    border:1px solid rgba(57,255,20,0.15);
    box-shadow: inset 0 0 10px rgba(0,0,0,0.65);
    position:relative;
  }
  .bar::after{
    content:"";
    position:absolute;
    inset:0;
    background:linear-gradient(90deg, rgba(255,255,255,0.08), transparent 35%, rgba(255,255,255,0.06));
    opacity:0.25;
    pointer-events:none;
  }
  .bar span{
    display:block;height:100%;
    border-radius:999px;
    filter: saturate(1.15) contrast(1.05);
    box-shadow: 0 0 14px rgba(57,255,20,0.18);
  }

  .bar.hp span{background:linear-gradient(90deg, var(--red), var(--orange)); box-shadow: var(--glow-red);}
  .bar.stamina span{background:linear-gradient(90deg, var(--green), rgba(0,183,255,0.55));}
  .bar.morale span{background:linear-gradient(90deg, var(--amber), rgba(57,255,20,0.55));}
  .bar.rads span{background:linear-gradient(90deg, rgba(57,255,20,0.8), var(--amber), var(--red));}
  .bar.hunger span{background:linear-gradient(90deg, var(--orange), var(--red));}
  .bar.thirst span{background:linear-gradient(90deg, var(--blue), rgba(57,255,20,0.6));}
  .bar.temp span{background:linear-gradient(90deg, var(--green), var(--blue));}

  /* META CHIPS */
  .meta{color:rgba(184,255,207,0.72);font-size:12px;display:flex;flex-wrap:wrap;gap:10px;}
  .meta b{color:#eafff0;margin-right:6px;}
  .pill-inline{
    display:inline-flex;align-items:center;gap:8px;
    padding:4px 10px;
    border-radius:999px;
    border:1px solid rgba(57,255,20,0.18);
    background:linear-gradient(180deg, rgba(10,12,10,0.6), rgba(0,0,0,0.55));
    font-size:11px;
    color:rgba(184,255,207,0.78);
    box-shadow: var(--inner);
    text-transform:uppercase;
    letter-spacing:0.6px;
  }
  .pill-inline::before{
    content:"▸";
    color:var(--green);
    text-shadow: var(--glow);
  }

  .rows{display:flex;flex-direction:column;gap:10px;}

  .muted-box{
    padding:14px 16px;
    border-radius:10px;
    border:1px dashed rgba(57,255,20,0.18);
    color:rgba(184,255,207,0.70);
    background:
      linear-gradient(180deg, rgba(0,0,0,0.62), rgba(0,0,0,0.46));
    box-shadow: inset 0 0 0 1px rgba(255,0,51,0.05);
    position:relative;
  }
  .muted-box::after{
    content:"⚠";
    position:absolute;
    right:10px;
    top:10px;
    color:rgba(255,176,0,0.65);
    text-shadow: 0 0 12px rgba(255,176,0,0.25);
    font-size:12px;
  }

  /* BUTTONS = chunky terminal keys */
  button{
    appearance:none;
    border:1px solid rgba(57,255,20,0.28);
    background:
      linear-gradient(180deg, rgba(10,14,10,0.92), rgba(0,0,0,0.78));
    color:#eafff0;
    border-radius:10px;
    padding:10px 12px;
    font-size:13px;
    text-align:left;
    cursor:pointer;
    transition:transform .06s ease, border .15s ease, filter .15s ease, box-shadow .15s ease;
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:8px;
    min-height:46px;

    box-shadow:
      0 10px 22px rgba(0,0,0,0.55),
      inset 0 0 0 1px rgba(57,255,20,0.08),
      0 0 0 1px rgba(0,0,0,0.5);
    letter-spacing:0.7px;
    text-transform:uppercase;
    position:relative;
    overflow:hidden;
  }
  button::before{
    content:"";
    position:absolute;
    inset:0;
    background:
      linear-gradient(90deg, transparent, rgba(57,255,20,0.10), transparent);
    transform:translateX(-120%);
    transition:transform .25s ease;
    pointer-events:none;
  }
  button::after{
    content:"";
    position:absolute;
    left:6px;
    top:50%;
    width:6px;height:6px;
    border-radius:50%;
    transform:translateY(-50%);
    background:rgba(255,176,0,0.85);
    box-shadow:
      0 0 10px rgba(255,176,0,0.45),
      0 0 18px rgba(255,106,0,0.20);
    pointer-events:none;
  }
  button:hover{
    transform:translateY(-1px);
    border-color:rgba(57,255,20,0.62);
    box-shadow: var(--shadow), var(--inner), var(--glow-strong);
    filter:saturate(1.15);
  }
  button:hover::before{transform:translateX(120%);}
  button:active{transform:translateY(0); filter:saturate(1.05) contrast(1.02);}

  button:disabled{
    opacity:0.35;
    cursor:not-allowed;
    border-style:dashed;
    box-shadow:none;
  }

  .btn-secondary{
    border-color:rgba(0,183,255,0.22);
    background:linear-gradient(180deg, rgba(8,10,14,0.92), rgba(0,0,0,0.78));
  }
  .btn-secondary::after{
    background:rgba(0,183,255,0.92);
    box-shadow:0 0 10px rgba(0,183,255,0.45), 0 0 18px rgba(0,183,255,0.20);
  }
  .danger{
    border-color:rgba(255,0,51,0.48);
    color:#ffd6de;
  }
  .danger:hover{
    border-color:rgba(255,0,51,0.75);
    box-shadow: var(--shadow), var(--inner), var(--glow-red);
  }
  .danger::after{
    background:rgba(255,0,51,0.95);
    box-shadow:0 0 10px rgba(255,0,51,0.55), 0 0 22px rgba(255,0,51,0.25);
  }

  /* TABS */
  .tabs{
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:var(--radius);
    box-shadow:var(--shadow), var(--inner);
    overflow:hidden;
  }
  .tab-buttons{
    display:flex;
    gap:8px;
    padding:10px 12px;
    border-top:1px solid rgba(57,255,20,0.14);
    flex-wrap:nowrap;
    justify-content:center;
    overflow-x:auto;
    background:
      linear-gradient(180deg, rgba(10,12,10,0.70), rgba(0,0,0,0.60));
    position:fixed;
    bottom:0;
    left:0;
    right:0;
    min-height:var(--tab-bar-height);
    z-index:5;
    border-radius:var(--radius) var(--radius) 0 0;
    box-shadow: var(--shadow), var(--inner), var(--glow);
    transform:translateY(calc(-1 * var(--visual-viewport-offset)));
    will-change:transform;
  }
  .tab-buttons button{
    flex:0 0 auto;
    min-width:110px;
    text-align:center;
    justify-content:center;
    border-radius:10px;
    padding:8px 10px;
    min-height:36px;
  }
  .tab-buttons button.active{
    border-color:rgba(57,255,20,0.75);
    background:
      linear-gradient(180deg, rgba(57,255,20,0.14), rgba(0,0,0,0.70));
    box-shadow: var(--glow-strong);
  }

  .tab-content{display:none;padding:12px;}
  .tab-content.active{display:block;}

  .tab-dock{
    height:0;
  }

  .subtabs{
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    margin-bottom:12px;
  }
  .subtabs button{
    flex:1 1 120px;
    text-align:center;
    justify-content:center;
    min-height:40px;
  }

  /* BADGES + SCENE */
  .badge{
    font-size:11px;
    border-radius:8px;
    padding:3px 10px;
    background:linear-gradient(180deg, rgba(57,255,20,0.10), rgba(0,0,0,0.72));
    border:1px solid rgba(57,255,20,0.45);
    color:rgba(184,255,207,0.92);
    display:inline-flex;
    gap:8px;
    align-items:center;
    text-transform:uppercase;
    letter-spacing:0.8px;
    box-shadow: var(--inner), var(--glow);
    position:relative;
  }
  .badge::before{
    content:"";
    width:8px;height:8px;border-radius:50%;
    background:rgba(57,255,20,0.95);
    box-shadow:0 0 10px rgba(57,255,20,0.55), 0 0 18px rgba(57,255,20,0.22);
  }
  .scene-title{font-size:15px;margin:0;color:#eafff0;text-transform:uppercase;letter-spacing:1px;}
  .scene-desc{margin:6px 0 10px;color:rgba(184,255,207,0.78);font-size:13px;}

  .inline{display:flex;flex-wrap:wrap;gap:8px;align-items:center;}
  .stack{display:flex;flex-direction:column;gap:12px;}

  .risk-low{
    border-color:rgba(57,255,20,0.45);
    box-shadow: var(--inner), var(--glow);
  }
  .risk-medium{
    border-color:rgba(255,176,0,0.5);
    box-shadow: var(--inner), 0 0 18px rgba(255,176,0,0.2);
  }
  .risk-high,
  .risk-deadly{
    border-color:rgba(255,0,51,0.55);
    box-shadow: var(--inner), var(--glow-red);
  }

  .badge.risk-medium{
    background:linear-gradient(180deg, rgba(255,176,0,0.16), rgba(0,0,0,0.72));
    color:rgba(255,227,194,0.9);
  }
  .badge.risk-high,
  .badge.risk-deadly{
    background:linear-gradient(180deg, rgba(255,0,51,0.16), rgba(0,0,0,0.72));
    color:rgba(255,210,218,0.9);
  }
  .badge.risk-medium::before{
    background:rgba(255,176,0,0.9);
    box-shadow:0 0 10px rgba(255,176,0,0.55), 0 0 18px rgba(255,176,0,0.22);
  }
  .badge.risk-high::before,
  .badge.risk-deadly::before{
    background:rgba(255,0,51,0.9);
    box-shadow:0 0 10px rgba(255,0,51,0.55), 0 0 18px rgba(255,0,51,0.22);
  }

  .door-card{
    border:1px solid var(--border);
    border-radius:12px;
    padding:8px 10px;
    background:linear-gradient(180deg, rgba(10,12,10,0.82), rgba(0,0,0,0.68));
    display:flex;
    flex-wrap:wrap;
    gap:8px;
    align-items:center;
    justify-content:space-between;
  }
  .door-card.locked{
    opacity:0.55;
    filter:saturate(0.4);
  }
  .door-info{
    display:flex;
    flex-direction:column;
    gap:2px;
    min-width:200px;
  }
  .door-title{
    font-size:13px;
    text-transform:uppercase;
    letter-spacing:0.8px;
  }
  .door-meta{
    font-size:11px;
    color:rgba(184,255,207,0.7);
  }
  .door-actions{
    display:flex;
    flex-wrap:wrap;
    gap:8px;
  }
  .door-panel{
    display:flex;
    flex-direction:column;
    gap:8px;
    margin-top:10px;
  }
  .door-panel.is-collapsed{
    display:none;
  }
  .door-current{
    margin-top:10px;
  }
  .door-current-card{
    border-style:solid;
  }
  .door-current-tag{
    font-size:10px;
    letter-spacing:0.9px;
    text-transform:uppercase;
    color:rgba(184,255,207,0.7);
  }
  .door-pagination{
    display:flex;
    align-items:center;
    justify-content:flex-end;
    gap:8px;
    font-size:11px;
    color:rgba(184,255,207,0.7);
  }
  .door-pagination button{
    min-height:30px;
    padding:4px 10px;
  }

  /* LOG/TERMINAL BOX */
  .log{
    white-space:pre-wrap;
    font-size:12px;
    color:#d6ffe6;
    line-height:1.35;
    max-height:320px;
    overflow:auto;
    padding:12px;

    background:
      radial-gradient(circle at 10% 10%, rgba(57,255,20,0.08), transparent 55%),
      linear-gradient(180deg, rgba(0,0,0,0.85), rgba(0,0,0,0.65));
    border:1px solid rgba(57,255,20,0.20);
    border-radius:12px;
    box-shadow: inset 0 0 0 1px rgba(57,255,20,0.07), inset 0 0 30px rgba(0,0,0,0.75);
    text-shadow: 0 0 10px rgba(57,255,20,0.10);
    position:relative;
  }
  .log::after{
    content:"SIG//NOISE";
    position:absolute;
    right:10px; bottom:10px;
    font-size:10px;
    color:rgba(0,183,255,0.55);
    text-shadow:0 0 10px rgba(0,183,255,0.25);
    letter-spacing:1px;
  }
  .log-entry{
    display:block;
    padding:2px 0;
  }
  .log-entry--danger{
    color:#ff4b5c;
    text-shadow:0 0 10px rgba(255,75,92,0.35);
  }
  .log-entry--warning{
    color:#ffd166;
    text-shadow:0 0 10px rgba(255,209,102,0.3);
  }
  .log-entry--mission{
    color:#7bff8b;
    text-shadow:0 0 10px rgba(123,255,139,0.25);
  }
  .log-entry--character{
    color:#ffad5a;
    text-shadow:0 0 10px rgba(255,173,90,0.3);
  }

  .signal-log{
    position:fixed;
    left:50%;
    bottom:var(--tab-bar-height);
    transform:translateX(-50%) translateY(calc(-1 * var(--visual-viewport-offset)));
    width:min(1200px, calc(100% - 24px));
    margin:0;
    z-index:6;
    display:flex;
    flex-direction:column;
    gap:8px;
    padding:0 6px 6px;
  }
  .signal-log__controls{
    display:flex;
    justify-content:flex-end;
    padding:6px 6px 0;
  }
  .signal-log__controls button{
    padding:6px 10px;
    min-height:unset;
    font-size:11px;
  }
  .signal-log .log{
    border-radius:var(--radius) var(--radius) 0 0;
    margin:0;
  }

  .small{font-size:11px;color:rgba(184,255,207,0.70);}

  /* SPINNER */
  .spinner{
    width:18px;height:18px;border-radius:999px;
    border:2px solid rgba(57,255,20,0.15);
    border-top-color:rgba(57,255,20,0.95);
    animation:spin 0.8s linear infinite;
    box-shadow: var(--glow);
  }

  /* PROGRESS */
  .progress{
    height:10px;border-radius:999px;
    background:rgba(0,0,0,0.70);
    border:1px solid rgba(57,255,20,0.18);
    overflow:hidden;
    box-shadow: inset 0 0 18px rgba(0,0,0,0.75);
  }
  .progress span{
    display:block;height:100%;
    background:linear-gradient(90deg, rgba(57,255,20,0.95), rgba(0,183,255,0.55), rgba(255,176,0,0.35));
    border-radius:999px;
    transition:width .2s ease;
    box-shadow: var(--glow-strong);
  }

  /* INVENTORY TILES */
  .item-grid{display:flex;flex-direction:column;gap:10px;}
  .inventory-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(96px,1fr));gap:8px;}
  .icon-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(96px,1fr));gap:8px;}
  .grid-span{grid-column:1 / -1;}

  .inventory-layout{
    display:flex;
    flex-direction:column;
    gap:12px;
  }
  .inventory-layout .command-card{
    order:-1;
  }

  .icon-tile{
    align-items:flex-start;
    justify-content:space-between;
    flex-direction:column;
    gap:6px;
    aspect-ratio:1;
    padding:8px 10px;
    min-height:0;
    text-align:left;

    border:1px solid rgba(57,255,20,0.18);
    background:
      linear-gradient(180deg, rgba(10,12,10,0.72), rgba(0,0,0,0.70));
    box-shadow: inset 0 0 0 1px rgba(57,255,20,0.06);
  }
  .icon-tile .icon-name{font-weight:800;font-size:11px;line-height:1.25; text-transform:uppercase; letter-spacing:0.7px;}
  .icon-tile .icon-meta{font-size:10px;color:rgba(184,255,207,0.68);}
  .icon-tile .icon-count{font-size:11px;color:rgba(184,255,207,0.72);}
  .icon-tile.selected{
    border-color:rgba(57,255,20,0.75);
    box-shadow: 0 0 0 1px rgba(57,255,20,0.35), var(--glow-strong);
    animation: selectPulse 1.4s infinite ease-in-out;
  }
  .icon-tile.empty{opacity:0.45;cursor:default;}
  .icon-tile.empty:hover{border-color:rgba(57,255,20,0.18);transform:none;box-shadow:none;}

  /* CHIPS */
  .chip{
    border:1px solid rgba(57,255,20,0.18);
    border-radius:999px;
    padding:2px 8px;
    font-size:10px;
    color:rgba(184,255,207,0.72);
    text-transform:uppercase;
    letter-spacing:0.7px;
  }
  .chip.common{color:rgba(184,255,207,0.75);}
  .chip.uncommon{color:rgba(57,255,20,0.95); text-shadow:0 0 10px rgba(57,255,20,0.18);}
  .chip.rare{color:rgba(0,183,255,0.95); text-shadow:0 0 12px rgba(0,183,255,0.18);}
  .chip.epic{color:rgba(255,176,0,0.95); text-shadow:0 0 12px rgba(255,176,0,0.18);}
  .chip.legendary{color:rgba(255,0,51,0.95); text-shadow:0 0 14px rgba(255,0,51,0.22); border-color:rgba(255,0,51,0.28);}

  /* COMMAND / HUD CARDS */
  .command-card, .op-card{
    border:1px solid rgba(57,255,20,0.18);
    border-radius:12px;
    padding:12px;
    background:
      linear-gradient(180deg, rgba(10,12,10,0.70), rgba(0,0,0,0.68));
    box-shadow: inset 0 0 0 1px rgba(57,255,20,0.06);
    display:flex;
    flex-direction:column;
    gap:10px;
    position:relative;
    overflow:hidden;
  }
  .command-card::before, .op-card::before{
    content:"";
    position:absolute; inset:0;
    background:radial-gradient(circle at 80% 0%, rgba(255,0,51,0.06), transparent 55%);
    pointer-events:none;
  }
  .command-title{font-size:13px;font-weight:900;letter-spacing:1.1px;text-transform:uppercase;}
  .command-hint{font-size:11px;color:rgba(184,255,207,0.68);}

  .combat-hud{
    border:1px solid rgba(255,0,51,0.22);
    border-radius:12px;
    padding:10px;
    background:linear-gradient(180deg, rgba(16,0,4,0.65), rgba(0,0,0,0.72));
    box-shadow: inset 0 0 0 1px rgba(255,0,51,0.08), var(--glow-red);
    display:flex;
    flex-direction:column;
    gap:8px;
  }
  .combat-hud .combat-title{
    font-weight:900;
    font-size:13px;
    letter-spacing:1px;
    text-transform:uppercase;
  }
  .combat-stats{
    display:grid;
    grid-template-columns:repeat(auto-fit,minmax(140px,1fr));
    gap:6px;
    font-size:12px;
    color:rgba(255,210,220,0.78);
  }
  .combat-stats b{color:#fff;}

  /* NAV / SCREENS */
  .screen-nav{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px;}
  .screen{display:none;flex-direction:column;gap:12px;}
  .screen.active{display:flex;}
  .tab-buttons button:disabled{opacity:0.35;cursor:not-allowed;border-style:dashed;}

  /* PAGER */
  .pager, .icon-pager{
    display:flex;flex-wrap:wrap;gap:8px;
    align-items:center;
    justify-content:space-between;
    margin-top:10px;
  }
  .pager .page-info, .icon-pager .page-info{
    font-size:11px;color:rgba(184,255,207,0.70);
    text-transform:uppercase;letter-spacing:0.7px;
  }
  .pager button, .icon-pager button{
    min-height:36px;
    padding:6px 10px;
    justify-content:center;
    text-align:center;
    flex:0 0 auto;
  }

  /* SCROLLBARS */
  *::-webkit-scrollbar{width:10px;height:10px;}
  *::-webkit-scrollbar-thumb{
    background:linear-gradient(180deg, rgba(57,255,20,0.35), rgba(255,0,51,0.18));
    border:1px solid rgba(57,255,20,0.18);
    border-radius:999px;
  }
  *::-webkit-scrollbar-track{background:rgba(0,0,0,0.65);}

  /* RESPONSIVE */
  @media(max-width:900px){
    header{position:static;}
    .two-col{grid-template-columns:1fr;}
    .inventory-layout{gap:12px;}
    #tab-field .inventory-layout{display:flex;flex-direction:column;}
    #tab-field #stashColumn{display:contents;}
    #tab-field #stashMarket.active{display:contents;}
    #tab-field #marketSubtitle{order:0;}
    #tab-field #marketBackpack{order:1;}
    #tab-field #stashCommandCard{order:2;}
    #tab-field #stashMarket .market-section{order:3;}
    #tab-field #stashActions{order:4;}
  }

  /* ANIMS */
  @keyframes spin{to{transform:rotate(360deg);}}
  @keyframes cursorBlink{50%{opacity:0;}}
  @keyframes sweep{
    0%{transform:translateX(-120%) skewX(-18deg);}
    100%{transform:translateX(320%) skewX(-18deg);}
  }
  @keyframes noiseDrift{
    0%{transform:translate3d(0,0,0);}
    25%{transform:translate3d(-1.2%,0.6%,0);}
    50%{transform:translate3d(0.8%,-0.9%,0);}
    75%{transform:translate3d(1.6%,0.2%,0);}
    100%{transform:translate3d(0,0,0);}
  }
  @keyframes crtFlicker{
    0%{filter:brightness(1) contrast(1.05) saturate(1.1);}
    1%{filter:brightness(1.06) contrast(1.08) saturate(1.15);}
    2%{filter:brightness(0.98) contrast(1.06) saturate(1.10);}
    3%{filter:brightness(1.02) contrast(1.05) saturate(1.12);}
    5%{filter:brightness(1) contrast(1.05) saturate(1.1);}
    30%{filter:brightness(1.01) contrast(1.06) saturate(1.12);}
    31%{filter:brightness(0.97) contrast(1.08) saturate(1.14);}
    32%{filter:brightness(1.03) contrast(1.06) saturate(1.11);}
    100%{filter:brightness(1) contrast(1.05) saturate(1.1);}
  }
  @keyframes selectPulse{
    0%{transform:translateY(0); filter:saturate(1.0);}
    50%{transform:translateY(-1px); filter:saturate(1.25);}
    100%{transform:translateY(0); filter:saturate(1.0);}
  }
</style>

</head>
<body>
  <div id="introModal" class="modal hidden" role="dialog" aria-modal="true">
    <div class="modal-card">
      <div class="command-title" id="introTitle">Welcome to Zero Lux</div>
      <div class="small" id="introMessage"></div>
      <div class="modal-actions" id="introActions"></div>
    </div>
  </div>
  <div id="app">
    <header>
      <div>
        <div class="title-row">
          <div class="title">Zones - fight, loot, survive.</div>
        </div>
        <div class="tagline">Pick zones, run salvage loops, and sort rewards into gear, stash, or scrap.</div>
      </div>
      <div class="pill">Build #: 0.3</div>
    </header>

    <section class="panel">
      <div class="two-col">
        <div>
          <h3>Status Board</h3>
          <div id="stats"></div>
          <div class="meta" id="meta"></div>
        </div>
        <div class="rows"></div>
      </div>
    </section>

    <div id="tabDock" class="tab-dock" aria-hidden="true"></div>

    <div class="tabs">
      <div class="tab-buttons">
        <button data-tab="hub" class="active">Operations</button>
        <button data-tab="inventory">Backpack</button>
        <button data-tab="field">Stash</button>
        <button id="pauseToggle" class="pause-toggle" type="button" aria-pressed="false">Pause</button>
      </div>
      <div id="tab-hub" class="tab-content active">
        <div class="stack">
          <div class="screen-nav" id="screenNav">
            <button data-screen="main" class="active">Main Hub</button>
            <button data-screen="locations">Locations Hub</button>
          </div>
          <div id="screen-main" class="screen active">
            <section class="panel">
              <h3>Idle Operations</h3>
              <div id="idleOps"></div>
            </section>
          </div>
          <div id="screen-locations" class="screen">
            <section class="panel">
              <div class="inline" style="justify-content:space-between;align-items:center;">
                <h3>Zone Gates</h3>
                <button id="doorsToggle" type="button" aria-expanded="false">Change location</button>
              </div>
              <div id="doorsCurrent" class="door-current"></div>
              <div id="doorsPanel" class="door-panel">
                <div id="doors"></div>
                <div class="door-pagination" id="doorsPagination"></div>
                <div class="small" id="doorsHint">Loading expansions…</div>
              </div>
            </section>
            <section class="panel">
              <div class="inline" style="justify-content:space-between;align-items:center;">
                <div>
                  <p class="scene-title" id="zoneTitle">Drift Yard</p>
                  <p class="scene-desc" id="zoneDesc">Low-risk salvage corridor. Ideal for stocking up on scrap and common gear.</p>
                </div>
                <span class="badge" id="zoneBadge">Low risk</span>
              </div>
              <div id="raidActions"></div>
            </section>
          </div>
          <div id="screen-mission" class="screen">
            <section class="panel">
              <h3>Mission Feed</h3>
              <div class="mission-card">
                <div class="mission-title" id="missionTitle">No mission active.</div>
                <div class="mission-meta" id="missionMeta"></div>
                <div class="progress" id="missionProgress"><span style="width:0%;"></span></div>
                <div class="small" id="missionLog"></div>
              <div class="mission-actions" id="missionActions"></div>
            </div>
            <div class="command-card" id="missionRewardsCard">
              <div class="command-title">Mission rewards</div>
              <div id="missionRewardHint" class="command-hint">Complete a mission to review rewards.</div>
              <div id="missionRewardList" class="item-grid"></div>
            </div>
          </section>
        </div>
        </div>
      </div>
      <div id="tab-inventory" class="tab-content">
        <section class="panel">
          <h3>Backpack & Loadout</h3>
          <div class="subtabs" id="inventoryNav">
            <button data-inv-screen="backpack" class="active">Backpack</button>
            <button data-inv-screen="loadout">Loadout</button>
            <button data-inv-screen="crafting">Crafting</button>
          </div>
          <div class="inventory-layout">
            <div>
              <div id="inventoryBackpack" class="subscreen active">
                <h4>Backpack Contents <span class="small" id="backpackCount"></span></h4>
                <div class="item-grid inventory-grid" id="inventory"></div>
              </div>
              <div id="inventoryLoadout" class="subscreen">
                <h4>Equipped Loadout <span class="small" id="loadoutCount"></span></h4>
                <div class="item-grid inventory-grid" id="equipment"></div>
              </div>
              <div id="inventoryCrafting" class="subscreen">
                <h4>Field Crafting</h4>
                <div class="command-hint">Combine junk stacks into quick survival tools.</div>
                <div id="crafting"></div>
              </div>
            </div>
            <div class="command-card">
              <div class="command-title">Selected item</div>
              <div id="itemDetail" class="command-hint">Select gear to view stats, uses, and actions.</div>
              <div class="action-grid" id="itemActions"></div>
            </div>
          </div>
        </section>
      </div>
      <div id="tab-field" class="tab-content">
        <section class="panel">
          <h3 id="stashTitle">Stash Vault</h3>
          <div class="subtabs" id="stashNav">
            <button data-stash-screen="vault" class="active">Vault</button>
            <button data-stash-screen="market">Shop</button>
          </div>
          <div class="inventory-layout">
            <div id="stashColumn">
              <div id="stashVault" class="subscreen active">
                <h4 id="stashSubtitle">Vault Inventory <span class="small" id="stashCount"></span></h4>
                <div id="stash"></div>
              </div>
              <div id="stashMarket" class="subscreen">
                <h4 id="marketSubtitle">Backpack Inventory <span class="small" id="marketBackpackCount"></span></h4>
                <div id="marketBackpack"></div>
                <div class="market-section" id="marketSection">
                  <h4>Vendor stock</h4>
                  <div class="command-hint" id="marketHint">Visit a shop in your current location to access vendors.</div>
                  <div id="marketInventory" class="market-grid"></div>
                </div>
              </div>
            </div>
            <div class="command-card" id="stashCommandCard">
              <div class="command-title" id="stashCommandTitle">Vault Command Card</div>
              <div id="stashDetail" class="command-hint">Select stash items to transfer, break down, or sell.</div>
              <div class="action-grid" id="stashItemActions"></div>
            </div>
            <div id="stashActions" class="stack"></div>
          </div>
          <p class="small">Move rewards into long-term storage, or liquidate overflow for credits.</p>
        </section>
      </div>
    </div>
    <div class="signal-log" id="codexPanel">
      <div class="signal-log__controls">
        <button class="btn-secondary" id="codexToggle" type="button">Show last 20</button>
      </div>
      <div class="log" id="codex"></div>
    </div>
  </div>

  <script>
    /* ================= STATE & CONSTANTS ================= */
    const SAVE_KEY='zeroLuxSave';
    const SAVE_VERSION=2;
    const CODEX_VISIBLE_LIMIT=20;
    const CODEX_HISTORY_LIMIT=120;
    const ELDER_MISSION_ID='safehouse-elders';
    const ELDER_ADVICE=[
      'Keep one energy bar in reserve; emergency actions cost more than you think.',
      'Scrap weighs less than credits, but credits open gates.',
      'Morale drops faster than hunger after a bad run—rest before you spiral.',
      'Stamina recovery is quicker when you stop in safe zones.',
      'Radiation shield buys time, not safety; reapply before deep dives.',
      'Cold drains stamina; warm layers matter more than armor on long walks.',
      'Keys open caches, but the noise draws trouble—move fast after unlocking.',
      'Low-risk missions still roll for mishaps; never go in empty.',
      'If your pack is full, a stash upgrade beats another risky run.',
      'Energy regen between ops is slower while wounded—patch up first.',
      'Door hints tell you what kind of gear to expect; plan your loadout.',
      'Combat eats time; budget extra energy on high-risk raids.',
      'When the codex goes quiet, check idle dispatches—they may need routing.',
      'Food restores more than hunger; morale steadies with a warm meal.',
      'Use the market when you can; junk in the pack is lost profit.',
      'A balanced loadout lowers risk more than a single rare item.',
      'Always carry one light source; dark halls spike failure rates.',
      'Trade off loot for survival; an extra medkit beats another trinket.',
      'If rads climb over twenty, retreat and cleanse before the next run.',
      'Short runs keep XP climbing without draining morale.',
      'Listen for hums in the bunker—systems online mean safer routes.',
      'Hubs are for planning; do not launch raids until your energy is stable.',
      'Spare filters are worth more than weapons when the air turns bad.',
      'Trust the mission timer; overruns bleed resources fast.',
      'A calm mind wins fights—enter combat only when your stamina is ready.'
    ];
    const createIdleSlot=()=>({active:false,id:null,startedAt:null,durationMs:0,etaMinutes:0,completed:false,statusMessage:''});
    const createDefaultState=()=>({
      hp:92,maxHp:100,
      stamina:90,maxStamina:100,
      morale:62,maxMorale:100,
      hunger:15,maxHunger:100,
      thirst:20,maxThirst:100,
      energy:72,maxEnergy:100,
      rads:0,
      radShield:0,
      radShieldUntil:null,
      bodyTemp:98,maxBodyTemp:104,
      scrap:6,
      credits:50,
      keys:1,
      level:1,xp:0,nextLevelXp:80,
      day:1,timeMinutes:6*60,
      backpackLimit:0,
      stashLimit:40,
      stashUpgradeLevel:0,
      craftingPage:0,
      inventoryPage:0,
      stashPage:0,
      loadoutPage:0,
      marketPage:0,
      inventory:["rusty flashlight","ration bar","scrap wiring"],
      equipped:['basic backpack'],
      codex:["Hub online. Reward bays clear."],
      codexExpanded:false,
      stash:{name:'Vault Stash',items:[]},
      marketAccess:{active:false,zoneId:null},
      idleOps:[createIdleSlot()],
      idleRewards:[],
      flags:new Set(),
      elderAdviceIndex:0,
      paused:false,
      pausedAt:null,
      lastHungerDamageAt:null,
      lastThirstDamageAt:null,
      doorsPage:0,
      doorsCollapsed:true,
      zone:{id:'drift-yard',name:'Drift Yard',risk:'low',desc:'Low-risk salvage corridor. Ideal for stocking up on scrap and common gear.',sceneId:null},
      screen:'main',
      travel:{active:false,endsAt:null,target:null},
      mission:{active:false,type:null,raid:null,startedAt:null,endsAt:null,completed:false,success:null,summary:'',rewards:[],statusMessage:'',location:null,fleeing:false,fleeEndsAt:null,pendingResolution:null,xpReward:0,rewardEffects:{success:'',fail:''},questMeta:null,combat:null,sceneTarget:null},
      inventoryScreen:'backpack',
      stashScreen:'vault',
      selected:{source:null,item:null}
    });
    const hydrateIdleOps=(savedIdleOps,flags)=>{
      const slots=Array.isArray(savedIdleOps)
        ? savedIdleOps.map(slot=>({ ...createIdleSlot(), ...slot }))
        : savedIdleOps && typeof savedIdleOps==='object'
          ? [{ ...createIdleSlot(), ...savedIdleOps }]
          : [createIdleSlot()];
      const limit=flags.has('ganglands-telecom') ? 2 : 1;
      while(slots.length<limit){
        slots.push(createIdleSlot());
      }
      if(slots.length>limit){
        slots.length=limit;
      }
      slots.forEach(slot=>{
        const idleStartedAt=Number(slot.startedAt);
        const idleDurationMs=Number(slot.durationMs);
        slot.startedAt=Number.isFinite(idleStartedAt) ? idleStartedAt : null;
        slot.durationMs=Number.isFinite(idleDurationMs) ? idleDurationMs : 0;
        slot.completed=Boolean(slot.completed);
        slot.active=Boolean(slot.active);
      });
      return slots;
    };

    function getMainHubZone(){
      const safehouseExp=expansions.safehouse;
      if(safehouseExp){
        const targetScene=safehouseExp.door?.target || Object.keys(safehouseExp.scenes || {})[0] || null;
        return {
          id:safehouseExp.meta?.id || 'safehouse',
          name:safehouseExp.meta?.name || 'Safe House',
          risk:getZoneRiskForExp(safehouseExp,'low'),
          desc:safehouseExp.door?.desc || safehouseExp.door?.hint || safehouseExp.meta?.summary || 'Safehouse hub.',
          sceneId:targetScene
        };
      }
      const fallback=createDefaultState().zone;
      return {...fallback};
    }
    const hydrateState=(saved)=>{
      const base=createDefaultState();
      if(!saved || typeof saved!=='object') return base;
      const merged={...base,...saved};
      merged.flags=new Set(saved.flags || []);
      merged.stash={...base.stash,...(saved.stash||{})};
      merged.marketAccess={...base.marketAccess,...(saved.marketAccess||{})};
      merged.idleOps=hydrateIdleOps(saved.idleOps,merged.flags);
      merged.idleRewards=Array.isArray(saved.idleRewards) ? [...saved.idleRewards] : [];
      merged.zone={...base.zone,...(saved.zone||{})};
      merged.travel={...base.travel,...(saved.travel||{})};
      merged.mission={...base.mission,...(saved.mission||{})};
      merged.selected={...base.selected,...(saved.selected||{})};
      const travelEndsAt=Number(merged.travel.endsAt);
      merged.travel.endsAt=Number.isFinite(travelEndsAt) ? travelEndsAt : null;
      const missionStartedAt=Number(merged.mission.startedAt);
      const missionEndsAt=Number(merged.mission.endsAt);
      merged.mission.startedAt=Number.isFinite(missionStartedAt) ? missionStartedAt : null;
      merged.mission.endsAt=Number.isFinite(missionEndsAt) ? missionEndsAt : null;
      merged.radShield=Number.isFinite(Number(merged.radShield)) ? Number(merged.radShield) : 0;
      const elderAdviceIndex=Number(merged.elderAdviceIndex);
      merged.elderAdviceIndex=Number.isFinite(elderAdviceIndex)
        ? Math.max(0,Math.min(ELDER_ADVICE.length,elderAdviceIndex))
        : 0;
      const radShieldUntil=Number(merged.radShieldUntil);
      merged.radShieldUntil=Number.isFinite(radShieldUntil) ? radShieldUntil : null;
      merged.paused=Boolean(merged.paused);
      const pausedAt=Number(merged.pausedAt);
      merged.pausedAt=Number.isFinite(pausedAt) ? pausedAt : null;
      if(!merged.paused){
        merged.pausedAt=null;
      }
      const doorsPage=Number(merged.doorsPage);
      merged.doorsPage=Number.isFinite(doorsPage) && doorsPage>=0 ? doorsPage : 0;
      merged.doorsCollapsed=Boolean(merged.doorsCollapsed);
      return merged;
    };
    const loadSavedState=()=>{
      try{
        const raw=localStorage.getItem(SAVE_KEY);
        if(!raw) return null;
        return hydrateState(JSON.parse(raw));
      }catch(err){
        console.warn('Save load failed.',err);
        return null;
      }
    };
    let pendingSave=null;
    let lastSaveAt=0;
    const saveGame=()=>{
      try{
        const payload={...state,flags:Array.from(state.flags||[]),saveVersion:SAVE_VERSION};
        localStorage.setItem(SAVE_KEY,JSON.stringify(payload));
        lastSaveAt=Date.now();
      }catch(err){
        console.warn('Save failed.',err);
      }
    };
    const savedState=loadSavedState();
    let state=createDefaultState();
    let allowAutosave=!savedState;
    const isHubMission=(raid)=>raid?.hub===true || raid?.hub==='true';
    const isElderAdviceMission=(raid)=>raid?.id===ELDER_MISSION_ID;
    const isElderAdviceExhausted=()=>state.elderAdviceIndex>=ELDER_ADVICE.length;
    const grantElderAdvice=()=>{
      if(isElderAdviceExhausted()) return null;
      const advice=ELDER_ADVICE[state.elderAdviceIndex];
      state.elderAdviceIndex=Math.min(state.elderAdviceIndex+1,ELDER_ADVICE.length);
      const exhausted=isElderAdviceExhausted();
      if(exhausted){
        state.flags.add('safehouse-elders-exhausted');
      }
      return {advice,exhausted};
    };
    const MISSION_OVERRUN_MULTIPLIER=2;
    const SAVE_DEBOUNCE_MS=1500;
    const SAVE_MIN_INTERVAL_MS=8000;
    const queueSave=({force=false}={})=>{
      if(!allowAutosave) return;
      if(force){
        if(pendingSave){
          clearTimeout(pendingSave);
          pendingSave=null;
        }
        saveGame();
        return;
      }
      if(pendingSave) return;
      const now=Date.now();
      const elapsed=now-lastSaveAt;
      const delay=Math.max(0,elapsed>=SAVE_MIN_INTERVAL_MS ? SAVE_DEBOUNCE_MS : SAVE_MIN_INTERVAL_MS-elapsed);
      pendingSave=setTimeout(()=>{
        pendingSave=null;
        saveGame();
      },delay);
    };

    const updateVisualViewportOffset=()=>{
      if(!window.visualViewport){
        document.documentElement.style.setProperty('--visual-viewport-offset','0px');
        return;
      }
      const { offsetTop, height }=window.visualViewport;
      const layoutHeight=window.innerHeight;
      const visualBottom=offsetTop + height;
      const offset=Math.max(0, layoutHeight - visualBottom);
      document.documentElement.style.setProperty('--visual-viewport-offset',`${offset}px`);
    };

    if(window.visualViewport){
      window.visualViewport.addEventListener('resize', updateVisualViewportOffset);
      window.visualViewport.addEventListener('scroll', updateVisualViewportOffset);
    }
    window.addEventListener('resize', updateVisualViewportOffset);
    updateVisualViewportOffset();

    const ITEM_CATALOG={
      'basic backpack':{type:'armor',slot:'backpack',rarity:'common',value:6,mods:{carryBonus:6,insulation:0.1}},
      'rusty flashlight':{type:'tool',slot:'tool',rarity:'common',value:6,mods:{riskMod:-0.02}},
      'cargo pants':{type:'armor',slot:'pants',rarity:'common',value:7,mods:{insulation:0.4},breakdown:{items:{'cloth scraps':4}}},
      'field backpack':{type:'armor',slot:'backpack',rarity:'uncommon',value:14,mods:{carryBonus:9,insulation:0.2}},
      'flare':{type:'tool',slot:'tool',rarity:'uncommon',value:10,mods:{lootBonus:0.04}},
      'patch kit':{type:'tool',slot:'tool',rarity:'uncommon',value:12,mods:{riskMod:-0.04}},
      'patch-kit':{type:'tool',slot:'tool',rarity:'uncommon',value:12,mods:{riskMod:-0.04}},
      'utility coat':{type:'armor',slot:'chest',rarity:'uncommon',value:12,mods:{staminaBonus:1,insulation:0.8},breakdown:{items:{'cloth scraps':6}}},
      'microcell':{type:'tool',slot:'tool',rarity:'rare',value:22,mods:{idleSpeed:0.15,energyRegen:1,staminaBonus:2}},
      'rigged backpack':{type:'armor',slot:'backpack',rarity:'rare',value:24,mods:{carryBonus:12,insulation:0.3}},
      'bandage':{type:'consumable',rarity:'common',value:4,effect:'hp+8'},
      'ration bar':{type:'consumable',rarity:'common',value:3,effect:'hunger-12,morale+2'},
      'water flask':{type:'consumable',rarity:'common',value:4,effect:'thirst-12'},
      'spark tonic':{type:'consumable',rarity:'uncommon',value:8,effect:'energy+18,stamina+6'},
      'scrap wiring':{type:'junk',rarity:'common',value:2,salvage:2,stackable:true},
      'scrap bundle':{type:'junk',rarity:'common',value:1,salvage:1,stackable:true},
      'wire spool':{type:'junk',rarity:'common',value:2,salvage:2,stackable:true},
      'cloth scraps':{type:'junk',rarity:'common',value:1,salvage:1,stackable:true},
      'plastic shards':{type:'junk',rarity:'common',value:1,salvage:1,stackable:true},
      'electronics bits':{type:'junk',rarity:'common',value:3,salvage:2,stackable:true},
      'old coin':{type:'junk',rarity:'uncommon',value:6,salvage:1},
      'lockbox key':{type:'key',rarity:'rare',value:18},
      'manager room key':{type:'key',rarity:'rare',value:20},
      'storage room key':{type:'key',rarity:'rare',value:20},
      'security supply room key':{type:'key',rarity:'rare',value:22},
      'director armory key':{type:'key',rarity:'rare',value:24},
      'bunker armory key':{type:'key',rarity:'rare',value:19},
      'relay crystal':{type:'junk',rarity:'rare',value:20,salvage:6},
      'drone core':{type:'tool',slot:'tool',rarity:'epic',value:32,mods:{lootBonus:0.08,energyRegen:2}},
      'fusion core shard':{type:'junk',rarity:'legendary',value:60,salvage:12},
      'scrapboss helm':{type:'armor',slot:'helmet',rarity:'legendary',value:85,mods:{moraleBonus:4,insulation:0.6},breakdown:{items:{'cloth scraps':5,'scrap wiring':2}}},
      'warlord helm':{type:'armor',slot:'helmet',rarity:'legendary',value:85,mods:{moraleBonus:4,insulation:0.6},breakdown:{items:{'cloth scraps':4,'scrap wiring':2}}},
      'safehouse warden coat':{type:'armor',slot:'chest',rarity:'legendary',value:90,mods:{staminaBonus:4,insulation:1}},
      'facility command badge':{type:'tool',slot:'tool',rarity:'legendary',value:95,mods:{lootBonus:0.12,energyRegen:2}},
      'riot jacket':{type:'armor',slot:'chest',rarity:'legendary',value:88,mods:{insulation:0.9,moraleBonus:2},breakdown:{items:{'cloth scraps':6,'plastic shards':2}}},
      'field rations':{type:'consumable',rarity:'common',value:5,effect:'hunger-16,stamina+4'},
      'water canister':{type:'consumable',rarity:'common',value:5,effect:'thirst-18,temp-1'},
      'painkillers':{type:'consumable',rarity:'uncommon',value:11,effect:'hp+12,morale+2'},
      'glowing herbs':{type:'consumable',rarity:'uncommon',value:10,effect:'rads-4,temp+1'},
      'military rations':{type:'consumable',rarity:'uncommon',value:12,effect:'hunger-22,stamina+6'},
      'coil battery':{type:'tool',slot:'tool',rarity:'uncommon',value:13,mods:{energyRegen:1}},
      'spare filter':{type:'tool',slot:'tool',rarity:'uncommon',value:12,mods:{riskMod:-0.03}},
      'copper wire':{type:'junk',rarity:'common',value:4,salvage:3,stackable:true},
      'reactor shard':{type:'junk',rarity:'rare',value:34,salvage:10},
      'exo brace':{type:'armor',slot:'gloves',rarity:'rare',value:28,mods:{staminaBonus:4,insulation:0.4}},
      'scavenger boots':{type:'armor',slot:'shoes',rarity:'uncommon',value:16,mods:{staminaBonus:2},breakdown:{items:{'cloth scraps':4,'scrap bundle':1}}},
      'underground map':{type:'tool',slot:'tool',rarity:'uncommon',value:15,mods:{riskMod:-0.05,lootBonus:0.03}},
      'data cartridge':{type:'tool',slot:'tool',rarity:'rare',value:26,mods:{lootBonus:0.06}},
      'signal wristband':{type:'tool',slot:'tool',rarity:'uncommon',value:14,mods:{moraleBonus:2}},
      'riot shield':{type:'weapon',slot:'weapon',rarity:'rare',value:30,mods:{riskMod:-0.06,insulation:0.5}},
      'flare paint':{type:'tool',slot:'tool',rarity:'uncommon',value:13,mods:{lootBonus:0.05}},
      'flashbang':{type:'tool',slot:'tool',rarity:'rare',value:24,mods:{combatBonus:5}},
      'foam canister':{type:'tool',slot:'tool',rarity:'uncommon',value:15,mods:{combatBonus:3,riskMod:-0.02}},
      'viral clip drive':{type:'junk',rarity:'rare',value:28,salvage:7},
      'limited hoodie':{type:'armor',slot:'chest',rarity:'rare',value:27,mods:{moraleBonus:3,insulation:0.6},breakdown:{items:{'cloth scraps':5}}},
      'payload crate':{type:'junk',rarity:'uncommon',value:18,salvage:5},
      'stun baton':{type:'weapon',slot:'weapon',rarity:'rare',value:29,mods:{combatBonus:6}},
      'mystery supply':{type:'junk',rarity:'rare',value:25,salvage:6},
      'salvaged tech':{type:'junk',rarity:'rare',value:27,salvage:8},
      'shock gel':{type:'consumable',rarity:'uncommon',value:12,effect:'hp+10,temp+1'},
      'overclock chip':{type:'tool',slot:'tool',rarity:'rare',value:31,mods:{energyRegen:2,combatBonus:4}},
      'insulated cloak':{type:'armor',slot:'chest',rarity:'rare',value:26,mods:{insulation:1.1,riskMod:-0.02},breakdown:{items:{'cloth scraps':6}}},
      'scavenger harness':{type:'armor',slot:'chest',rarity:'uncommon',value:17,mods:{staminaBonus:2}},
      'hardened canteen':{type:'consumable',rarity:'uncommon',value:9,effect:'thirst-16,stamina+3'},
      'ember ration':{type:'consumable',rarity:'common',value:6,effect:'hunger-14,temp+2'},
      'signal jammer':{type:'tool',slot:'tool',rarity:'rare',value:33,mods:{riskMod:-0.07,combatBonus:2}},

      /* base items */
      'pocket pack':{type:'armor',slot:'backpack',rarity:'common',value:18,mods:{carryBonus:7}},
      'scout daypack':{type:'armor',slot:'backpack',rarity:'uncommon',value:26,mods:{carryBonus:8}},
      'salvage tote':{type:'armor',slot:'backpack',rarity:'uncommon',value:24,mods:{carryBonus:9}},
      'expedition frame pack':{type:'armor',slot:'backpack',rarity:'rare',value:44,mods:{carryBonus:14}},
      'jury-rigged blade':{type:'weapon',slot:'weapon',rarity:'common',value:9,mods:{combatBonus:3}},
      'scrap spear':{type:'weapon',slot:'weapon',rarity:'uncommon',value:18,mods:{combatBonus:5,lootBonus:0.01}},
      'pipe rifle':{type:'weapon',slot:'weapon',rarity:'rare',value:32,mods:{combatBonus:7,riskMod:-0.01}},
      'compact medkit':{type:'consumable',rarity:'uncommon',value:14,effect:'hp+18'},
      'filtered water pack':{type:'consumable',rarity:'uncommon',value:13,effect:'thirst-20,rads-2'},
      'anti-rad serum':{type:'consumable',rarity:'rare',value:32,effect:'rads-40,radshield+25'},
      'morale patch':{type:'consumable',rarity:'common',value:7,effect:'morale+8,stamina+2'},

      /* iron ward */
      'ledger-etched compass':{type:'tool',slot:'tool',rarity:'uncommon',value:19,mods:{riskMod:-0.04,lootBonus:0.02}},
      'clocktower chime':{type:'junk',rarity:'uncommon',value:16,salvage:4},
      'iron ward seals':{type:'junk',rarity:'common',value:3,salvage:2,stackable:true},
      'market shock knife':{type:'weapon',slot:'weapon',rarity:'rare',value:34,mods:{combatBonus:6,lootBonus:0.02}},
      'tarpaulin roll':{type:'junk',rarity:'common',value:4,salvage:2,stackable:true},

      /* cold shelter */
      'thermal wrap':{type:'consumable',rarity:'common',value:6,effect:'temp+3,stamina+4'},
      'bunker schematics':{type:'tool',slot:'tool',rarity:'uncommon',value:21,mods:{riskMod:-0.02}},
      'lantern oil':{type:'junk',rarity:'common',value:2,salvage:1,stackable:true},
      'stabilizer brace':{type:'armor',slot:'gloves',rarity:'uncommon',value:20,mods:{staminaBonus:3,insulation:0.3}},
      'cache latch':{type:'junk',rarity:'uncommon',value:10,salvage:3},

      /* blackwood expanse */
      'spore lantern':{type:'tool',slot:'tool',rarity:'uncommon',value:22,mods:{riskMod:-0.03,lootBonus:0.03}},
      'rad moss poultice':{type:'consumable',rarity:'uncommon',value:15,effect:'hp+10,rads-5,temp+1'},
      'hardened bark plate':{type:'armor',slot:'chest',rarity:'uncommon',value:18,mods:{insulation:0.7,riskMod:-0.02}},
      'monsoon canteen':{type:'consumable',rarity:'rare',value:23,effect:'thirst-24,temp+1'},
      'feral talon':{type:'junk',rarity:'rare',value:24,salvage:7},

      /* downtown portland */
      'floodgate keycard':{type:'key',rarity:'rare',value:22},
      'signal flare rack':{type:'tool',slot:'tool',rarity:'uncommon',value:20,mods:{lootBonus:0.05,moraleBonus:1}},
      'riot-line tape':{type:'junk',rarity:'common',value:3,salvage:2,stackable:true},
      'bridge-runner pack':{type:'armor',slot:'backpack',rarity:'uncommon',value:28,mods:{carryBonus:10}},
      'arc pistol':{type:'weapon',slot:'weapon',rarity:'rare',value:38,mods:{combatBonus:8,energyRegen:1}},

      /* underground bunker additions */
      'bunker stew pouch':{type:'consumable',rarity:'common',value:5,effect:'hunger-10,temp+1'},
      'tinned beans':{type:'consumable',rarity:'common',value:4,effect:'hunger-8'},
      'stale biscuits':{type:'consumable',rarity:'common',value:3,effect:'hunger-6,morale+1'},
      'canteen tablets':{type:'consumable',rarity:'uncommon',value:9,effect:'thirst-14,rads-1'},
      'barracks coffee':{type:'consumable',rarity:'uncommon',value:10,effect:'energy+10,stamina+4'},
      'moth-eaten scarf':{type:'armor',slot:'chest',rarity:'common',value:8,mods:{insulation:0.4},breakdown:{items:{'cloth scraps':3}}},
      'bunker fatigues':{type:'armor',slot:'pants',rarity:'common',value:9,mods:{insulation:0.3},breakdown:{items:{'cloth scraps':4}}},
      'reinforced gloves':{type:'armor',slot:'gloves',rarity:'uncommon',value:16,mods:{staminaBonus:2,insulation:0.2}},
      'mess hall apron':{type:'armor',slot:'chest',rarity:'common',value:7,mods:{insulation:0.2},breakdown:{items:{'cloth scraps':2}}},
      'locker prybar':{type:'weapon',slot:'weapon',rarity:'common',value:8,mods:{combatBonus:2}},
      'service wrench':{type:'weapon',slot:'weapon',rarity:'uncommon',value:16,mods:{combatBonus:4}},
      'flashline map':{type:'tool',slot:'tool',rarity:'uncommon',value:15,mods:{riskMod:-0.03,lootBonus:0.02}},

      /* abandoned mall additions */
      'mall snack pack':{type:'consumable',rarity:'common',value:5,effect:'hunger-10,morale+2'},
      'instant noodles':{type:'consumable',rarity:'common',value:4,effect:'hunger-9,temp+1'},
      'citrus soda':{type:'consumable',rarity:'common',value:4,effect:'thirst-10,energy+4'},
      'security poncho':{type:'armor',slot:'chest',rarity:'uncommon',value:18,mods:{insulation:0.5,riskMod:-0.02}},
      'store runner shoes':{type:'armor',slot:'shoes',rarity:'uncommon',value:16,mods:{staminaBonus:2}},
      'queue jacket':{type:'armor',slot:'chest',rarity:'uncommon',value:17,mods:{moraleBonus:1,insulation:0.4}},
      'sale-day hoodie':{type:'armor',slot:'chest',rarity:'common',value:9,mods:{moraleBonus:1,insulation:0.3}},
      'loading hook':{type:'weapon',slot:'weapon',rarity:'uncommon',value:19,mods:{combatBonus:5}},
      'glass shard shiv':{type:'weapon',slot:'weapon',rarity:'common',value:10,mods:{combatBonus:3}},
      'kiosk toolkit':{type:'tool',slot:'tool',rarity:'uncommon',value:16,mods:{lootBonus:0.04}},
      'power coupler':{type:'tool',slot:'tool',rarity:'rare',value:28,mods:{energyRegen:1,lootBonus:0.04}},
      'spark kiosk battery':{type:'tool',slot:'tool',rarity:'uncommon',value:15,mods:{energyRegen:1}},

      /* metro ganglands additions */
      'rail spike mace':{type:'weapon',slot:'weapon',rarity:'uncommon',value:20,mods:{combatBonus:6}},
      'shanty revolver':{type:'weapon',slot:'weapon',rarity:'rare',value:36,mods:{combatBonus:8}},
      'signal jammer coil':{type:'tool',slot:'tool',rarity:'rare',value:32,mods:{riskMod:-0.06,lootBonus:0.02}},
      'turnstile shield':{type:'weapon',slot:'weapon',rarity:'rare',value:34,mods:{riskMod:-0.05,insulation:0.4}},
      'trackside vest':{type:'armor',slot:'chest',rarity:'uncommon',value:18,mods:{staminaBonus:1,insulation:0.4}},
      'graffiti cloak':{type:'armor',slot:'chest',rarity:'rare',value:30,mods:{moraleBonus:3,insulation:0.7}},
      'metro runner boots':{type:'armor',slot:'shoes',rarity:'uncommon',value:19,mods:{staminaBonus:3}},
      'gang patchwork pants':{type:'armor',slot:'pants',rarity:'common',value:10,mods:{insulation:0.3}},
      'torchlight lantern':{type:'tool',slot:'tool',rarity:'uncommon',value:18,mods:{lootBonus:0.04}},
      'black market battery':{type:'tool',slot:'tool',rarity:'rare',value:30,mods:{energyRegen:2}},
      'coin string':{type:'tool',slot:'tool',rarity:'uncommon',value:17,mods:{moraleBonus:2}},
      'rail map rig':{type:'tool',slot:'tool',rarity:'uncommon',value:18,mods:{riskMod:-0.04}},
      'scrapper mask':{type:'armor',slot:'helmet',rarity:'uncommon',value:17,mods:{insulation:0.3,riskMod:-0.02}},
      'barter satchel':{type:'armor',slot:'backpack',rarity:'uncommon',value:26,mods:{carryBonus:9}},

      /* government facility additions */
      'security visor':{type:'armor',slot:'helmet',rarity:'rare',value:34,mods:{riskMod:-0.04,insulation:0.4}},
      'tactical comms rig':{type:'tool',slot:'tool',rarity:'rare',value:34,mods:{lootBonus:0.06,energyRegen:1}},
      'hazmat undersuit':{type:'armor',slot:'chest',rarity:'rare',value:36,mods:{insulation:0.9,riskMod:-0.03}},
      'pulse baton':{type:'weapon',slot:'weapon',rarity:'rare',value:38,mods:{combatBonus:7,riskMod:-0.02}},
      'shock carbine':{type:'weapon',slot:'weapon',rarity:'epic',value:54,mods:{combatBonus:10,energyRegen:1}},
      'response harness':{type:'armor',slot:'chest',rarity:'uncommon',value:20,mods:{staminaBonus:2,insulation:0.5}},
      'facility boots':{type:'armor',slot:'shoes',rarity:'uncommon',value:19,mods:{staminaBonus:2,insulation:0.2}},
      'clearance gloves':{type:'armor',slot:'gloves',rarity:'uncommon',value:18,mods:{staminaBonus:2,insulation:0.2}},
      'access scanner':{type:'tool',slot:'tool',rarity:'uncommon',value:19,mods:{riskMod:-0.04}},
      'secure datapad':{type:'tool',slot:'tool',rarity:'rare',value:30,mods:{lootBonus:0.07}},
      'containment seal kit':{type:'tool',slot:'tool',rarity:'uncommon',value:20,mods:{riskMod:-0.03}},
      'warden longcoat':{type:'armor',slot:'chest',rarity:'legendary',value:96,mods:{staminaBonus:4,insulation:1}},
      'command bracer':{type:'armor',slot:'gloves',rarity:'rare',value:32,mods:{moraleBonus:2,insulation:0.3}},
      'nutri-gel pack':{type:'consumable',rarity:'rare',value:18,effect:'hunger-18,energy+6'},

      /* medical center additions */
      'antiseptic wipes':{type:'consumable',rarity:'common',value:4,effect:'hp+6'},
      'electro bandage':{type:'consumable',rarity:'uncommon',value:12,effect:'hp+14,stamina+2'},
      'clinic IV pack':{type:'consumable',rarity:'rare',value:26,effect:'hp+24'},
      'antiviral vial':{type:'consumable',rarity:'rare',value:24,effect:'hp+12,morale+6'},
      'cooling compress':{type:'consumable',rarity:'common',value:4,effect:'hp+4,temp-2'},
      'sterile gloves':{type:'armor',slot:'gloves',rarity:'uncommon',value:17,mods:{riskMod:-0.02,insulation:0.2}},
      'scrub jacket':{type:'armor',slot:'chest',rarity:'common',value:8,mods:{insulation:0.3}},
      'triage boots':{type:'armor',slot:'shoes',rarity:'uncommon',value:18,mods:{staminaBonus:2,insulation:0.2}},
      'medic satchel':{type:'armor',slot:'backpack',rarity:'uncommon',value:24,mods:{carryBonus:8}},
      'portable scanner':{type:'tool',slot:'tool',rarity:'rare',value:28,mods:{lootBonus:0.05}},
      'triage lamp':{type:'tool',slot:'tool',rarity:'uncommon',value:16,mods:{lootBonus:0.03}},
      'biofilter mask':{type:'armor',slot:'helmet',rarity:'rare',value:30,mods:{riskMod:-0.05,insulation:0.4}},
      'pain suppressant':{type:'consumable',rarity:'uncommon',value:12,effect:'hp+10,morale+3'},
      'hydration drip':{type:'consumable',rarity:'uncommon',value:11,effect:'thirst-18,energy+4'},

      /* safehouse additions */
      'bunk blanket':{type:'armor',slot:'chest',rarity:'common',value:8,mods:{insulation:0.5}},
      'safehouse slippers':{type:'armor',slot:'shoes',rarity:'common',value:6,mods:{staminaBonus:1}},
      'workshop apron':{type:'armor',slot:'chest',rarity:'uncommon',value:16,mods:{insulation:0.4,staminaBonus:1}},
      'tool roll':{type:'tool',slot:'tool',rarity:'uncommon',value:16,mods:{lootBonus:0.03,riskMod:-0.02}},
      'generator capacitor':{type:'tool',slot:'tool',rarity:'rare',value:30,mods:{energyRegen:2}},
      'quiet radio':{type:'tool',slot:'tool',rarity:'uncommon',value:14,mods:{moraleBonus:2}},
      'galley kit':{type:'tool',slot:'tool',rarity:'common',value:8,mods:{lootBonus:0.02}},
      'homebrew stew':{type:'consumable',rarity:'common',value:5,effect:'hunger-10,morale+3'},
      'clean canteen':{type:'consumable',rarity:'common',value:4,effect:'thirst-12,temp-1'},
      'recovery tonic':{type:'consumable',rarity:'rare',value:22,effect:'hp+18,morale+4'},
      'spare belt rig':{type:'armor',slot:'backpack',rarity:'uncommon',value:22,mods:{carryBonus:7}},
      'comfort liner':{type:'armor',slot:'chest',rarity:'uncommon',value:18,mods:{insulation:0.7}},
      'restful mask':{type:'armor',slot:'helmet',rarity:'uncommon',value:15,mods:{moraleBonus:2,insulation:0.2}},
      'training weights':{type:'tool',slot:'tool',rarity:'rare',value:28,mods:{staminaBonus:3}}
    };

    const LOOT_BY_RARITY={
      common:['bandage','ration bar','water flask','scrap wiring','scrap bundle','wire spool','cloth scraps','plastic shards','electronics bits','rusty flashlight','cargo pants','field rations','water canister','copper wire','ember ration','morale patch','pocket pack','jury-rigged blade','iron ward seals','tarpaulin roll','lantern oil','thermal wrap','riot-line tape','bunker stew pouch','tinned beans','stale biscuits','moth-eaten scarf','bunker fatigues','mess hall apron','locker prybar','mall snack pack','instant noodles','citrus soda','sale-day hoodie','glass shard shiv','gang patchwork pants','antiseptic wipes','cooling compress','scrub jacket','bunk blanket','safehouse slippers','galley kit','homebrew stew','clean canteen'],
      uncommon:['flare','patch kit','patch-kit','old coin','spark tonic','utility coat','field backpack','coil battery','spare filter','scavenger boots','underground map','signal wristband','flare paint','foam canister','scavenger harness','hardened canteen','shock gel','salvage tote','scout daypack','scrap spear','compact medkit','filtered water pack','ledger-etched compass','clocktower chime','bunker schematics','stabilizer brace','cache latch','spore lantern','rad moss poultice','hardened bark plate','signal flare rack','bridge-runner pack','canteen tablets','barracks coffee','reinforced gloves','service wrench','flashline map','security poncho','store runner shoes','queue jacket','loading hook','kiosk toolkit','spark kiosk battery','rail spike mace','trackside vest','metro runner boots','torchlight lantern','coin string','rail map rig','scrapper mask','barter satchel','response harness','facility boots','clearance gloves','access scanner','containment seal kit','sterile gloves','triage boots','medic satchel','triage lamp','pain suppressant','hydration drip','workshop apron','tool roll','quiet radio','spare belt rig','comfort liner','restful mask'],
      rare:['microcell','lockbox key','manager room key','storage room key','security supply room key','director armory key','bunker armory key','relay crystal','rigged backpack','exo brace','reactor shard','data cartridge','riot shield','flashbang','limited hoodie','stun baton','mystery supply','salvaged tech','overclock chip','insulated cloak','signal jammer','viral clip drive','expedition frame pack','pipe rifle','market shock knife','monsoon canteen','feral talon','floodgate keycard','arc pistol','anti-rad serum','power coupler','shanty revolver','signal jammer coil','turnstile shield','graffiti cloak','black market battery','security visor','tactical comms rig','hazmat undersuit','pulse baton','secure datapad','command bracer','nutri-gel pack','clinic IV pack','antiviral vial','portable scanner','biofilter mask','recovery tonic','generator capacitor','training weights'],
      epic:['drone core','shock carbine'],
      legendary:['fusion core shard','scrapboss helm','warlord helm','safehouse warden coat','facility command badge','riot jacket','warden longcoat']
    };

    const RAID_TEMPLATES=[
      {id:'quick',label:'Quick Grab',desc:'Fast sweep for low-tier gear.',time:6,energy:8,loot:2,risk:'low'},
      {id:'deep',label:'Deep Sweep',desc:'Longer push with higher-value crates.',time:12,energy:14,loot:3,risk:'medium'},
      {id:'hazard',label:'Hazard Drift',desc:'Pressurized route for rare tech.',time:16,energy:18,loot:4,risk:'high'},
      {id:'vault',label:'Lockbox Crack',desc:'Spend a key to crack sealed cache.',time:10,energy:10,loot:3,risk:'high',key:1}
    ];

    const ACTION_TIMES={camp:10};
    const RAD_SHIELD_DURATION_MINUTES=12*60;
    const RAD_DANGER_THRESHOLD=20;
    const NEED_DAMAGE_THRESHOLD=65;
    const NEED_DAMAGE_INTERVAL_MINUTES=90;
    const DOORS_PAGE_SIZE=4;
    const riskTable={low:0.08,medium:0.2,high:0.32,deadly:0.45};
    const riskRank={low:1,medium:2,high:3,deadly:4};
    const riskLevels=['low','medium','high','deadly'];
    const riskClassList=['risk-low','risk-medium','risk-high','risk-deadly'];
    const lowerRisk=(risk)=>{
      const idx=riskLevels.indexOf(risk);
      if(idx<=0) return riskLevels[0];
      return riskLevels[idx-1] || risk;
    };
    const applyRiskClasses=(el,risk)=>{
      if(!el) return;
      riskClassList.forEach(cls=>el.classList.remove(cls));
      const normalized=String(risk || 'low').toLowerCase();
      const target=riskClassList.includes(`risk-${normalized}`) ? `risk-${normalized}` : 'risk-low';
      el.classList.add(target);
    };
    const getZoneRiskForExp=(exp,baseRisk)=>{
      if(exp?.meta?.id==='abandoned_mall' && state.flags.has('mall-power')){
        return lowerRisk(baseRisk);
      }
      return baseRisk;
    };
    const getDoorLootScore=(exp)=>{
      const missionLoot=Array.isArray(exp?.missions) ? exp.missions.map(m=>Number(m.loot || 0)) : [];
      const questLoot=Array.isArray(exp?.quests) ? exp.quests.map(q=>Number(q.loot || 0)) : [];
      return Math.max(0,...missionLoot,...questLoot);
    };
    const getSortedDoors=()=>{
      return Object.values(expansions)
        .filter(exp=>exp?.meta?.id)
        .sort((a,b)=>{
          const riskA=getZoneRiskForExp(a,a.door?.risk || 'low');
          const riskB=getZoneRiskForExp(b,b.door?.risk || 'low');
          const riskCompare=(riskRank[riskA] || 1) - (riskRank[riskB] || 1);
          if(riskCompare) return riskCompare;
          const lootCompare=getDoorLootScore(b) - getDoorLootScore(a);
          if(lootCompare) return lootCompare;
          const nameA=(a.meta?.name || '').toLowerCase();
          const nameB=(b.meta?.name || '').toLowerCase();
          return nameA.localeCompare(nameB);
        });
    };
    const expansions={};
    const EXPANSION_MANIFEST=[
      {id:'safehouse',name:'Safe House',file:'expansions/safehouse.txt'},
      {id:'underground_bunker',name:'Abandoned Underground Bunker System',file:'expansions/underground_bunker.txt'},
      {id:'metro_ganglands',name:'Ganglands Metro Shanty',file:'expansions/metro_ganglands.txt'},
      {id:'government_facility',name:'Abandoned Government Facility',file:'expansions/government_facility.txt'},
      {id:'medical_center',name:'Medical Center',file:'expansions/medical_center.txt'},
      {id:'abandoned_mall',name:'Abandoned Mall',file:'expansions/abandoned_mall.txt'}
    ];
    const EMBEDDED_EXPANSIONS={
      safehouse:`@expansion
id:safehouse
name:Safe House
summary:A reinforced bunker hub with bunks, a trade counter, and a humming generator wall. No loot runs here—just recovery and planning.
shop:true

@door
label:Safe House Airlock
hint:rest, shop, recovery
risk:low
note:The airlock seals and the bunker hum steadies your breathing.
target:commons

@scene commons
title:Safe House Commons
desc:Warm lights, clean water, and the trade counter keep the crew steady between runs.
tags:Safe / Hub
option:Rest in the bunks => commons | risk:low | time:6 | reward:rested | success:hp+12,stamina+14,morale+6,log:The bunk warmth sinks into your bones. | fail:morale-2,log:Sleep won't come tonight.
option:Reset the loadout bench => commons | risk:low | time:5 | reward:prep | success:energy+6,log:You tighten straps and reset your kit. | fail:stamina-2,log:The bench clamps fail you.

@mission
id:safehouse-elders
label:Talk to the bunker elders for advice
desc:Sit with the bunker elders to trade stories and learn hard-won survival wisdom.
risk:low
time:6
energy:6
loot:0
reward:elder advice
combatChance:0
hub:true

@quest
id:safehouse-vents
title:Fix the ventilation system
desc:Patch the corroded vent intake so the bunker can cycle clean air again.
risk:medium
time:9
energy:12
loot:1
lootType:maintenance cache
reward:ventilation restored
success:item:spare filter,item:tool roll,credits+8,morale+6,flag:safehouse-vents,log:The fans spin up and the air clears. Maintenance dispatches are back online.
fail:temp-3,morale-4
flag:safehouse-vents
once:true`,
      underground_bunker:`@expansion
id:underground_bunker
name:Abandoned Underground Bunker System
summary:A low-risk labyrinth of concrete corridors and shuttered barracks. Easy opponents, low-tier food, and worn clothing line the halls.
shop:false

@door
label:Bunker Access Hatch
hint:low-risk combat, food runs, clothing caches, telecom job
risk:low
note:Condensation beads on the hatch as you descend into the bunker system.
target:mess-hall

@scene mess-hall
title:Mess Hall
desc:Metal tables and dented lockers sit beneath flickering emergency lights.
tags:Bunker / Low risk
option:Search the ration cages => mess-hall | risk:low | time:6 | reward:low-tier food | success:item:ration bar,item:bunker stew pouch,log:You salvage sealed rations from a rusted cage. | fail:hunger+6,log:Only spoiled tins remain.
option:Strip the barracks lockers => mess-hall | risk:low | time:7 | reward:clothing scraps | success:item:bunker fatigues,item:moth-eaten scarf,log:You gather worn but usable uniforms. | fail:hp-3,log:A locker door clips your shoulder.

@mission
id:bunker-quick
label:Mess hall sweep
desc:Low-risk sweep for food packs and basic clothing.
risk:low
time:9
energy:10
loot:2
lootType:low-tier food & clothing

@mission
id:bunker-deep
label:Lower tunnel scavenge
desc:Push deeper for better rations and intact gear.
risk:medium
time:12
energy:14
loot:3
lootType:sealed kits

@mission
id:bunker-armory
label:Armory annex breach
desc:Use the bunker armory key to crack the sealed weapons annex for richer loot.
risk:medium
time:13
energy:16
loot:4
lootType:armory kits & rations
key:1
combatChance:0.5

@quest
id:bunker-telecom-1
title:Trace the telecom line
desc:Follow the severed line through the service corridors and map the damage.
risk:low
time:8
energy:10
loot:1
lootType:signal trace
reward:telecom trace
success:credits+8,flag:bunker-telecom-1,log:You map the cut and mark a clear path to the relay core.
fail:morale-3
flag:bunker-telecom-1
once:true

@quest
id:bunker-telecom-2
title:Restart the relay core
desc:Power the relay core back on—expect a guaranteed fight with a pair of bunker hostiles.
risk:medium
time:12
energy:16
loot:2
lootType:relay salvage
reward:relay restored
success:item:coil battery,item:flashline map,credits+12,flag:bunker-telecom-2,log:The relay crackles to life. New idle dispatch options unlock.
fail:hp-6,morale-4
flag:bunker-telecom-2
requires:bunker-telecom-1
combat:true
once:true`,
      metro_ganglands:`@expansion
id:metro_ganglands
name:Ganglands Metro Shanty
summary:A mid-risk warren of rail tunnels turned into a shanty bazaar. Mid-tier combatants guard clothing and weapons caches.
unlockCost:50
shop:true

@door
label:Ganglands Turnstile
hint:mid-tier gear, weapons, telecom job
risk:medium
note:Graffiti and torchlight guide you into the rail shanty.
target:concourse

@scene concourse
title:Shanty Concourse
desc:Ticket booths are barricaded into gang posts and scrap stalls.
tags:Metro / Hostile
option:Pay for a safe route => concourse | risk:low | time:6 | reward:safe passage | success:credits-6,log:A toll buys a quieter lane. | fail:hp-4,log:A lookout tags you on the way through.
option:Skim the gear cages => concourse | risk:medium | time:7 | reward:gear cache | success:item:trackside vest,item:torchlight lantern,log:You nab mid-tier tools before the guards return. | fail:hp-5,morale-2,log:A sentry clips you on the exit.

@mission
id:gangland-supply
label:Shanty supply pull
desc:Run the tunnels for mid-tier clothing and weapons.
risk:medium
time:11
energy:14
loot:3
lootType:mid-tier gear

@mission
id:tunnel-sweep
label:Rail line sweep
desc:Search maintenance shafts for weapons and equipment.
risk:medium
time:10
energy:13
loot:3
lootType:weapons & gear

@mission
id:ganglands-security-cache
label:Security supply room raid
desc:Use the security supply room key to access the guarded arsenal cage.
risk:high
time:14
energy:18
loot:5
lootType:weapons & armored gear
key:1
combatChance:0.5

@quest
id:ganglands-telecom
title:Reconnect the ganglands telecoms
desc:Splice the shattered fiber lines and bring the relay back online.
risk:medium
time:12
energy:16
loot:3
lootType:signal crates
reward:mercenary contract
success:item:signal jammer coil,credits+18,flag:ganglands-telecom,log:The relay hums to life. A mercenary answers the call, opening a second idle dispatch slot.
fail:hp-6,morale-4
flag:ganglands-telecom
once:true`,
      government_facility:`@expansion
id:government_facility
name:Abandoned Government Facility
summary:A sealed agency compound with broken scanners and hardened patrols. Mid-tier risk with hard combatants and better gear.
minLevel:7
shop:false

@door
label:Facility Security Gate
hint:hard combatants, weapons, tools, telecom job
risk:high
note:The security gate grinds open and the halls go quiet.
target:control-hall

@scene control-hall
title:Control Hall
desc:Security consoles flicker, and sealed doors hiss with pressure.
tags:Government / Hazard
option:Run a diagnostic sweep => control-hall | risk:medium | time:7 | reward:systems intel | success:credits+10,log:You recover a diagnostic snapshot. | fail:temp-2,log:The breaker snaps and the room chills.
option:Crack the sealed locker => control-hall | risk:high | time:8 | reward:gear cache | success:item:response harness,item:access scanner,log:You pry loose a cache of uniforms and tools. | fail:hp-6,log:A security latch bites your hand.

@mission
id:facility-sweep
label:Security sweep
desc:Room-to-room sweep for mid-tier weapons and tools.
risk:medium
time:12
energy:16
loot:3
lootType:weapons & tools

@mission
id:facility-deep
label:Hardline extraction
desc:Push through hard combatants for high-tier clothing.
risk:high
time:14
energy:18
loot:4
lootType:reinforced clothing

@mission
id:facility-armory
label:Director armory lock
desc:Use the director armory key to enter the restricted weapons vault.
risk:high
time:15
energy:20
loot:5
lootType:high-tier tactical gear
key:1
combatChance:0.5

@quest
id:facility-telecom
title:Reconnect the facility telecom grid
desc:Bring the facility telecom backbone online to accelerate idle dispatches.
risk:high
time:13
energy:18
loot:3
lootType:signal crates
reward:dispatch acceleration
success:item:secure datapad,credits+20,flag:facility-telecom,log:The telecom grid stabilizes. Idle dispatches now complete faster.
fail:hp-8,morale-5
flag:facility-telecom
once:true`,
      medical_center:`@expansion
id:medical_center
name:Medical Center
summary:A clinic wing stripped of most supplies, but still hiding low-tier medical stock. Mid-risk patrols linger in the halls.
shop:true

@door
label:Clinic Access Bay
hint:medical salvage, mid-risk patrols, telecom job
risk:medium
note:Sterile lights flicker as you enter the medical wing.
target:triage

@scene triage
title:Triage Bay
desc:Empty gurneys line the bay. Cabinets rattle with leftover kits.
tags:Medical / Hazard
option:Check the triage lockers => triage | risk:low | time:6 | reward:basic medical | success:item:antiseptic wipes,item:painkillers,log:You gather intact wraps and meds. | fail:hp-3,log:A drawer slams on your fingers.
option:Search the supply cage => triage | risk:medium | time:7 | reward:medical cache | success:item:electro bandage,item:compact medkit,log:You recover a sealed med case. | fail:hp-5,morale-2,log:A patrol forces a hasty exit.

@mission
id:clinic-supply
label:Supply closet sweep
desc:Low-risk sweep for basic medical items.
risk:low
time:9
energy:10
loot:2
lootType:medical basics

@mission
id:clinic-ward
label:Ward salvage run
desc:Push deeper for mid-tier medical packs.
risk:medium
time:12
energy:14
loot:3
lootType:medical packs

@mission
id:clinic-storage
label:Storage room breach
desc:Use the storage room key to crack the locked supply vault for premium medical stock.
risk:high
time:14
energy:18
loot:5
lootType:advanced medical stock
key:1
combatChance:0.5

@quest
id:medical-telecom
title:Reconnect the clinic telecoms
desc:Restore the clinic relay so vendors can source better medical stock.
risk:medium
time:11
energy:15
loot:2
lootType:signal crates
reward:expanded medical stock
success:item:portable scanner,credits+14,flag:medical-telecom,log:The relay comes online. More medical supplies reach the shop.
fail:hp-6,morale-3
flag:medical-telecom
once:true`,
      abandoned_mall:`@expansion
id:abandoned_mall
name:Abandoned Mall
summary:A hollow mall with shuttered storefronts and a quiet food court. Mid-risk runs for low-tier food and supply crates.
shop:false

@door
label:Mall Service Entrance
hint:food runs, mid-risk corridors, power restart
risk:medium
note:Neon reflections dance on polished tiles as you step inside.
target:food-court

@scene food-court
title:Food Court
desc:Tables are stacked into makeshift barriers. The air smells of cold grease.
tags:Mall / Hazard
option:Check the kiosk storage => food-court | risk:medium | time:7 | reward:food stash | success:item:mall snack pack,item:field rations,log:You pull sealed meals from a storage bin. | fail:hunger+8,log:The stash is picked clean.
option:Search the loading dock => food-court | risk:medium | time:8 | reward:food crates | success:item:water canister,item:citrus soda,log:You drag out a pallet of usable supplies. | fail:hp-5,log:A falling shutter clips your shoulder.

@mission
id:mall-snack
label:Food court sweep
desc:Low-risk sweep for low-tier food items.
risk:medium
time:9
energy:10
loot:2
lootType:low-tier food

@mission
id:mall-stockroom
label:Backroom stock run
desc:Push deeper for better food crates.
risk:medium
time:12
energy:14
loot:3
lootType:food crates

@mission
id:mall-manager-cache
label:Manager suite cache
desc:Use the manager room key to breach the locked office and cold storage stash.
risk:high
time:14
energy:18
loot:5
lootType:premium food & supplies
key:1
combatChance:0.5

@quest
id:mall-power-1
title:Trace the power breakers
desc:Map the breaker panels and identify the dead zones.
risk:medium
time:9
energy:12
loot:1
lootType:power parts
reward:power diagnostics
success:item:power coupler,credits+8,flag:mall-power-1,log:The breaker layout is mapped. You can reach the main switch.
fail:temp-2,morale-3
flag:mall-power-1
once:true

@quest
id:mall-power-2
title:Bring the mall power online
desc:Restart the main power feeds. This will lower the mall's risk and improve food finds.
risk:medium
time:12
energy:16
loot:2
lootType:power salvage
reward:mall power restored
success:item:spark kiosk battery,credits+12,flag:mall-power,log:The lights blaze back on. Mall risk drops and food supplies are easier to locate.
fail:hp-6,morale-4
flag:mall-power
requires:mall-power-1
once:true`
    };
    let expansionsExpected=0;
    let expansionsLoaded=0;
    let expansionsAttempted=0;
    const idleOperations=[
      {id:'bunker-maintenance',label:'Bunker maintenance run',desc:'Maintenance crews stabilize morale and earn a few credits.',duration:3,cost:{credits:6},reward:'credits+5,morale+4,item:old coin',unlockFlag:'safehouse-vents',xp:8},
      {id:'tunnel-relay',label:'Relay salvage sweep',desc:'Bunker scouts recover salvage and food from the old tunnels.',duration:4,cost:{credits:10,scrap:1},reward:'item:ration bar,item:cloth scraps,credits+6',unlockFlag:'bunker-telecom-2',xp:10}
    ];

    const IDLE_DURATION_MULTIPLIER=1;
    const getIdleDurationMultiplier=()=>state.flags.has('facility-telecom') ? IDLE_DURATION_MULTIPLIER*0.85 : IDLE_DURATION_MULTIPLIER;
    const TIME_DISPLAY_MULTIPLIER=4;
    const formatMinutesPrecise=(minutes)=>minutes>=1?`${minutes.toFixed(1)} min`:`${Math.max(5,Math.round(minutes*60))}s`;
    const getIdleDurationMinutes=(op,gearMods=getGearMods())=>{
      const base=op.duration*getIdleDurationMultiplier();
      const adjusted=base*(1-(gearMods.idleSpeed||0));
      return clamp(adjusted,1,5);
    };

    const CRAFTING_PAGE_SIZE=4;
    const MARKET_PAGE_SIZE=6;
    const CRAFTING_RECIPES=[
      {id:'bandage',label:'Bandage',desc:'Quick field wrap to stabilize wounds.',cost:{'cloth scraps':5}},
      {id:'water flask',label:'Water flask',desc:'Patch together a reusable hydration pouch.',cost:{'plastic shards':6,'cloth scraps':3}},
      {id:'ration bar',label:'Ration bar',desc:'Compress salvageable nutrients into a meal.',cost:{'scrap bundle':7,'plastic shards':2}},
      {id:'patch kit',label:'Patch kit',desc:'Bundle wire and electronics into repair gear.',cost:{'wire spool':8,'electronics bits':4}},
      {id:'morale patch',label:'Morale patch',desc:'Stitch a bright patch that steadies nerves.',cost:{'cloth scraps':4,'plastic shards':2}},
      {id:'compact medkit',label:'Compact medkit',desc:'Upgrade basic wraps into a full trauma pack.',cost:{'bandage':2,'cloth scraps':6,'electronics bits':3}},
      {id:'filtered water pack',label:'Filtered water pack',desc:'Pair a flask with a fresh filter for clean water.',cost:{'water flask':1,'spare filter':1,'plastic shards':4}},
      {id:'jury-rigged blade',label:'Jury-rigged blade',desc:'Sharpen scrap into a brutal close-range tool.',cost:{'scrap wiring':4,'wire spool':3}},
      {id:'scrap spear',label:'Scrap spear',desc:'Bind rods and scrap into a reach advantage.',cost:{'copper wire':3,'scrap bundle':6,'cloth scraps':5}},
      {id:'pocket pack',label:'Pocket pack',desc:'Add extra compartments without adding weight.',cost:{'cloth scraps':6,'plastic shards':3}},
      {id:'salvage tote',label:'Salvage tote',desc:'Reinforce a tote for hauling extra salvage.',cost:{'cloth scraps':8,'plastic shards':5,'wire spool':4}},
      {id:'scout daypack',label:'Scout daypack',desc:'Build a balanced daypack for longer routes.',cost:{'salvage tote':1,'wire spool':4,'cloth scraps':6}},
      {id:'bridge-runner pack',label:'Bridge-runner pack',desc:'Tethered pack tuned for wet transit lanes.',cost:{'salvage tote':1,'riot-line tape':4,'wire spool':4}},
      {id:'ledger-etched compass',label:'Ledger-etched compass',desc:'Etch trade routes into a compass that never lies.',cost:{'old coin':2,'electronics bits':4,'wire spool':3}}
    ];

    const MARKET_STOCK_BY_ZONE={
      safehouse:[
        {id:'bandage',cost:10,tag:'Shelter care'},
        {id:'water flask',cost:12,tag:'Hydration'},
        {id:'ration bar',cost:14,tag:'Rations'},
        {id:'homebrew stew',cost:16,tag:'Rations'},
        {id:'clean canteen',cost:14,tag:'Hydration'},
        {id:'morale patch',cost:16,tag:'Morale'},
        {id:'quiet radio',cost:20,tag:'Morale'},
        {id:'spare filter',cost:22,tag:'Air kit'},
        {id:'thermal wrap',cost:20,tag:'Warmth'},
        {id:'comfort liner',cost:26,tag:'Warmth'},
        {id:'tool roll',cost:24,tag:'Gear mod'},
        {id:'recovery tonic',cost:40,tag:'Recovery'},
        {id:'anti-rad serum',cost:46,tag:'Anti-rad'}
      ],
      medical_center:[
        {id:'bandage',cost:10,tag:'Medical'},
        {id:'electro bandage',cost:18,tag:'Medical'},
        {id:'painkillers',cost:18,tag:'Medical'},
        {id:'pain suppressant',cost:22,tag:'Medical'},
        {id:'compact medkit',cost:32,tag:'Medical'},
        {id:'clinic IV pack',cost:42,tag:'Medical'},
        {id:'filtered water pack',cost:26,tag:'Hydration'},
        {id:'hydration drip',cost:20,tag:'Hydration'},
        {id:'spark tonic',cost:22,tag:'Stims'},
        {id:'morale patch',cost:16,tag:'Recovery'},
        {id:'portable scanner',cost:38,tag:'Diagnostics'},
        {id:'biofilter mask',cost:36,tag:'Protection'},
        {id:'anti-rad serum',cost:46,tag:'Anti-rad'}
      ],
      metro_ganglands:[
        {id:'utility coat',cost:34,tag:'Armor'},
        {id:'riot jacket',cost:120,tag:'Armor'},
        {id:'scavenger harness',cost:30,tag:'Clothing'},
        {id:'limited hoodie',cost:44,tag:'Clothing'},
        {id:'graffiti cloak',cost:58,tag:'Clothing'},
        {id:'barter satchel',cost:40,tag:'Pack'},
        {id:'rail spike mace',cost:36,tag:'Weapon'},
        {id:'market shock knife',cost:62,tag:'Weapon'},
        {id:'pipe rifle',cost:72,tag:'Weapon'},
        {id:'shanty revolver',cost:78,tag:'Weapon'}
      ]
    };
    const MEDICAL_CENTER_UPGRADE_STOCK=[
      {id:'compact medkit',cost:30,tag:'Medical'},
      {id:'painkillers',cost:20,tag:'Medical'},
      {id:'anti-rad serum',cost:46,tag:'Anti-rad'},
      {id:'filtered water pack',cost:28,tag:'Hydration'}
    ];
    const MARKET_STOCK_DEFAULT=[
      {id:'pocket pack',cost:26,tag:'Backpack'},
      {id:'scout daypack',cost:38,tag:'Backpack'},
      {id:'expedition frame pack',cost:68,tag:'Backpack'},
      {id:'jury-rigged blade',cost:18,tag:'Weapon'},
      {id:'scrap spear',cost:32,tag:'Weapon'},
      {id:'pipe rifle',cost:70,tag:'Weapon'},
      {id:'arc pistol',cost:82,tag:'Weapon'},
      {id:'compact medkit',cost:30,tag:'Medical'},
      {id:'filtered water pack',cost:28,tag:'Hydration'},
      {id:'morale patch',cost:16,tag:'Morale'},
      {id:'anti-rad serum',cost:46,tag:'Anti-rad'},
      {id:'spare filter',cost:24,tag:'Gear mod'},
      {id:'coil battery',cost:26,tag:'Gear mod'},
      {id:'bunker schematics',cost:44,tag:'Route intel'}
    ];

    const dom={
      introModal:document.getElementById('introModal'),
      introTitle:document.getElementById('introTitle'),
      introMessage:document.getElementById('introMessage'),
      introActions:document.getElementById('introActions'),
      stats:document.getElementById('stats'),
      meta:document.getElementById('meta'),
      pauseToggle:document.getElementById('pauseToggle'),
      doors:document.getElementById('doors'),
      doorsHint:document.getElementById('doorsHint'),
      doorsPanel:document.getElementById('doorsPanel'),
      doorsPagination:document.getElementById('doorsPagination'),
      doorsToggle:document.getElementById('doorsToggle'),
      doorsCurrent:document.getElementById('doorsCurrent'),
      zoneTitle:document.getElementById('zoneTitle'),
      zoneDesc:document.getElementById('zoneDesc'),
      zoneBadge:document.getElementById('zoneBadge'),
      raidActions:document.getElementById('raidActions'),
      inventory:document.getElementById('inventory'),
      equipment:document.getElementById('equipment'),
      crafting:document.getElementById('crafting'),
      backpackCount:document.getElementById('backpackCount'),
      loadoutCount:document.getElementById('loadoutCount'),
      codex:document.getElementById('codex'),
      idleOps:document.getElementById('idleOps'),
      screenNav:document.getElementById('screenNav'),
      screens:{
        main:document.getElementById('screen-main'),
        locations:document.getElementById('screen-locations'),
        mission:document.getElementById('screen-mission')
      },
      screenButtons:Array.from(document.querySelectorAll('#screenNav button')),
      missionTitle:document.getElementById('missionTitle'),
      missionMeta:document.getElementById('missionMeta'),
      missionProgress:document.getElementById('missionProgress'),
      missionLog:document.getElementById('missionLog'),
      missionActions:document.getElementById('missionActions'),
      missionRewardsCard:document.getElementById('missionRewardsCard'),
      missionRewardHint:document.getElementById('missionRewardHint'),
      missionRewardList:document.getElementById('missionRewardList'),
      stash:document.getElementById('stash'),
      stashActions:document.getElementById('stashActions'),
      stashDetail:document.getElementById('stashDetail'),
      stashItemActions:document.getElementById('stashItemActions'),
      stashCount:document.getElementById('stashCount'),
      stashTitle:document.getElementById('stashTitle'),
      stashSubtitle:document.getElementById('stashSubtitle'),
      stashCommandTitle:document.getElementById('stashCommandTitle'),
      marketInventory:document.getElementById('marketInventory'),
      marketHint:document.getElementById('marketHint'),
      marketBackpack:document.getElementById('marketBackpack'),
      marketBackpackCount:document.getElementById('marketBackpackCount'),
      marketSubtitle:document.getElementById('marketSubtitle'),
      itemDetail:document.getElementById('itemDetail'),
      itemActions:document.getElementById('itemActions'),
      inventoryNav:Array.from(document.querySelectorAll('#inventoryNav button')),
      inventoryScreens:{
        backpack:document.getElementById('inventoryBackpack'),
        loadout:document.getElementById('inventoryLoadout'),
        crafting:document.getElementById('inventoryCrafting')
      },
      codexToggle:document.getElementById('codexToggle'),
      stashNav:Array.from(document.querySelectorAll('#stashNav button')),
      stashScreens:{
        vault:document.getElementById('stashVault'),
        market:document.getElementById('stashMarket')
      },
      tabs:document.querySelector('.tabs'),
      tabButtons:Array.from(document.querySelectorAll('.tab-buttons button[data-tab]')),
      tabContents:{
        hub:document.getElementById('tab-hub'),
        inventory:document.getElementById('tab-inventory'),
        field:document.getElementById('tab-field')
      }
    };

    let activeTab='hub';

    /* ================= UTILITIES ================= */
    const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
    const pct=(v,max)=>Math.round((v/max)*100);
    const NORMAL_BODY_TEMP=98;
    const BODY_TEMP_MIN=70;
    const BODY_TEMP_MAX=104;
    const moveToward=(value,target,amount)=>{
      if(value<target) return Math.min(target,value+amount);
      if(value>target) return Math.max(target,value-amount);
      return value;
    };
    const getTotalMinutes=()=>((state.day||0)*24*60)+(state.timeMinutes||0);
    const updateRadShield=()=>{
      if(!state.radShieldUntil || !state.radShield) return state.radShield || 0;
      if(getTotalMinutes()>=state.radShieldUntil){
        state.radShield=0;
        state.radShieldUntil=null;
      }
      return state.radShield || 0;
    };
    const fmtTime=(mins)=>{
      const m=mins%60;const h=Math.floor(mins/60)%24;const suffix=h>=12?"PM":"AM";
      const hour=((h+11)%12+1);return `${hour}:${m.toString().padStart(2,'0')} ${suffix}`;
    }
    const parseCodexEntry=(entry)=>{
      const match=entry.match(/^x(\d+)\s+(.*)$/);
      if(match){
        return {count:Number(match[1]), text:match[2]};
      }
      return {count:1, text:entry};
    };
    const formatCodexEntry=(count,text)=>count>1 ? `x${count} ${text}` : text;
    const getLogTone=(msg)=>{
      const lower=msg.toLowerCase();
      if(/hp-|\-\d+\s*hp|\bdamage\b|\bhit\b|\bwound\b|\binjur|\bharm\b|\bbleed\b/.test(lower)){
        return 'danger';
      }
      if(/\bdanger\b|\bincoming\b|\bimminent\b|\bwarning\b|\bstarvation\b|\bdehydration\b|\bcold\b|\bheat haze\b|\bevacu|\bhostile contact\b/.test(lower)){
        return 'warning';
      }
      if(/\belder\b|\badvisor\b|\bmercenary\b|\bcontact\b|\boperator\b|\bpatrol\b|\bsentry\b/.test(lower)){
        return 'character';
      }
      if(/\bmission\b|\bcontract\b|\braid\b|\bidle\b|\bdispatch\b|\btransit\b|\barrived\b|\blevel up\b|\boperation\b|\bop\b/.test(lower)){
        return 'mission';
      }
      return '';
    };
    const renderCodexEntry=(entry)=>{
      const tone=getLogTone(entry);
      const line=document.createElement('div');
      line.className=tone ? `log-entry log-entry--${tone}` : 'log-entry';
      line.textContent=entry;
      return line;
    };
    function renderCodex(){
      if(!dom.codex) return;
      const entries=state.codex.slice(-CODEX_VISIBLE_LIMIT);
      const latest=entries[entries.length-1] || '';
      dom.codex.textContent='';
      if(state.codexExpanded){
        const fragment=document.createDocumentFragment();
        entries.forEach(entry=>fragment.appendChild(renderCodexEntry(entry)));
        dom.codex.appendChild(fragment);
      }else if(latest){
        dom.codex.appendChild(renderCodexEntry(latest));
      }
      if(dom.codexToggle){
        dom.codexToggle.textContent=state.codexExpanded ? 'Hide log' : 'Show last 20';
      }
    }
    const setCodex=(msg)=>{
      if(!msg) return;
      const lastEntry=state.codex[state.codex.length-1];
      if(lastEntry){
        const parsed=parseCodexEntry(lastEntry);
        if(parsed.text===msg){
          state.codex[state.codex.length-1]=formatCodexEntry(parsed.count+1,msg);
          renderCodex();
          return;
        }
      }
      state.codex.push(msg);
      if(state.codex.length>CODEX_HISTORY_LIMIT){
        state.codex.splice(0,state.codex.length-CODEX_HISTORY_LIMIT);
      }
      renderCodex();
    };
    const getIdleSlotLimit=()=>state.flags.has('ganglands-telecom') ? 2 : 1;
    const syncIdleSlots=()=>{
      if(!Array.isArray(state.idleOps)){
        state.idleOps=[createIdleSlot()];
      }
      const limit=getIdleSlotLimit();
      while(state.idleOps.length<limit){
        state.idleOps.push(createIdleSlot());
      }
      if(state.idleOps.length>limit){
        state.idleOps.length=limit;
      }
    };
    const isHubZone=(zone=state.zone)=>{
      if(!zone) return false;
      const name=(zone.name||'').toLowerCase();
      return zone.id==='safehouse' || zone.id==='drift-yard' || name.includes('safehouse') || name.includes('hub') || name.includes('drift yard');
    };
    const canAccessVault=()=>isHubZone(state.zone) && !state.mission.active && !state.travel.active;
    const canAccessMarket=()=>state.marketAccess.active && state.marketAccess.zoneId===state.zone.id && !state.mission.active && !state.travel.active;
    const isMarketZone=(zone=state.zone)=>{
      if(!zone) return false;
      const exp=expansions[zone.id];
      if(exp?.meta?.shop==='true') return true;
      return (zone.name||'').toLowerCase().includes('market');
    };
    const zoneHasShop=(zone=state.zone)=>isMarketZone(zone) || zone.id==='safehouse';
    const getMarketStockForZone=(zoneId)=>{
      if(!zoneId) return MARKET_STOCK_DEFAULT;
      if(zoneId==='medical_center'){
        const base=MARKET_STOCK_BY_ZONE[zoneId] || MARKET_STOCK_DEFAULT;
        if(state.flags.has('medical-telecom')){
          return [...base,...MEDICAL_CENTER_UPGRADE_STOCK];
        }
        return base;
      }
      return MARKET_STOCK_BY_ZONE[zoneId] || MARKET_STOCK_DEFAULT;
    };
    const ensureZoneScene=(zone=state.zone)=>{
      const exp=expansions[zone.id];
      if(!exp) return null;
      const availableSceneId=zone.sceneId || exp.door?.target || Object.keys(exp.scenes || {})[0];
      if(availableSceneId && zone.sceneId!==availableSceneId){
        zone.sceneId=availableSceneId;
      }
      if(!availableSceneId) return null;
      const scene=exp.scenes?.[availableSceneId];
      return scene ? {id:availableSceneId,...scene} : null;
    };
    const clearMarketAccess=()=>{
      if(state.marketAccess.active){
        state.marketAccess={active:false,zoneId:null};
        if(state.stashScreen==='market'){
          state.stashScreen='vault';
        }
      }
    };
    const vaultBlockedMessage='Return to a hub location to access the vault.';
    const logMsg=(msg)=>{
      const stamp=`[Day ${state.day} // ${fmtTime(state.timeMinutes)}] ${msg}`;
      if(state.mission.active && !state.mission.completed){
        state.mission.statusMessage=stamp;
        state.mission.summary=stamp;
        renderMissionStatus();
        return;
      }
      const activeIdleSlot=state.idleOps.find(slot=>slot.active && !slot.completed);
      if(activeIdleSlot){
        activeIdleSlot.statusMessage=stamp;
        renderIdleOps();
        return;
      }
      setCodex(msg);
    }
    let travelResolveTimer=null;
    const scheduleTravelResolution=()=>{
      if(travelResolveTimer){
        clearTimeout(travelResolveTimer);
        travelResolveTimer=null;
      }
      if(!state.travel.active) return;
      const endsAt=Number(state.travel.endsAt);
      if(!Number.isFinite(endsAt)) return;
      const delay=Math.max(0,endsAt-Date.now())+60;
      travelResolveTimer=setTimeout(()=>{
        if(state.travel.active){
          renderTravelStatus();
        }
      },delay);
    };

    const GRID_PAGE_SIZE=18;
    const STACK_LIMIT=25;
    const STACKABLE_CHUNK_RANGE={min:5,max:20};
    const STACKABLE_ITEMS=new Set(['scrap bundle','wire spool','cloth scraps','plastic shards','electronics bits','scrap wiring','copper wire']);
    const isStackable=(id)=>STACKABLE_ITEMS.has(id);
    const getItemCount=(arr,id)=>arr.reduce((acc,item)=>acc+(item===id?1:0),0);
    const slotUsageFor=(id,count)=>isStackable(id)?Math.ceil(count/STACK_LIMIT):count;
    const getSlotUsage=(arr)=>{
      const tally={};
      arr.forEach(item=>{tally[item]=(tally[item]||0)+1;});
      return Object.entries(tally).reduce((total,[id,count])=>total+slotUsageFor(id,count),0);
    };
    const hasCapacityFor=(arr,limit,id,count=1)=>{
      const currentSlots=getSlotUsage(arr);
      const existingCount=getItemCount(arr,id);
      const currentItemSlots=slotUsageFor(id,existingCount);
      const nextItemSlots=slotUsageFor(id,existingCount+count);
      const projected=currentSlots-currentItemSlots+nextItemSlots;
      return projected<=limit;
    };
    const removeItem=(arr,item)=>{const idx=arr.indexOf(item); if(idx>=0) arr.splice(idx,1);};
    const removeItems=(arr,item,count)=>{
      for(let i=0;i<count;i++){
        const idx=arr.indexOf(item);
        if(idx<0) return i===count;
        arr.splice(idx,1);
      }
      return true;
    };
    const addItemCopies=(arr,item,count=1)=>{for(let i=0;i<count;i++) arr.push(item);};
    const routeItemGain=(item)=>{
      const data=getItem(item);
      if(data.type==='key'){
        state.keys+=1;
        logMsg(`Key recovered: ${item}.`);
        return 'keys';
      }
      if(hasCapacityFor(state.inventory,getBackpackLimit(),item,1)){
        state.inventory.push(item);
        return 'inventory';
      }
      if(canAccessVault() && hasCapacityFor(state.stash.items,state.stashLimit,item,1)){
        state.stash.items.push(item);
        return 'vault';
      }
      return 'lost';
    };
    const getItem=(id)=>ITEM_CATALOG[id] || {type:'junk',rarity:'common',value:1};
    const formatDisplayMinutes=(minutes)=>Math.max(1,Math.round(minutes*TIME_DISPLAY_MULTIPLIER));
    const normalizeBreakdown=(breakdown)=>({
      scrap:Math.max(0,Number(breakdown?.scrap || 0)),
      items:{...(breakdown?.items || {})}
    });
    const BREAKDOWN_DEFAULTS={
      armor:{items:{'cloth scraps':4}},
      tool:{items:{'electronics bits':3,'plastic shards':2}},
      weapon:{items:{'scrap wiring':3,'copper wire':2},scrap:1},
      consumable:{items:{'scrap bundle':2,'plastic shards':1}},
      key:{items:{'electronics bits':2,'scrap wiring':1}}
    };
    const getBreakdownOutputs=(item)=>{
      const data=getItem(item);
      if(data.breakdown){
        return normalizeBreakdown(data.breakdown);
      }
      if(data.type==='junk'){
        return {scrap:data.salvage || Math.max(1,Math.floor((data.value || 1)/2)),items:{}};
      }
      const fallback=BREAKDOWN_DEFAULTS[data.type];
      if(fallback){
        return normalizeBreakdown(fallback);
      }
      return {scrap:Math.max(1,Math.floor((data.value || 1)/2)),items:{'scrap bundle':1}};
    };
    const formatBreakdownOutput=(outputs)=>{
      const parts=[];
      if(outputs.scrap){
        parts.push(`${outputs.scrap} scrap`);
      }
      Object.entries(outputs.items || {}).forEach(([id,count])=>{
        if(count>0) parts.push(`${count} ${id}`);
      });
      return parts.join(' · ');
    };
    const applyBreakdownOutputs=(outputs,{preferred='inventory'}={})=>{
      const losses=[];
      if(outputs.scrap){
        state.scrap+=outputs.scrap;
      }
      Object.entries(outputs.items || {}).forEach(([id,count])=>{
        for(let i=0;i<count;i++){
          const preferStash=preferred==='stash';
          if(preferStash && canAccessVault() && hasCapacityFor(state.stash.items,state.stashLimit,id,1)){
            state.stash.items.push(id);
            continue;
          }
          if(hasCapacityFor(state.inventory,getBackpackLimit(),id,1)){
            state.inventory.push(id);
            continue;
          }
          if(canAccessVault() && hasCapacityFor(state.stash.items,state.stashLimit,id,1)){
            state.stash.items.push(id);
            continue;
          }
          losses.push(id);
        }
      });
      if(losses.length){
        logMsg(`${losses.length}x ${losses[0]} lost: no storage space available.`);
      }
    };
    const formatMods=(mods)=>{
      if(!mods) return [];
      return Object.entries(mods).map(([key,val])=>{
        const label=key.replace(/([A-Z])/g,' $1').toLowerCase();
        const sign=val>0?'+':'';
        return `${label} ${sign}${val}`;
      });
    };
    const rarityLabel=(rarity)=>rarity ? `${rarity[0].toUpperCase()}${rarity.slice(1)}` : '';
    const formatEffects=(effect)=>{
      if(!effect) return [];
      const labels={temp:'body temp',backpack:'backpack slots'};
      return effect.split(',').map(token=>token.trim()).filter(Boolean).map(token=>{
        if(token.startsWith('item:')) return `Adds item: ${token.slice(5).trim()}`;
        if(token.startsWith('note:')) return token.slice(5).trim();
        if(token.startsWith('log:')) return token.slice(4).trim();
        if(token.startsWith('flag:')) return `Flags ${token.slice(5).trim()}`;
        const radPercentMatch=token.match(/^rads([+-]\d+)%$/i);
        if(radPercentMatch){
          return `radiation ${radPercentMatch[1]}%`;
        }
        const radShieldMatch=token.match(/^radshield([+-]\d+)/i);
        if(radShieldMatch){
          const value=Number(radShieldMatch[1]);
          const display=value>0 ? `-${Math.abs(value)}%` : `${value}%`;
          return `radiation accumulation ${display}`;
        }
        const match=token.match(/([a-zA-Z]+)([+-]\d+)/);
        if(match){
          const stat=match[1];
          const delta=match[2];
          const label=labels[stat] || stat;
          return `${label} ${delta}`;
        }
        return token;
      });
    };
    const groupItems=(items)=>{
      const tally=items.reduce((acc,item)=>{
        acc[item]=(acc[item]||0)+1;
        return acc;
      },{});
      return Object.entries(tally).map(([id,count])=>({id,count,data:getItem(id)}));
    };
    const rollLootItem=(risk,bonus=0)=>{
      const roll=Math.random();
      const bias={
        low:{common:0.7,uncommon:0.22,rare:0.07,epic:0.009,legendary:0.001},
        medium:{common:0.55,uncommon:0.28,rare:0.13,epic:0.035,legendary:0.005},
        high:{common:0.4,uncommon:0.3,rare:0.18,epic:0.09,legendary:0.03},
        deadly:{common:0.3,uncommon:0.28,rare:0.2,epic:0.14,legendary:0.08}
      };
      const dist=bias[risk] || bias.low;
      const adjusted={
        common:Math.max(0.05,dist.common-(bonus*0.5)),
        uncommon:dist.uncommon+(bonus*0.2),
        rare:dist.rare+(bonus*0.2),
        epic:dist.epic+(bonus*0.08),
        legendary:dist.legendary+(bonus*0.02)
      };
      const rollTable=[
        ['common',adjusted.common],
        ['uncommon',adjusted.uncommon],
        ['rare',adjusted.rare],
        ['epic',adjusted.epic],
        ['legendary',adjusted.legendary]
      ];
      let cursor=0;
      for(const [rarity,weight] of rollTable){
        cursor+=weight;
        if(roll<=cursor){
          const pool=LOOT_BY_RARITY[rarity];
          return pool[Math.floor(Math.random()*pool.length)];
        }
      }
      return 'scrap wiring';
    };
    const rollStackableChunk=()=>STACKABLE_CHUNK_RANGE.min+Math.floor(Math.random()*(STACKABLE_CHUNK_RANGE.max-STACKABLE_CHUNK_RANGE.min+1));
    const rollLootDrop=(risk,bonus=0)=>{
      const id=rollLootItem(risk,bonus);
      const count=isStackable(id)?rollStackableChunk():1;
      return {id,count};
    };
    const getGearMods=(excludeItem)=>{
      return state.equipped.reduce((acc,item)=>{
        if(excludeItem && item===excludeItem) return acc;
        const mod=getItem(item).mods;
        if(!mod) return acc;
        Object.entries(mod).forEach(([key,val])=>{
          acc[key]=(acc[key]||0)+val;
        });
        return acc;
      },{});
    };
    const getBackpackLimit=(excludeItem)=>state.backpackLimit+(getGearMods(excludeItem).carryBonus||0);
    const getBackpackUsage=()=>getSlotUsage(state.inventory);
    const getStashUsage=()=>getSlotUsage(state.stash.items);
    const canUnequipItem=(item)=>hasCapacityFor(state.inventory,getBackpackLimit(item),item,1);
    const XP_BASE=80;
    const XP_GROWTH=20;
    const xpToNextLevel=(level)=>XP_BASE+(XP_GROWTH*(level-1));
    const EQUIPMENT_SLOTS={
      backpack:1,
      gloves:1,
      helmet:1,
      eyewear:1,
      pants:1,
      shoes:1,
      chest:1,
      weapon:2,
      tool:3
    };
    const EQUIPMENT_SLOT_LABELS={
      backpack:'Backpack',
      gloves:'Gloves',
      helmet:'Helmet',
      eyewear:'Eyewear',
      pants:'Pants',
      shoes:'Shoes',
      chest:'Chest',
      weapon:'Weapon',
      tool:'Tool'
    };
    const getEquipmentSlotUsage=()=>{
      const usage=Object.keys(EQUIPMENT_SLOTS).reduce((acc,key)=>{acc[key]=0;return acc;},{});
      state.equipped.forEach(item=>{
        const slot=getItem(item).slot;
        if(slot && usage.hasOwnProperty(slot)){
          usage[slot]+=1;
        }
      });
      return usage;
    };
    const getEquipmentUsageCount=()=>{
      const usage=getEquipmentSlotUsage();
      return Object.values(usage).reduce((sum,val)=>sum+val,0);
    };
    const getEquipmentSlotTotal=()=>Object.values(EQUIPMENT_SLOTS).reduce((sum,val)=>sum+val,0);
    const slotLabel=(slot)=>EQUIPMENT_SLOT_LABELS[slot] || slot;
    const getEquippedItemBySlot=(slot)=>state.equipped.find(item=>getItem(item).slot===slot);
    const getBackpackLimitAfterSwap=(currentBackpack,newBackpack)=>{
      const currentMods=getGearMods(currentBackpack);
      const newMods=getItem(newBackpack).mods || {};
      const carryBonus=(currentMods.carryBonus||0)+(newMods.carryBonus||0);
      return state.backpackLimit+carryBonus;
    };
    const canSwapBackpack=(currentBackpack,newBackpack,removeFromInventory)=>{
      const tempInventory=[...state.inventory];
      if(removeFromInventory){
        removeItem(tempInventory,newBackpack);
      }
      const limit=getBackpackLimitAfterSwap(currentBackpack,newBackpack);
      return hasCapacityFor(tempInventory,limit,currentBackpack,1);
    };
    const canEquipItem=(item,source='inventory')=>{
      const data=getItem(item);
      if(!data.slot) return {ok:false,reason:'This item cannot be equipped.'};
      const usage=getEquipmentSlotUsage();
      const limit=EQUIPMENT_SLOTS[data.slot] || 0;
      if((usage[data.slot]||0) >= limit){
        if(data.slot==='backpack'){
          const equippedBackpack=getEquippedItemBySlot('backpack');
          if(equippedBackpack){
            const removeFromInventory=source==='inventory';
            if(canSwapBackpack(equippedBackpack,item,removeFromInventory)){
              return {ok:true,reason:'',requiresSwap:true,swapItem:equippedBackpack};
            }
            return {ok:false,reason:'Backpack too full to swap.'};
          }
        }
        return {ok:false,reason:`${slotLabel(data.slot)} slot full.`};
      }
      return {ok:true,reason:'',requiresSwap:false};
    };
    function awardXp(amount,sourceLabel){
      if(amount<=0) return;
      state.xp+=amount;
      let leveled=false;
      while(state.xp>=state.nextLevelXp){
        state.xp-=state.nextLevelXp;
        state.level+=1;
        state.maxHp+=6;
        state.maxStamina+=4;
        state.maxMorale+=3;
        state.nextLevelXp=xpToNextLevel(state.level);
        state.hp=clamp(state.hp+10,0,state.maxHp);
        state.stamina=clamp(state.stamina+8,0,state.maxStamina);
        state.morale=clamp(state.morale+6,0,state.maxMorale);
        leveled=true;
      }
      if(leveled){
        logMsg(`Level up! You are now level ${state.level}.`);
      }else if(sourceLabel){
        logMsg(`+${amount} XP from ${sourceLabel}.`);
      }
    }
    const STASH_UPGRADE_STEP=6;
    const STASH_UPGRADE_BASE_COST={credits:32,scrap:4};
    const STASH_UPGRADE_GROWTH={credits:24,scrap:3};
    const getStashUpgradeCost=()=>{
      const level=state.stashUpgradeLevel;
      return {
        credits:STASH_UPGRADE_BASE_COST.credits+(STASH_UPGRADE_GROWTH.credits*level),
        scrap:STASH_UPGRADE_BASE_COST.scrap+(STASH_UPGRADE_GROWTH.scrap*level)
      };
    };
    const upgradeStash=()=>{
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      const cost=getStashUpgradeCost();
      if(!canAfford(cost)){
        setCodex('Not enough resources to expand the stash.');
        return;
      }
      applyCost(cost);
      state.stashLimit+=STASH_UPGRADE_STEP;
      state.stashUpgradeLevel+=1;
      setCodex(`Vault expanded by ${STASH_UPGRADE_STEP} slots.`);
      logMsg(`Vault expansion complete. Capacity now ${state.stashLimit}.`);
      renderAll();
    };
    const formatCost=(cost)=>Object.entries(cost).map(([k,v])=>`${v} ${k}`).join(' · ');
    const canAfford=(cost)=>Object.entries(cost).every(([k,v])=>state[k]>=v);
    const applyCost=(cost)=>{
      Object.entries(cost).forEach(([k,v])=>{
        state[k]=Math.max(0,state[k]-v);
      });
    };
    const addToArray=(arr,item)=>{arr.push(item);};
    function equipItem(item){
      if(state.equipped.includes(item)) return;
      const data=getItem(item);
      const check=canEquipItem(item,'inventory');
      if(!check.ok){
        setCodex(check.reason || 'No open slots for that item.');
        return;
      }
      if(check.requiresSwap){
        const equippedBackpack=check.swapItem || getEquippedItemBySlot('backpack');
        if(!equippedBackpack){
          setCodex('No open slots for that item.');
          return;
        }
        removeItem(state.inventory,item);
        removeItem(state.equipped,equippedBackpack);
        state.inventory.push(equippedBackpack);
        state.equipped.push(item);
        state.selected={source:'equipped',item};
        setCodex(`${item} equipped.`);
        logMsg(`Swapped to ${item}.`);
        renderAll();
        return;
      }
      removeItem(state.inventory,item);
      state.equipped.push(item);
      state.selected={source:'equipped',item};
      setCodex(`${item} equipped.`);
      logMsg(`Equipped ${item}.`);
      renderAll();
    }
    function unequipItem(item){
      if(!canUnequipItem(item)){
        setCodex('Backpack full. Make space before unequipping.');
        return;
      }
      removeItem(state.equipped,item);
      state.inventory.push(item);
      state.selected={source:'inventory',item};
      setCodex(`${item} stowed.`);
      logMsg(`Unequipped ${item}.`);
      renderAll();
    }
    function consumeItem(item){
      const data=getItem(item);
      if(data.type!=='consumable'){
        setCodex('That item cannot be used like a consumable.');
        return;
      }
      if(data.effect){
        applyEffects(data.effect,'success');
      }
      removeItem(state.inventory,item);
      state.selected={source:null,item:null};
      logMsg(`Consumed ${item}.`);
      setCodex(`${item} used.`);
      renderAll();
    }
    function stashItem(item){
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      if(!hasCapacityFor(state.stash.items,state.stashLimit,item,1)){
        setCodex('Stash is full.');
        return;
      }
      removeItem(state.inventory,item);
      state.stash.items.push(item);
      state.selected={source:'stash',item};
      setCodex(`${item} stored in ${state.stash.name}.`);
      logMsg(`Stored ${item} in ${state.stash.name}.`);
      renderAll();
    }
    function stashItemStack(item,count){
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      const available=getItemCount(state.inventory,item);
      const transferCount=Math.min(count,available);
      if(transferCount<=0){
        setCodex('No stack available to route.');
        return;
      }
      if(!hasCapacityFor(state.stash.items,state.stashLimit,item,transferCount)){
        setCodex('Stash is full.');
        return;
      }
      removeItems(state.inventory,item,transferCount);
      addItemCopies(state.stash.items,item,transferCount);
      state.selected={source:'stash',item};
      setCodex(`${item} stack routed into ${state.stash.name}.`);
      logMsg(`Routed ${transferCount}x ${item} into ${state.stash.name}.`);
      renderAll();
    }
    function stashItemHalf(item){
      const available=getItemCount(state.inventory,item);
      const half=Math.floor(available/2);
      if(half<=0){
        setCodex('Not enough of that item to split.');
        return;
      }
      stashItemStack(item,half);
    }
    function unstashItem(item){
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      if(!hasCapacityFor(state.inventory,getBackpackLimit(),item,1)){
        setCodex('Backpack full.');
        return;
      }
      removeItem(state.stash.items,item);
      state.inventory.push(item);
      state.selected={source:'inventory',item};
      setCodex(`${item} withdrawn from ${state.stash.name}.`);
      logMsg(`Retrieved ${item} from ${state.stash.name}.`);
      renderAll();
    }
    function sellItem(item){
      if(!canAccessMarket()){
        setCodex('Visit a shop to sell items.');
        return;
      }
      const data=getItem(item);
      removeItem(state.inventory,item);
      state.credits+=data.value || 1;
      state.selected={source:null,item:null};
      logMsg(`Sold ${item} for ${data.value || 1} credits.`);
      renderAll();
    }
    function sellItemStack(item,count){
      if(!canAccessMarket()){
        setCodex('Visit a shop to sell items.');
        return;
      }
      const available=getItemCount(state.inventory,item);
      const sellCount=Math.min(count,available);
      if(sellCount<=0) return;
      const data=getItem(item);
      removeItems(state.inventory,item,sellCount);
      state.credits+=(data.value || 1) * sellCount;
      state.selected={source:null,item:null};
      logMsg(`Sold ${sellCount}x ${item} for ${(data.value || 1) * sellCount} credits.`);
      renderAll();
    }
    function dismantleItem(item){
      removeItem(state.inventory,item);
      const breakdown=getBreakdownOutputs(item);
      applyBreakdownOutputs(breakdown,{preferred:'inventory'});
      state.selected={source:null,item:null};
      logMsg(`Dismantled ${item} for ${formatBreakdownOutput(breakdown) || 'junk'}.`);
      renderAll();
    }

    function resetIdleSlot(slot){
      Object.assign(slot,createIdleSlot());
    }
    function closeIdleOp(slotIndex){
      const slot=state.idleOps[slotIndex];
      if(!slot) return;
      resetIdleSlot(slot);
      state.selected={source:null,item:null};
      setCodex('Idle operation slot cleared. Ready for another dispatch.');
      renderAll();
    }

    function startIdleOp(opId){
      syncIdleSlots();
      if((state.idleRewards?.length||0)>0){
        setCodex('Resolve idle rewards before dispatching a new operation.');
        return;
      }
      const op=idleOperations.find(entry=>entry.id===opId);
      if(!op) return;
      if(op.unlockFlag && !state.flags.has(op.unlockFlag)){
        setCodex('Idle dispatch locked. Complete the required contract to unlock it.');
        return;
      }
      const slot=state.idleOps.find(entry=>!entry.active && !entry.completed);
      if(!slot){
        setCodex('All idle dispatch slots are occupied.');
        return;
      }
      if(!canAfford(op.cost)){
        setCodex('Insufficient resources for this operation.');
        return;
      }
      startLoops();
      applyCost(op.cost);
      const gearMods=getGearMods();
      const duration=getIdleDurationMinutes(op,gearMods);
      Object.assign(slot,{
        active:true,
        id:opId,
        startedAt:Date.now(),
        durationMs:duration*60000,
        etaMinutes:duration,
        completed:false,
        statusMessage:`Idle op launched: ${op.label}.`
      });
      logMsg(`Idle op launched: ${op.label}. ETA ${formatMinutesPrecise(duration)}.`);
      renderAll();
    }

    function completeIdleOp(slot){
      const op=idleOperations.find(entry=>entry.id===slot.id);
      if(!op) return;
      const rewards=[];
      applyEffects(op.reward,'success',{deferItemsTo:rewards});
      if(op.xp){
        awardXp(op.xp,op.label);
      }
      state.idleRewards.push(...rewards);
      Object.assign(slot,{
        active:false,
        id:op.id,
        startedAt:null,
        durationMs:0,
        etaMinutes:0,
        completed:true,
        statusMessage:`Idle op complete: ${op.label}. Rewards routed to idle cache.`
      });
      state.selected={source:null,item:null};
      setCodex('Idle operation complete. Review rewards.');
      renderAll();
    }

    /* ================= RENDERING ================= */
    function renderBars(){
      const rows=[
        ['HP','hp','maxHp','hp'],
        ['Stamina','stamina','maxStamina','stamina'],
        ['Morale','morale','maxMorale','morale'],
        ['Energy','energy','maxEnergy','stamina'],
        ['Hunger','hunger','maxHunger','hunger'],
        ['Hydration','thirst','maxThirst','thirst'],
        ['Radiation','rads',100,'rads'],
        ['Body Temp','bodyTemp','maxBodyTemp','temp']
      ];
      dom.stats.innerHTML=rows.map(([label,key,maxKey,cls])=>{
        const val=state[key];const max=(typeof maxKey==='string')?state[maxKey]:maxKey;
        const percent=clamp(pct(val,max),0,200);
        return `<div class="statline"><div>${label}</div><div class="bar ${cls}"><span style="width:${percent}%;"></span></div><div>${Math.round(val)}/${max}</div></div>`;
      }).join('');
    dom.meta.innerHTML=`<span class="pill-inline"><b>Credits</b>${state.credits}</span>`+
        `<span class="pill-inline"><b>Scrap</b>${state.scrap}</span>`+
        `<span class="pill-inline"><b>Keys</b>${state.keys}</span>`+
        `<span class="pill-inline"><b>Level</b>${state.level}</span>`+
        `<span class="pill-inline"><b>XP</b>${state.xp}/${state.nextLevelXp}</span>`+
        `<span class="pill-inline"><b>Time</b>${fmtTime(state.timeMinutes)}</span>`+
        `<span class="pill-inline"><b>Day</b>${state.day}</span>`+
        `<span class="pill-inline"><b>Backpack</b>${getBackpackUsage()}/${getBackpackLimit()}</span>`;
    }

    const rewardSources={
      mission:{
        key:'missionReward',
        getItems:()=>state.mission.rewards || [],
        clear:()=>{ state.mission.rewards=[]; }
      },
      idle:{
        key:'idleReward',
        getItems:()=>state.idleRewards || [],
        clear:()=>{ state.idleRewards=[]; }
      }
    };
    const getRewardConfig=(source)=>Object.values(rewardSources).find(cfg=>cfg.key===source) || null;
    const rewardHasItem=(source,item)=>{
      const cfg=getRewardConfig(source);
      if(!cfg) return false;
      return cfg.getItems().includes(item);
    };
    const getRewardItemCount=(source,item)=>{
      const cfg=getRewardConfig(source);
      if(!cfg) return 0;
      return cfg.getItems().filter(entry=>entry===item).length;
    };
    const removeRewardItem=(source,item)=>{
      const cfg=getRewardConfig(source);
      if(!cfg) return false;
      const bucket=cfg.getItems();
      const idx=bucket.indexOf(item);
      if(idx<0) return false;
      bucket.splice(idx,1);
      return true;
    };
    const removeRewardItems=(source,item,count)=>{
      const cfg=getRewardConfig(source);
      if(!cfg) return false;
      return removeItems(cfg.getItems(),item,count);
    };
    const isMissionResolved=()=>state.mission.active && state.mission.completed && (state.mission.rewards?.length||0)===0;
    function autoCloseMissionIfResolved(){
      if(isMissionResolved()){
        closeMission({auto:true});
      }
    }
    function claimRewardToInventory(source,item){
      const data=getItem(item);
      if(data.type!=='key' && !hasCapacityFor(state.inventory,getBackpackLimit(),item,1)){
        setCodex('Backpack full. Make room first.');
        return;
      }
      if(!removeRewardItem(source,item)) return;
      if(data.type==='key'){
        state.keys+=1;
        state.selected={source:null,item:null};
        setCodex(`${item} secured. Key count updated.`);
      }else{
        state.inventory.push(item);
        state.selected={source:'inventory',item};
        setCodex(`${item} packed into your backpack.`);
      }
      autoCloseMissionIfResolved();
      renderAll();
    }
    function claimRewardStackToInventory(source,item){
      const count=getRewardItemCount(source,item);
      if(!count) return;
      const data=getItem(item);
      if(data.type!=='key' && !hasCapacityFor(state.inventory,getBackpackLimit(),item,count)){
        setCodex('Backpack full. Make room first.');
        return;
      }
      if(!removeRewardItems(source,item,count)) return;
      if(data.type==='key'){
        state.keys+=count;
        state.selected={source:null,item:null};
        setCodex(`${item} secured. ${count} key${count===1?'':'s'} added.`);
      }else{
        addItemCopies(state.inventory,item,count);
        state.selected={source:'inventory',item};
        setCodex(`${item} stack packed into your backpack.`);
      }
      autoCloseMissionIfResolved();
      renderAll();
    }
    function claimRewardToVault(source,item){
      if(source==='missionReward'){
        setCodex('Mission rewards can only be packed, equipped, broken down, or left behind.');
        return;
      }
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      const data=getItem(item);
      if(data.type!=='key' && !hasCapacityFor(state.stash.items,state.stashLimit,item,1)){
        setCodex('Stash full. Sell or break down to clear space.');
        return;
      }
      if(!removeRewardItem(source,item)) return;
      if(data.type==='key'){
        state.keys+=1;
        state.selected={source:null,item:null};
        setCodex(`${item} secured. Key count updated.`);
      }else{
        state.stash.items.push(item);
        state.selected={source:'stash',item};
        setCodex(`${item} routed into the vault.`);
      }
      renderAll();
    }
    function equipRewardItem(source,item){
      const data=getItem(item);
      const check=canEquipItem(item,source);
      if(!check.ok){
        setCodex(check.reason || 'No open slots for that item.');
        return;
      }
      if(check.requiresSwap){
        const equippedBackpack=check.swapItem || getEquippedItemBySlot('backpack');
        if(!equippedBackpack){
          setCodex('No open slots for that item.');
          return;
        }
        if(!removeRewardItem(source,item)) return;
        removeItem(state.equipped,equippedBackpack);
        state.inventory.push(equippedBackpack);
        state.equipped.push(item);
        state.selected={source:'equipped',item};
        setCodex(`${item} equipped from rewards.`);
        autoCloseMissionIfResolved();
        renderAll();
        return;
      }
      if(!removeRewardItem(source,item)) return;
      state.equipped.push(item);
      state.selected={source:'equipped',item};
      setCodex(`${item} equipped from rewards.`);
      autoCloseMissionIfResolved();
      renderAll();
    }
    function scrapRewardItem(source,item){
      if(!removeRewardItem(source,item)) return;
      const breakdown=getBreakdownOutputs(item);
      applyBreakdownOutputs(breakdown);
      state.selected={source:null,item:null};
      setCodex(`${item} broken down into ${formatBreakdownOutput(breakdown) || 'junk'}.`);
      autoCloseMissionIfResolved();
      renderAll();
    }
    function leaveRewardItem(source,item){
      if(!removeRewardItem(source,item)) return;
      state.selected={source:null,item:null};
      setCodex(`${item} left behind.`);
      autoCloseMissionIfResolved();
      renderAll();
    }
    function clearRewardSource(source){
      const cfg=getRewardConfig(source);
      if(!cfg) return;
      cfg.clear();
      state.selected={source:null,item:null};
      setCodex(source==='missionReward' ? 'Mission rewards left behind.' : 'Idle rewards dismissed.');
      autoCloseMissionIfResolved();
      renderAll();
    }

    const hasCraftingMaterials=(recipe)=>Object.entries(recipe.cost).every(([id,count])=>getItemCount(state.inventory,id)>=count);
    const craftingCostLabel=(recipe)=>Object.entries(recipe.cost).map(([id,count])=>`${count} ${id}`).join(' · ');
    function craftRecipe(recipeId){
      const recipe=CRAFTING_RECIPES.find(entry=>entry.id===recipeId);
      if(!recipe) return;
      if(!hasCraftingMaterials(recipe)) {
        setCodex('Missing crafting materials.');
        return;
      }
      if(!hasCapacityFor(state.inventory,getBackpackLimit(),recipe.id,1)){
        setCodex('Backpack capacity reached. Crafting would overflow.');
        return;
      }
      Object.entries(recipe.cost).forEach(([id,count])=>removeItems(state.inventory,id,count));
      state.inventory.push(recipe.id);
      state.selected={source:'inventory',item:recipe.id};
      logMsg(`Crafted ${recipe.label} from salvage.`);
      renderAll();
    }

    function buyMarketItem(itemId){
      const zoneId=state.marketAccess.zoneId || state.zone.id;
      const stock=getMarketStockForZone(zoneId).find(entry=>entry.id===itemId);
      if(!stock) return;
      if(!canAccessMarket()){
        setCodex('Visit a shop to buy items.');
        return;
      }
      if(state.credits<stock.cost){
        setCodex('Not enough credits for this purchase.');
        return;
      }
      if(!hasCapacityFor(state.inventory,getBackpackLimit(),itemId,1)){
        setCodex('Backpack full. Make room before purchasing.');
        return;
      }
      state.credits-=stock.cost;
      state.inventory.push(itemId);
      state.selected={source:'inventory',item:itemId};
      logMsg(`Purchased ${itemId} for ${stock.cost} credits.`);
      renderAll();
    }

    function buildItemRow({id,count,data,source}){
      const row=document.createElement('div');
      row.className='item-row selectable';
      if(state.selected.source===source && state.selected.item===id){
        row.classList.add('selected');
      }
      row.onclick=()=>selectItem(source,id);
      const name=document.createElement('div');
      name.className='item-name';
      name.textContent=`${id} ×${count}`;
      const meta=document.createElement('div');
      meta.className='item-meta';
      const slotTag=data.slot ? `${slotLabel(data.slot)} · ` : '';
      meta.textContent=`${data.type} · ${slotTag}${data.value || 1} cr`;
      const chip=document.createElement('span');
      chip.className=`chip ${data.rarity}`;
      chip.textContent=data.rarity;
      row.appendChild(name);
      row.appendChild(chip);
      row.appendChild(meta);
      return row;
    }

    function buildItemTile({id,count,data,source}){
      const tile=document.createElement('button');
      tile.type='button';
      tile.className='icon-tile';
      if(state.selected.source===source && state.selected.item===id){
        tile.classList.add('selected');
      }
      tile.onclick=()=>selectItem(source,id);
      tile.title=`${id} ×${count}`;
      const name=document.createElement('div');
      name.className='icon-name';
      name.textContent=id;
      const meta=document.createElement('div');
      meta.className='icon-meta';
      const metaParts=[];
      if(data.slot) metaParts.push(slotLabel(data.slot));
      metaParts.push(rarityLabel(data.rarity) || data.type);
      meta.textContent=metaParts.filter(Boolean).join(' · ');
      const countEl=document.createElement('div');
      countEl.className='icon-count';
      countEl.textContent=`×${count}`;
      tile.appendChild(name);
      tile.appendChild(meta);
      tile.appendChild(countEl);
      return tile;
    }

    function buildRewardTile({id,count,data,source}){
      const wrap=document.createElement('div');
      wrap.className='reward-tile';
      const tile=buildItemTile({id,count,data,source});
      wrap.appendChild(tile);
      if(state.selected.source===source && state.selected.item===id){
        const actions=document.createElement('div');
        actions.className='reward-actions';
        const takeOneBtn=document.createElement('button');
        takeOneBtn.textContent='Take one';
        takeOneBtn.disabled=!hasCapacityFor(state.inventory,getBackpackLimit(),id,1);
        takeOneBtn.onclick=()=>claimRewardToInventory(source,id);
        actions.appendChild(takeOneBtn);
        if(count>1){
          const stackBtn=document.createElement('button');
          stackBtn.textContent='Take stack';
          stackBtn.disabled=!hasCapacityFor(state.inventory,getBackpackLimit(),id,count);
          stackBtn.onclick=()=>claimRewardStackToInventory(source,id);
          actions.appendChild(stackBtn);
        }
        if(data.slot){
          const equipBtn=document.createElement('button');
          equipBtn.textContent='Equip';
          equipBtn.disabled=!canEquipItem(id,source).ok;
          equipBtn.onclick=()=>equipRewardItem(source,id);
          actions.appendChild(equipBtn);
        }
        const scrapBtn=document.createElement('button');
        scrapBtn.textContent='Break down';
        scrapBtn.onclick=()=>scrapRewardItem(source,id);
        actions.appendChild(scrapBtn);
        wrap.appendChild(actions);
      }
      return wrap;
    }

    function buildEmptySlotTile(label){
      const tile=document.createElement('button');
      tile.type='button';
      tile.disabled=true;
      tile.className='icon-tile empty';
      const name=document.createElement('div');
      name.className='icon-name';
      name.textContent=label;
      const meta=document.createElement('div');
      meta.className='icon-meta';
      meta.textContent='Empty slot';
      tile.appendChild(name);
      tile.appendChild(meta);
      return tile;
    }

    function paginateEntries(entries,pageKey,pageSize){
      const totalPages=Math.max(1,Math.ceil(entries.length/pageSize));
      const safePage=clamp(state[pageKey] || 0,0,totalPages-1);
      state[pageKey]=safePage;
      const start=safePage*pageSize;
      return {entries:entries.slice(start,start+pageSize),page:safePage,totalPages};
    }

    function renderPager({page,totalPages,onPrev,onNext,label}){
      if(totalPages<=1) return null;
      const pager=document.createElement('div');
      pager.className='icon-pager';
      const prev=document.createElement('button');
      prev.textContent=label ? `Prev ${label}` : 'Prev';
      prev.disabled=page<=0;
      prev.onclick=onPrev;
      const info=document.createElement('div');
      info.className='page-info';
      info.textContent=`Page ${page+1} of ${totalPages}`;
      const next=document.createElement('button');
      next.textContent=label ? `Next ${label}` : 'Next';
      next.disabled=page>=totalPages-1;
      next.onclick=onNext;
      pager.appendChild(prev);
      pager.appendChild(info);
      pager.appendChild(next);
      return pager;
    }

    function renderItemDetails(){
      let {source,item}=state.selected;
      const sourceHasItem=()=>{
        if(!source || !item) return false;
        if(source==='inventory') return state.inventory.includes(item);
        if(source==='equipped') return state.equipped.includes(item);
        if(source==='stash') return state.stash.items.includes(item);
        if(source==='missionReward' || source==='idleReward') return rewardHasItem(source,item);
        return false;
      };
      if(source && item && !sourceHasItem()){
        state.selected={source:null,item:null};
        source=null;
        item=null;
      }
      const data=item?getItem(item):null;
      const vaultAccess=canAccessVault();
      const marketActive=canAccessMarket();
      const stashDefault=state.stashScreen==='market'
        ? 'Select backpack items to sell or break down in the trade bay.'
        : 'Select stash items to transfer, break down, or sell.';
      const targets=[
        {detail:dom.itemDetail,actions:dom.itemActions,default:'Select gear to view stats, uses, and actions.'},
        {detail:dom.stashDetail,actions:dom.stashItemActions,default:stashDefault}
      ];
      targets.forEach(target=>{
        if(!target.detail || !target.actions) return;
        if(!item || !data){
          target.detail.innerHTML=`<div class="command-hint">${target.default}</div>`;
        }else{
          const mods=formatMods(data.mods);
          const effects=formatEffects(data.effect);
          const uses=[];
          const breakdown=getBreakdownOutputs(item);
          const breakdownLabel=formatBreakdownOutput(breakdown);
          if(data.type==='consumable') uses.push('Consume for field boost.');
          if(data.slot) uses.push('Equip to gain passive bonuses.');
          uses.push('Break down into salvage.');
          if(data.type==='key') uses.push('Unlocks lockbox raids.');
          target.detail.innerHTML=`
            <div class="command-title">${item}</div>
            <div class="stat-list">
              <div>Type</div><span>${data.type}</span>
              <div>Rarity</div><span>${data.rarity}</span>
              <div>Value</div><span>${data.value || 1} credits</span>
              ${data.slot ? `<div>Slot</div><span>${slotLabel(data.slot)}</span>` : ''}
              ${breakdownLabel ? `<div>Breakdown</div><span>${breakdownLabel}</span>` : ''}
            </div>
            ${uses.length ? `<div class="small">${uses.join(' ')}</div>` : ''}
            ${effects.length ? `<div class="small"><b>Effects:</b> ${effects.join(' · ')}</div>` : ''}
            ${mods.length ? `<div class="small"><b>Mods:</b> ${mods.join(' · ')}</div>` : ''}
          `;
        }
        target.actions.innerHTML='';
      });
      if(!item || !data) return;

      const actionConfigs=[];
      if(source==='inventory'){
        const stackCount=getItemCount(state.inventory,item);
        const stackable=isStackable(item) || data.stackable;
        if(data.slot){
          const check=canEquipItem(item,'inventory');
          actionConfigs.push({
            label:'Deploy to loadout',
            action:()=>equipItem(item),
            disabled:!check.ok,
            blockedHint:check.ok ? '' : check.reason
          });
        }
        if(data.type==='consumable'){
          actionConfigs.push({label:'Use item',action:()=>consumeItem(item)});
        }
        if(vaultAccess){
          actionConfigs.push({
            label:'Route to vault',
            action:()=>stashItem(item),
            disabled:!hasCapacityFor(state.stash.items,state.stashLimit,item,1),
            blockedHint:''
          });
          if(stackable && stackCount>1){
            const halfCount=Math.floor(stackCount/2);
            actionConfigs.push({
              label:'Route stack to vault',
              action:()=>stashItemStack(item,stackCount),
              disabled:!hasCapacityFor(state.stash.items,state.stashLimit,item,stackCount),
              blockedHint:''
            });
            actionConfigs.push({
              label:'Route half stack',
              action:()=>stashItemStack(item,halfCount),
              disabled:halfCount<=0 || !hasCapacityFor(state.stash.items,state.stashLimit,item,halfCount),
              blockedHint:''
            });
          }
        }
        actionConfigs.push({label:'Break down into junk',action:()=>dismantleItem(item)});
        if(marketActive){
          actionConfigs.push({label:'Sell to market',action:()=>sellItem(item)});
          if(stackable && stackCount>1){
            const halfCount=Math.floor(stackCount/2);
            actionConfigs.push({label:'Sell stack',action:()=>sellItemStack(item,stackCount)});
            actionConfigs.push({label:'Sell half stack',action:()=>sellItemStack(item,halfCount),disabled:halfCount<=0});
          }
        }
      }else if(source==='equipped'){
        actionConfigs.push({label:'Return to backpack',action:()=>unequipItem(item),disabled:!canUnequipItem(item)});
      }else if(source==='stash'){
        actionConfigs.push({
          label:'Withdraw to backpack',
          action:()=>unstashItem(item),
          disabled:!vaultAccess || !hasCapacityFor(state.inventory,getBackpackLimit(),item,1),
          blockedHint:!vaultAccess ? vaultBlockedMessage : ''
        });
        actionConfigs.push({
          label:'Break down into junk',
          action:()=>scrapStashItem(item),
          disabled:!vaultAccess,
          blockedHint:!vaultAccess ? vaultBlockedMessage : ''
        });
        if(marketActive && vaultAccess){
          actionConfigs.push({
            label:'Sell to market',
            action:()=>sellStashItem(item)
          });
          const stackCount=getItemCount(state.stash.items,item);
          const stackable=isStackable(item) || data.stackable;
          if(stackable && stackCount>1){
            const halfCount=Math.floor(stackCount/2);
            actionConfigs.push({label:'Sell stack',action:()=>sellStashItemStack(item,stackCount)});
            actionConfigs.push({label:'Sell half stack',action:()=>sellStashItemStack(item,halfCount),disabled:halfCount<=0});
          }
        }
      }
      targets.forEach(target=>{
        if(!target.actions) return;
        actionConfigs.forEach(cfg=>{
          const btn=document.createElement('button');
          btn.textContent=cfg.label;
          if(cfg.disabled){
            btn.disabled=true;
            if(cfg.blockedHint){
              btn.title=cfg.blockedHint;
            }
          }
          btn.onclick=cfg.action;
          target.actions.appendChild(btn);
        });
        if(!actionConfigs.length){
          const msg=document.createElement('div');
          msg.className='command-hint';
          msg.textContent='No actions available.';
          target.actions.appendChild(msg);
        }
      });
    }

    function renderInventory(){
      dom.inventory.innerHTML='';
      dom.equipment.innerHTML='';
      if(!state.inventory.length){
        const empty=document.createElement('div');
        empty.className='muted-box';
        empty.textContent='Backpack empty. Run raids to pull more loot.';
        empty.classList.add('grid-span');
        dom.inventory.appendChild(empty);
      }else{
        const grouped=groupItems(state.inventory);
        const {entries,page,totalPages}=paginateEntries(grouped,'inventoryPage',GRID_PAGE_SIZE);
        entries.forEach(({id,count,data})=>{
          dom.inventory.appendChild(buildItemTile({id,count,data,source:'inventory'}));
        });
        const pager=renderPager({
          page,
          totalPages,
          label:'items',
          onPrev:()=>{state.inventoryPage=Math.max(0,page-1); renderInventory();},
          onNext:()=>{state.inventoryPage=Math.min(totalPages-1,page+1); renderInventory();}
        });
        if(pager){
          pager.classList.add('grid-span');
          dom.inventory.appendChild(pager);
        }
      }
      const equippedBySlot=Object.keys(EQUIPMENT_SLOTS).reduce((acc,key)=>{acc[key]=[];return acc;},{});
      state.equipped.forEach(item=>{
        const slot=getItem(item).slot;
        if(slot && equippedBySlot[slot]){
          equippedBySlot[slot].push(item);
        }
      });
      Object.entries(EQUIPMENT_SLOTS).forEach(([slot,count])=>{
        for(let i=0;i<count;i++){
          const item=equippedBySlot[slot].shift();
          if(item){
            dom.equipment.appendChild(buildItemTile({id:item,count:1,data:getItem(item),source:'equipped'}));
          }else{
            dom.equipment.appendChild(buildEmptySlotTile(slotLabel(slot)));
          }
        }
      });
      if(dom.backpackCount){
        dom.backpackCount.textContent=`(${getBackpackUsage()}/${getBackpackLimit()})`;
      }
      if(dom.loadoutCount){
        dom.loadoutCount.textContent=`(${getEquipmentUsageCount()}/${getEquipmentSlotTotal()})`;
      }
      renderCodex();
    }

    function changeCraftingPage(delta){
      const totalPages=Math.max(1,Math.ceil(CRAFTING_RECIPES.length/CRAFTING_PAGE_SIZE));
      state.craftingPage=clamp(state.craftingPage+delta,0,totalPages-1);
      renderCrafting();
    }

    function changeMarketPage(delta){
      const zoneId=state.marketAccess.zoneId || state.zone.id;
      const totalPages=Math.max(1,Math.ceil(getMarketStockForZone(zoneId).length/MARKET_PAGE_SIZE));
      state.marketPage=clamp(state.marketPage+delta,0,totalPages-1);
      renderMarketStock();
    }

    function renderCrafting(){
      if(!dom.crafting) return;
      dom.crafting.innerHTML='';
      if(!CRAFTING_RECIPES.length){
        const empty=document.createElement('div');
        empty.className='muted-box';
        empty.textContent='No recipes available yet.';
        dom.crafting.appendChild(empty);
        return;
      }
      const totalPages=Math.max(1,Math.ceil(CRAFTING_RECIPES.length/CRAFTING_PAGE_SIZE));
      state.craftingPage=clamp(state.craftingPage,0,totalPages-1);
      const start=state.craftingPage*CRAFTING_PAGE_SIZE;
      const visibleRecipes=CRAFTING_RECIPES.slice(start,start+CRAFTING_PAGE_SIZE);
      const grid=document.createElement('div');
      grid.className='recipe-grid';
      visibleRecipes.forEach(recipe=>{
        const card=document.createElement('div');
        card.className='recipe-card';
        const titleRow=document.createElement('div');
        titleRow.className='title-row';
        titleRow.innerHTML=`<span>${recipe.label}</span><span class="small">craft</span>`;
        const desc=document.createElement('div');
        desc.className='small';
        desc.textContent=recipe.desc;
        const reqs=document.createElement('div');
        reqs.className='reqs';
        const reqParts=Object.entries(recipe.cost).map(([id,count])=>{
          const have=getItemCount(state.inventory,id);
          const status=have>=count?'✓':'•';
          return `${status} ${id} ${have}/${count}`;
        });
        reqs.textContent=reqParts.join(' · ');
        const craftBtn=document.createElement('button');
        craftBtn.textContent=`Craft ${recipe.label}`;
        const canCraft=hasCraftingMaterials(recipe) && hasCapacityFor(state.inventory,getBackpackLimit(),recipe.id,1);
        craftBtn.disabled=!canCraft;
        if(!hasCraftingMaterials(recipe)) craftBtn.title='Missing materials.';
        else if(!hasCapacityFor(state.inventory,getBackpackLimit(),recipe.id,1)) craftBtn.title='Backpack capacity reached.';
        craftBtn.onclick=()=>craftRecipe(recipe.id);
        card.appendChild(titleRow);
        card.appendChild(desc);
        card.appendChild(reqs);
        card.appendChild(craftBtn);
        grid.appendChild(card);
      });
      dom.crafting.appendChild(grid);
      if(totalPages>1){
        const pager=document.createElement('div');
        pager.className='pager';
        const prev=document.createElement('button');
        prev.textContent='Previous recipes';
        prev.disabled=state.craftingPage===0;
        prev.onclick=()=>changeCraftingPage(-1);
        const info=document.createElement('div');
        info.className='page-info';
        const end=Math.min(CRAFTING_RECIPES.length,start+visibleRecipes.length);
        info.textContent=`Showing recipes ${start+1}-${end} of ${CRAFTING_RECIPES.length}`;
        const next=document.createElement('button');
        next.textContent='More recipes';
        next.disabled=state.craftingPage>=totalPages-1;
        next.onclick=()=>changeCraftingPage(1);
        pager.appendChild(prev);
        pager.appendChild(info);
        pager.appendChild(next);
        dom.crafting.appendChild(pager);
      }
    }

    function renderMarketStock(){
      if(!dom.marketInventory) return;
      dom.marketInventory.innerHTML='';
      const marketActive=canAccessMarket();
      const zoneId=state.marketAccess.zoneId || state.zone.id;
      const stockList=getMarketStockForZone(zoneId);
      if(dom.marketHint){
        const zoneName=expansions[zoneId]?.meta?.name || state.zone.name;
        dom.marketHint.textContent=marketActive
          ? `Market vendors are online in ${zoneName}. Trade while the shop is open.`
          : 'Visit a shop in your current location to access vendors.';
      }
      const totalPages=Math.max(1,Math.ceil(stockList.length/MARKET_PAGE_SIZE));
      state.marketPage=clamp(state.marketPage,0,totalPages-1);
      const start=state.marketPage*MARKET_PAGE_SIZE;
      const visibleStock=stockList.slice(start,start+MARKET_PAGE_SIZE);
      const grid=document.createElement('div');
      grid.className='market-grid';
      visibleStock.forEach(stock=>{
        const data=getItem(stock.id);
        const card=document.createElement('div');
        card.className='market-card';
        const titleRow=document.createElement('div');
        titleRow.className='title-row';
        titleRow.innerHTML=`<span>${stock.id}</span><span class="small">${stock.tag}</span>`;
        const desc=document.createElement('div');
        desc.className='small';
        desc.textContent=`${rarityLabel(data.rarity)} · ${data.type}`;
        const cost=document.createElement('div');
        cost.className='cost';
        cost.textContent=`${stock.cost} credits`;
        const btn=document.createElement('button');
        btn.textContent=`Buy ${stock.id}`;
        const canBuy=marketActive && state.credits>=stock.cost && hasCapacityFor(state.inventory,getBackpackLimit(),stock.id,1);
        btn.disabled=!canBuy;
        if(!marketActive) btn.title='Visit a shop to buy.';
        else if(!hasCapacityFor(state.inventory,getBackpackLimit(),stock.id,1)) btn.title='Backpack full.';
        else if(state.credits<stock.cost) btn.title='Not enough credits.';
        btn.onclick=()=>buyMarketItem(stock.id);
        card.appendChild(titleRow);
        card.appendChild(desc);
        card.appendChild(cost);
        card.appendChild(btn);
        grid.appendChild(card);
      });
      dom.marketInventory.appendChild(grid);
      if(totalPages>1){
        const pager=document.createElement('div');
        pager.className='pager';
        const prev=document.createElement('button');
        prev.textContent='Previous items';
        prev.disabled=state.marketPage===0;
        prev.onclick=()=>changeMarketPage(-1);
        const info=document.createElement('div');
        info.className='page-info';
        const end=Math.min(stockList.length,start+visibleStock.length);
        info.textContent=`Showing items ${start+1}-${end} of ${stockList.length}`;
        const next=document.createElement('button');
        next.textContent='More items';
        next.disabled=state.marketPage>=totalPages-1;
        next.onclick=()=>changeMarketPage(1);
        pager.appendChild(prev);
        pager.appendChild(info);
        pager.appendChild(next);
        dom.marketInventory.appendChild(pager);
      }
    }

    function renderIdleOps(){
      dom.idleOps.innerHTML='';
      const gearMods=getGearMods();
      const vaultAccess=canAccessVault();
      syncIdleSlots();
      const idleRewards=state.idleRewards || [];
      const activeSlots=state.idleOps.filter(slot=>slot.active);
      const completedSlots=state.idleOps.filter(slot=>slot.completed);
      activeSlots.forEach(slot=>{
        const op=idleOperations.find(entry=>entry.id===slot.id);
        if(!op) return;
        const startedAt=Number.isFinite(slot.startedAt) ? slot.startedAt : Date.now();
        const elapsed=Math.max(0,(Date.now()-startedAt)/1000);
        const total=Math.max(1,slot.durationMs/1000);
        const pctDone=clamp((elapsed/total)*100,0,100);
        const card=document.createElement('div');
        card.className='op-card';
        const title=document.createElement('div');
        title.innerHTML=`<b>${op.label}</b> · in progress`;
        const progress=document.createElement('div');
        progress.className='progress';
        progress.innerHTML=`<span style="width:${pctDone}%;"></span>`;
        const meta=document.createElement('div');
        meta.className='op-meta';
        const remainingMinutes=Math.max(0,(total-elapsed)/60);
        meta.textContent=`ETA ${formatMinutesPrecise(remainingMinutes)} · ${op.desc}`;
        const signal=document.createElement('div');
        signal.className='op-meta';
        signal.textContent=slot.statusMessage || 'Operation underway.';
        card.appendChild(title);
        card.appendChild(progress);
        card.appendChild(meta);
        card.appendChild(signal);
        dom.idleOps.appendChild(card);
      });
      completedSlots.forEach((slot,index)=>{
        const op=idleOperations.find(entry=>entry.id===slot.id);
        const card=document.createElement('div');
        card.className='op-card';
        const title=document.createElement('div');
        title.innerHTML=`<b>${op?.label || 'Idle operation'}</b> · complete`;
        const meta=document.createElement('div');
        meta.className='op-meta';
        meta.textContent=slot.statusMessage || 'Rewards routed to idle cache.';
        card.appendChild(title);
        card.appendChild(meta);
        const footer=document.createElement('div');
        footer.className='op-actions';
        const closeBtn=document.createElement('button');
        closeBtn.textContent='Clear slot';
        closeBtn.disabled=idleRewards.length>0;
        closeBtn.title=idleRewards.length>0 ? 'Resolve idle rewards before clearing slots.' : '';
        closeBtn.onclick=()=>closeIdleOp(state.idleOps.indexOf(slot));
        footer.appendChild(closeBtn);
        card.appendChild(footer);
        dom.idleOps.appendChild(card);
      });
      if(idleRewards.length){
        const rewardCard=document.createElement('div');
        rewardCard.className='op-card';
        const title=document.createElement('div');
        title.innerHTML='<b>Idle rewards cache</b> · ready';
        const meta=document.createElement('div');
        meta.className='op-meta';
        meta.textContent='Resolve idle rewards before dispatching again.';
        rewardCard.appendChild(title);
        rewardCard.appendChild(meta);
        const rewardsWrap=document.createElement('div');
        rewardsWrap.className='item-grid';
        groupItems(idleRewards).forEach(({id,count,data})=>{
          const row=buildItemRow({id,count,data,source:'idleReward'});
          rewardsWrap.appendChild(row);
          const actions=document.createElement('div');
          actions.className='inline-actions';
          const packBtn=document.createElement('button');
          packBtn.textContent='Take one';
          packBtn.disabled=!hasCapacityFor(state.inventory,getBackpackLimit(),id,1);
          packBtn.onclick=()=>claimRewardToInventory('idleReward',id);
          actions.appendChild(packBtn);
          const stackBtn=document.createElement('button');
          stackBtn.textContent='Take stack';
          stackBtn.disabled=!hasCapacityFor(state.inventory,getBackpackLimit(),id,count);
          stackBtn.onclick=()=>claimRewardStackToInventory('idleReward',id);
          actions.appendChild(stackBtn);
          if(data.slot){
            const equipBtn=document.createElement('button');
            equipBtn.textContent='Equip';
            equipBtn.disabled=!canEquipItem(id,'idleReward').ok;
            equipBtn.onclick=()=>equipRewardItem('idleReward',id);
            actions.appendChild(equipBtn);
          }
          const vaultBtn=document.createElement('button');
          vaultBtn.textContent='Vault';
          vaultBtn.disabled=!vaultAccess || !hasCapacityFor(state.stash.items,state.stashLimit,id,1);
          vaultBtn.title=vaultAccess ? '' : vaultBlockedMessage;
          vaultBtn.onclick=()=>claimRewardToVault('idleReward',id);
          actions.appendChild(vaultBtn);
          const scrapBtn=document.createElement('button');
          scrapBtn.textContent='Break down';
          scrapBtn.onclick=()=>scrapRewardItem('idleReward',id);
          actions.appendChild(scrapBtn);
          const leaveBtn=document.createElement('button');
          leaveBtn.textContent='Leave';
          leaveBtn.onclick=()=>leaveRewardItem('idleReward',id);
          actions.appendChild(leaveBtn);
          rewardsWrap.appendChild(actions);
        });
        rewardCard.appendChild(rewardsWrap);
        const footer=document.createElement('div');
        footer.className='op-actions';
        const leaveAll=document.createElement('button');
        leaveAll.textContent='Leave all rewards';
        leaveAll.onclick=()=>clearRewardSource('idleReward');
        footer.appendChild(leaveAll);
        rewardCard.appendChild(footer);
        dom.idleOps.appendChild(rewardCard);
      }
      const availableIdleOps=idleOperations.filter(op=>!op.unlockFlag || state.flags.has(op.unlockFlag));
      const hasOpenSlot=state.idleOps.some(slot=>!slot.active && !slot.completed);
      const blockedDispatch=idleRewards.length>0 || !hasOpenSlot;
      if(!availableIdleOps.length){
        const locked=document.createElement('div');
        locked.className='muted-box';
        locked.textContent='Idle dispatches locked. Complete special missions to unlock them.';
        dom.idleOps.appendChild(locked);
        return;
      }
      availableIdleOps.forEach(op=>{
        const card=document.createElement('div');
        card.className='op-card';
        const title=document.createElement('div');
        title.innerHTML=`<b>${op.label}</b>`;
        const meta=document.createElement('div');
        meta.className='op-meta';
        const duration=getIdleDurationMinutes(op,gearMods);
        meta.textContent=`${op.desc} · ${formatMinutesPrecise(duration)}`;
        const cost=document.createElement('div');
        cost.className='op-meta';
        const xpLabel=op.xp ? ` · XP ${op.xp}` : '';
        cost.textContent=`Cost: ${formatCost(op.cost)} · Reward: ${op.reward}${xpLabel}`;
        const actions=document.createElement('div');
        actions.className='op-actions';
        const btn=document.createElement('button');
        btn.textContent='Dispatch';
        btn.onclick=()=>startIdleOp(op.id);
        if(blockedDispatch || !canAfford(op.cost)) btn.disabled=true;
        if(idleRewards.length>0){
          btn.title='Resolve idle rewards before dispatching again.';
        }else if(!hasOpenSlot){
          btn.title='All idle dispatch slots are in use.';
        }
        actions.appendChild(btn);
        card.appendChild(title);
        card.appendChild(meta);
        card.appendChild(cost);
        card.appendChild(actions);
        dom.idleOps.appendChild(card);
      });
    }

    function setActiveTab(tab){
      activeTab=tab;
      syncTabs();
    }

    function syncTabs(){
      dom.tabButtons.forEach(btn=>{
        const target=btn.dataset.tab;
        btn.classList.toggle('active',target===activeTab);
        btn.disabled=false;
      });
      if(state.mission.active){
        const stashBtn=dom.tabButtons.find(btn=>btn.dataset.tab==='field');
        if(stashBtn) stashBtn.disabled=true;
      }
      Object.entries(dom.tabContents).forEach(([id,el])=>{
        el.classList.toggle('active',id===activeTab);
      });
    }

    dom.tabButtons.forEach(btn=>{
      btn.onclick=()=>{ activeTab=btn.dataset.tab; syncTabs(); };
    });
    if(dom.codexToggle){
      dom.codexToggle.onclick=()=>{
        state.codexExpanded=!state.codexExpanded;
        renderCodex();
      };
    }

    function setInventoryScreen(screen){
      const changed=state.inventoryScreen!==screen;
      state.inventoryScreen=screen;
      dom.inventoryNav.forEach(btn=>{
        btn.classList.toggle('active',btn.dataset.invScreen===screen);
      });
      Object.entries(dom.inventoryScreens).forEach(([id,el])=>{
        el.classList.toggle('active',id===screen);
      });
      if(changed){
        clearSelection();
      }
    }

    function setStashScreen(screen){
      const changed=state.stashScreen!==screen;
      state.stashScreen=screen;
      dom.stashNav.forEach(btn=>{
        btn.classList.toggle('active',btn.dataset.stashScreen===screen);
      });
      Object.entries(dom.stashScreens).forEach(([id,el])=>{
        el.classList.toggle('active',id===screen);
      });
      if(changed){
        clearSelection();
      }
    }

    dom.inventoryNav.forEach(btn=>{
      btn.onclick=()=>setInventoryScreen(btn.dataset.invScreen);
    });

    dom.stashNav.forEach(btn=>{
      btn.onclick=()=>setStashScreen(btn.dataset.stashScreen);
    });

    function clearSelection(){
      if(!state.selected.source) return;
      state.selected={source:null,item:null};
      renderItemDetails();
      renderInventory();
      renderStash();
      renderMissionStatus();
      renderIdleOps();
    }

    function selectItem(source,item){
      state.selected={source,item};
      renderItemDetails();
      renderInventory();
      renderStash();
      renderMissionStatus();
      renderIdleOps();
    }

    function isMissionBlockingTravel(){
      return state.mission.active && !state.mission.completed;
    }

    function isRewardBlockingTravel(){
      return state.mission.active && state.mission.completed && (state.mission.rewards?.length||0)>0;
    }

    function syncMissionCompletion(){
      if(!state.mission.active || state.mission.completed) return;
      const now=Date.now();
      normalizeMissionTiming(now);
      if(state.mission.type==='combat'){
        combatTick(now);
        if(state.mission.completed) return;
        if(state.mission.fleeing && now>=state.mission.endsAt){
          completeMission({combatResolved:true});
        }else if(now>=state.mission.endsAt){
          completeMission({combatResolved:true,forcedFail:true});
        }
        return;
      }
      if(now>=state.mission.endsAt){
        completeMission();
      }
    }

    function setScreen(screen){
      syncMissionCompletion();
      if(screen==='locations' && isMissionBlockingTravel()){
        setCodex('Mission in progress. Locations hub locked.');
        return;
      }
      if(screen==='main' && isMissionBlockingTravel()){
        setCodex('Mission in progress. Stay on the raid feed.');
        return;
      }
      if(screen==='mission' && !state.mission.active){
        setCodex('No mission active.');
        return;
      }
      state.screen=screen;
      if(screen==='locations'){
        ensureExpansionsLoaded();
      }
      renderAll();
    }

    function renderScreens(){
      syncMissionCompletion();
      dom.screenButtons.forEach(btn=>{
        const target=btn.dataset.screen;
        const isLocked=target==='mission' && !state.mission.active;
        const isLocationsLocked=target==='locations' && isMissionBlockingTravel();
        const isMainLocked=target==='main' && isMissionBlockingTravel();
        btn.classList.toggle('active',target===state.screen);
        btn.disabled=isLocked || isLocationsLocked || isMainLocked;
      });
      Object.entries(dom.screens).forEach(([id,el])=>{
        el.classList.toggle('active',id===state.screen);
      });
    }

    dom.screenButtons.forEach(btn=>{
      btn.onclick=()=>setScreen(btn.dataset.screen);
    });
    if(dom.pauseToggle){
      dom.pauseToggle.onclick=()=>{
        if(state.paused){
          const delta=Date.now()-(state.pausedAt || Date.now());
          state.paused=false;
          state.pausedAt=null;
          adjustTimersForPause(delta);
          setCodex('Gameplay resumed.');
        }else{
          state.paused=true;
          state.pausedAt=Date.now();
          setCodex('Gameplay paused.');
        }
        renderAll();
      };
    }
    if(dom.doorsToggle){
      dom.doorsToggle.onclick=()=>{
        state.doorsCollapsed=!state.doorsCollapsed;
        renderDoors();
      };
    }

    function renderPauseToggle(){
      if(!dom.pauseToggle) return;
      dom.pauseToggle.textContent=state.paused ? 'Play' : 'Pause';
      dom.pauseToggle.setAttribute('aria-pressed',state.paused ? 'true' : 'false');
    }

    function renderZone(){
      const exp=expansions[state.zone.id];
      if(exp){
        state.zone.risk=getZoneRiskForExp(exp,state.zone.risk);
      }
      const scene=ensureZoneScene(state.zone);
      dom.zoneTitle.textContent=scene?.title ? `${state.zone.name} · ${scene.title}` : state.zone.name;
      dom.zoneDesc.textContent=scene?.desc || state.zone.desc;
      dom.zoneBadge.textContent=`${state.zone.risk} risk`;
      applyRiskClasses(dom.zoneBadge,state.zone.risk);
    }

    function formatRewardEstimate({loot=0,lootType='',reward='',risk='low',time=8,xp}={}){
      const parts=[];
      if(loot){
        const min=Math.max(1,loot);
        const max=Math.max(min,loot+2);
        const lootLabel=`${min}-${max} loot`;
        parts.push(lootType ? `${lootLabel} ${lootType}` : lootLabel);
      }
      if(reward) parts.push(reward);
      const xpValue=Number.isFinite(xp) ? xp : computeMissionXp(risk,time);
      if(xpValue) parts.push(`XP ${xpValue}`);
      return parts.length ? `Rewards ${parts.join(' · ')}` : '';
    }

    function buildMissionMeta({risk='low',time=8,energy,key,loot=0,lootType='',reward='',xp}={}){
      const parts=[`${risk} · ${formatDisplayMinutes(time)} min`];
      const rewardLabel=formatRewardEstimate({loot,lootType,reward,risk,time,xp});
      if(rewardLabel) parts.push(rewardLabel);
      if(Number.isFinite(energy)){
        const costParts=[`${energy} energy`];
        if(key) costParts.push(`${key} key`);
        parts.push(costParts.join(' · '));
      }
      return parts.join(' · ');
    }

    function renderRaidActions(){
      dom.raidActions.innerHTML='';
      const exp=expansions[state.zone.id];
      const scene=ensureZoneScene(state.zone);
      if(scene && scene.options && scene.options.length){
        scene.options.forEach(option=>{
          const optionFlag=option.flag;
          if(option.once && optionFlag && state.flags.has(optionFlag)) return;
          const btn=document.createElement('button');
          const label=option.label || 'Local action';
          const meta=buildMissionMeta({
            risk:option.risk,
            time:option.time,
            loot:option.loot,
            lootType:option.lootType,
            reward:option.reward
          });
          btn.innerHTML=`<span>${label}</span><span class="small">${meta}</span>`;
          btn.onclick=()=>startSceneAction(option);
          if(state.mission.active || state.travel.active) btn.disabled=true;
          if(option.risk==='high') btn.classList.add('danger');
          dom.raidActions.appendChild(btn);
        });
      }
      const vendorEligible=zoneHasShop();
      if(vendorEligible){
        const shopBtn=document.createElement('button');
        shopBtn.innerHTML=`<span>Visit shop</span><span class="small">trade · vendors</span>`;
        shopBtn.onclick=()=>openMarketAccess();
        if(state.mission.active || state.travel.active) shopBtn.disabled=true;
        dom.raidActions.appendChild(shopBtn);
      }
      if(exp && exp.quests && exp.quests.length){
        exp.quests.forEach(quest=>{
          const btn=document.createElement('button');
          const questFlag=quest.flag || quest.id;
          const completed=quest.once && questFlag && state.flags.has(questFlag);
          const requiresFlag=quest.requires;
          const blockedByRequirement=requiresFlag && !state.flags.has(requiresFlag);
          const label=quest.title || 'Local contract';
          const time=quest.time || 10;
          const risk=quest.risk || state.zone.risk;
          const energy=quest.energy ?? 12;
          const keyCost=quest.key || 0;
          const meta=buildMissionMeta({
            risk,
            time,
            energy,
            key:keyCost,
            loot:quest.loot || 0,
            lootType:quest.lootType || '',
            reward:quest.reward || ''
          });
          btn.innerHTML=`<span>${label}</span><span class="small">${meta}</span>`;
          btn.onclick=()=>runQuest(quest);
          if(completed){
            btn.disabled=true;
            btn.title='Contract complete.';
          }else if(blockedByRequirement){
            btn.disabled=true;
            btn.title='Complete the prerequisite contract to unlock this.';
          }else if(state.mission.active || state.travel.active || !canAfford({energy,keys:keyCost})){
            btn.disabled=true;
          }
          if(risk==='high') btn.classList.add('danger');
          dom.raidActions.appendChild(btn);
        });
      }
      const hubZone=isHubZone();
      if(hubZone){
        const hubMissions=(exp?.missions || []).filter(isHubMission);
        if(hubMissions.length){
          hubMissions.forEach(raid=>{
            const btn=document.createElement('button');
            const meta=buildMissionMeta({
              risk:raid.risk,
              time:raid.time,
              energy:raid.energy,
              key:raid.key,
              loot:raid.loot,
              lootType:raid.lootType,
              reward:raid.reward,
              xp:raid.xp
            });
            btn.innerHTML=`<span>${raid.label}</span><span class="small">${meta}</span>`;
            btn.onclick=()=>startMission(raid);
            const adviceDepleted=isElderAdviceMission(raid) && isElderAdviceExhausted();
            if(adviceDepleted){
              btn.disabled=true;
              btn.title="You're very wise, young one.";
            }else if(state.mission.active || state.travel.active || !canAfford({energy:raid.energy,keys:raid.key||0})){
              btn.disabled=true;
            }
            if(raid.risk==='high') btn.classList.add('danger');
            dom.raidActions.appendChild(btn);
          });
        }
      }
      if(hubZone && !dom.raidActions.children.length){
        const blocked=document.createElement('div');
        blocked.className='muted-box';
        blocked.textContent='Hub zone secure. Use the transit console to select a field site.';
        dom.raidActions.appendChild(blocked);
        return;
      }
      if(!hubZone){
        const missions=(exp?.missions && exp.missions.length) ? exp.missions : RAID_TEMPLATES;
        missions.forEach(raid=>{
          const btn=document.createElement('button');
          const meta=buildMissionMeta({
            risk:raid.risk,
            time:raid.time,
            energy:raid.energy,
            key:raid.key,
            loot:raid.loot,
            lootType:raid.lootType,
            reward:raid.reward,
            xp:raid.xp
          });
          btn.innerHTML=`<span>${raid.label}</span><span class="small">${meta}</span>`;
          btn.onclick=()=>startMission(raid);
          if(state.mission.active || state.travel.active || !canAfford({energy:raid.energy,keys:raid.key||0})) btn.disabled=true;
          if(raid.risk==='high') btn.classList.add('danger');
          dom.raidActions.appendChild(btn);
        });
        const combatBtn=document.createElement('button');
        const combatProfile=getCombatProfile(state.zone.risk);
        const combatMeta=buildMissionMeta({
          risk:combatProfile.risk,
          time:combatProfile.time,
          energy:10,
          loot:2+Math.floor(combatProfile.difficulty),
          lootType:'combat salvage',
          xp:computeMissionXp(combatProfile.risk,combatProfile.time)
        });
        combatBtn.innerHTML=`<span>Engage hostiles</span><span class="small">${combatMeta}</span>`;
        combatBtn.onclick=startCombatMission;
        if(state.mission.active || state.travel.active || !canAfford({energy:10})) combatBtn.disabled=true;
        combatBtn.classList.add('danger');
        dom.raidActions.appendChild(combatBtn);
        const canCamp=state.screen==='locations' && state.zone.id!=='safehouse';
        if(canCamp){
          const rest=document.createElement('button');
        rest.innerHTML=`<span>Make camp</span><span class="small">recover · ${formatDisplayMinutes(ACTION_TIMES.camp)} min</span>`;
          rest.onclick=runCamp;
          if(state.mission.active || state.travel.active) rest.disabled=true;
          dom.raidActions.appendChild(rest);
        }
      }
    }

    function openMarketAccess(){
      if(state.mission.active || state.travel.active){
        setCodex('Finish current operations before visiting vendors.');
        return;
      }
      if(!zoneHasShop()){
        setCodex('No vendors are set up here.');
        return;
      }
      state.marketAccess={active:true,zoneId:state.zone.id};
      state.marketPage=0;
      setCodex('Vendor bay open. Trade out of your active pack while the shop is live.');
      setActiveTab('field');
      setStashScreen('market');
      renderAll();
    }

    function startSceneAction(option){
      if(state.mission.active){
        setCodex('Mission already underway.');
        return;
      }
      if(state.travel.active){
        setCodex('Finish travel before taking local action.');
        return;
      }
      startLoops();
      const label=option.label || 'Local action';
      const risk=option.risk || state.zone.risk;
      const time=option.time || 8;
      const durationMs=computeMissionDurationMs({risk,time,loot:option.loot});
      const raidLike={
        id:`scene-${Date.now()}`,
        label,
        desc:'',
        time,
        energy:0,
        loot:0,
        risk
      };
      const now=Date.now();
      state.mission={
        active:true,
        type:'scene',
        raid:raidLike,
        startedAt:now,
        endsAt:now+durationMs,
        completed:false,
        success:null,
        summary:'',
        rewards:[],
        statusMessage:`Action underway: ${label}.`,
        location:{...state.zone},
        fleeing:false,
        fleeEndsAt:null,
        pendingResolution:null,
        xpReward:computeMissionXp(risk,time),
        rewardEffects:{success:option.success||'',fail:option.fail||''},
        questMeta:null,
        combat:null,
        sceneTarget:option.target || null
      };
      setCodex(`Action launched: ${label}.`);
      logMsg(`Local action: ${label} (${formatDisplayMinutes(time)} min).`);
      setActiveTab('hub');
      setScreen('mission');
      normalizeMissionTiming(Date.now());
      renderAll();
    }

    function resolveTravelIfComplete(){
      if(!state.travel.active) return false;
      if(!state.travel.target || !state.travel.endsAt){
        state.travel={active:false,endsAt:null,target:null};
        setCodex('Transit data lost. Select a zone gate to reroute.');
        logMsg('Transit data lost. Zone selection reset.');
        if(travelResolveTimer){
          clearTimeout(travelResolveTimer);
          travelResolveTimer=null;
        }
        return true;
      }
      if(Date.now()<state.travel.endsAt) return false;
      state.zone=state.travel.target;
      clearMarketAccess();
      state.travel={active:false,endsAt:null,target:null};
      setCodex(`Arrived at ${state.zone.name}.`);
      logMsg(`Transit complete: ${state.zone.name}.`);
      saveGame();
      if(travelResolveTimer){
        clearTimeout(travelResolveTimer);
        travelResolveTimer=null;
      }
      return true;
    }

    function renderTravelStatus(){
      if(resolveTravelIfComplete()){
        return renderTravelStatus();
      }
      const doorButtons=dom.doors.querySelectorAll('button');
      doorButtons.forEach(btn=>{
        if(btn.dataset.action==='travel'){
          const locked=btn.dataset.locked === 'true';
          btn.disabled=locked || state.mission.active || state.travel.active || isRewardBlockingTravel();
          return;
        }
        if(btn.dataset.action==='unlock'){
          btn.disabled=state.mission.active || state.travel.active;
        }
      });
      if(state.travel.active){
        scheduleTravelResolution();
      }
    }

    function renderMissionStatus(){
      if(!state.mission.active){
        dom.missionTitle.textContent='No mission active.';
        dom.missionMeta.textContent='Launch a raid from the locations hub to enter the field.';
        dom.missionProgress.querySelector('span').style.width='0%';
        dom.missionLog.textContent='';
        dom.missionActions.innerHTML='';
        if(dom.missionRewardsCard) dom.missionRewardsCard.style.display='none';
        if(dom.missionRewardList) dom.missionRewardList.innerHTML='';
        if(dom.missionRewardHint) dom.missionRewardHint.textContent='Complete a mission to review rewards.';
        return;
      }
      const raid=state.mission.raid;
      const remainingMs=Math.max(0,state.mission.endsAt-Date.now());
      const totalMs=Math.max(1,state.mission.endsAt-state.mission.startedAt);
      const percent=clamp(((totalMs-remainingMs)/totalMs)*100,0,100);
      dom.missionProgress.querySelector('span').style.width=`${state.mission.completed ? 100 : percent}%`;
      const remainingSec=Math.ceil(remainingMs/1000);
      const labelPrefix=state.mission.type==='combat'
        ? 'In combat'
        : (state.mission.type==='contract'
          ? 'In contract'
          : (state.mission.type==='scene' ? 'In action' : 'In raid'));
      dom.missionTitle.textContent=state.mission.completed
        ? `Mission complete: ${raid.label}`
        : `${labelPrefix}: ${raid.label}`;
      const etaLabel=state.mission.fleeing ? 'Escaping…' : `ETA ${remainingSec}s`;
      dom.missionMeta.textContent=`${raid.risk} risk · ${formatDisplayMinutes(raid.time)} min op · ${state.mission.location?.name || state.zone.name} · XP ${state.mission.xpReward || computeMissionXp(raid.risk,raid.time)} · ${state.mission.completed ? 'Rewards ready' : etaLabel}`;
      const liveMessage=state.mission.statusMessage || state.mission.summary;
      dom.missionLog.textContent=liveMessage || 'Stay sharp. Watch the feed for extraction clearance.';
      dom.missionActions.innerHTML='';
      const rewards=state.mission.rewards || [];
      const rewardsReady=state.mission.completed && rewards.length>0;
      if(state.mission.completed && rewards.length===0){
        autoCloseMissionIfResolved();
        if(!state.mission.active) return;
      }
      if(dom.missionRewardsCard){
        dom.missionRewardsCard.style.display=state.mission.completed ? 'flex' : 'none';
      }
      if(dom.missionRewardList){
        dom.missionRewardList.innerHTML='';
        if(rewardsReady){
          if(dom.missionRewardHint) dom.missionRewardHint.textContent='Select a reward to choose an action.';
          const grid=document.createElement('div');
          grid.className='icon-grid';
          groupItems(rewards).forEach(({id,count,data})=>{
            grid.appendChild(buildRewardTile({id,count,data,source:'missionReward'}));
          });
          dom.missionRewardList.appendChild(grid);
        }else if(state.mission.completed){
          if(dom.missionRewardHint) dom.missionRewardHint.textContent='Rewards resolved.';
          const empty=document.createElement('div');
          empty.className='muted-box';
          empty.textContent=state.mission.success ? 'No rewards remaining. Mission will close automatically.' : 'Mission failed. Mission will close automatically.';
          dom.missionRewardList.appendChild(empty);
        }
      }
      if(!state.mission.completed && state.mission.type==='combat'){
        const combat=state.mission.combat;
        if(combat){
          const hud=document.createElement('div');
          hud.className='combat-hud';
          const title=document.createElement('div');
          title.className='combat-title';
          title.textContent=`Signal log: ${raid.enemyName}`;
          const stats=document.createElement('div');
          stats.className='combat-stats';
          const consumeState=combat.consumable
            ? `Applying ${combat.consumable.item} (${Math.max(0,Math.ceil((combat.consumable.readyAt-Date.now())/1000))}s)`
            : 'No consumable in use';
          stats.innerHTML=`<div><b>Enemy HP</b> ${Math.max(0,Math.round(combat.enemyHp))}/${Math.round(combat.enemyMaxHp)}</div>`+
            `<div><b>Enemies left</b> ${combat.enemiesRemaining}/${combat.totalEnemies}</div>`+
            `<div><b>You dealt</b> ${Math.round(combat.totalDamageDealt)}</div>`+
            `<div><b>You took</b> ${Math.round(combat.totalDamageTaken)}</div>`+
            `<div><b>Consumable</b> ${consumeState}</div>`;
          hud.appendChild(title);
          hud.appendChild(stats);
          const consumables=document.createElement('div');
          consumables.className='combat-consumables';
          const consumableItems=groupItems(state.inventory.filter(item=>getItem(item).type==='consumable'));
          if(consumableItems.length){
            const hint=document.createElement('div');
            hint.className='small';
            hint.textContent='Backpack consumables (3s channel, one at a time):';
            consumables.appendChild(hint);
            consumableItems.forEach(({id,count})=>{
              const btn=document.createElement('button');
              btn.textContent=`Use ${id} ×${count}`;
              btn.disabled=Boolean(combat.consumable);
              btn.onclick=()=>applyCombatConsumable(id);
              consumables.appendChild(btn);
            });
          }else{
            const empty=document.createElement('div');
            empty.className='small';
            empty.textContent='No consumables in backpack.';
            consumables.appendChild(empty);
          }
          hud.appendChild(consumables);
          dom.missionActions.appendChild(hud);
        }
        const fleeBtn=document.createElement('button');
        fleeBtn.textContent=state.mission.fleeing ? 'Fleeing…' : 'Flee (5s)';
        fleeBtn.disabled=state.mission.fleeing;
        fleeBtn.onclick=attemptFlee;
        dom.missionActions.appendChild(fleeBtn);
      }
      if(state.mission.completed){
        if(rewardsReady){
          const leaveAll=document.createElement('button');
          leaveAll.textContent='Leave all rewards';
          leaveAll.onclick=()=>clearRewardSource('missionReward');
          dom.missionActions.appendChild(leaveAll);
        }
        const closeBtn=document.createElement('button');
        closeBtn.textContent='Close mission';
        closeBtn.disabled=rewards.length>0;
        closeBtn.onclick=closeMission;
        dom.missionActions.appendChild(closeBtn);
      }
    }

    function renderStash(){
      dom.stash.innerHTML='';
      dom.marketBackpack.innerHTML='';
      dom.stashActions.innerHTML='';
      const vaultAccess=canAccessVault();
      const marketActive=canAccessMarket();
      const inMarketScreen=state.stashScreen==='market';
      if(dom.stashTitle){
        dom.stashTitle.textContent=inMarketScreen ? 'Trade Bay' : 'Stash Vault';
      }
      if(dom.stashCommandTitle){
        dom.stashCommandTitle.textContent=inMarketScreen ? 'Trade Console' : 'Vault Command Card';
      }
      if(inMarketScreen){
        if(dom.marketSubtitle){
          dom.marketSubtitle.innerHTML=`Backpack Inventory <span class="small" id="marketBackpackCount"></span>`;
          dom.marketBackpackCount=document.getElementById('marketBackpackCount');
        }
        if(dom.marketBackpackCount){
          dom.marketBackpackCount.textContent=`(${getBackpackUsage()}/${getBackpackLimit()})`;
        }
        const items=state.inventory;
        if(!items.length){
          const empty=document.createElement('div');
          empty.className='muted-box';
          empty.textContent='Backpack is empty. Trade when you have gear on hand.';
          dom.marketBackpack.appendChild(empty);
        }else{
          const grid=document.createElement('div');
          grid.className='icon-grid';
          const grouped=groupItems(items);
          const {entries,page,totalPages}=paginateEntries(grouped,'stashPage',GRID_PAGE_SIZE);
          entries.forEach(({id,count,data})=>{
            grid.appendChild(buildItemTile({id,count,data,source:'inventory'}));
          });
          dom.marketBackpack.appendChild(grid);
          const pager=renderPager({
            page,
            totalPages,
            label:'items',
            onPrev:()=>{state.stashPage=Math.max(0,page-1); renderStash();},
            onNext:()=>{state.stashPage=Math.min(totalPages-1,page+1); renderStash();}
          });
          if(pager) dom.marketBackpack.appendChild(pager);
        }
        const notice=document.createElement('div');
        notice.className='muted-box';
        notice.textContent=marketActive
          ? 'Trade bay open. Select backpack items to sell or break down.'
          : 'Visit a shop to trade with local vendors.';
        dom.stashActions.appendChild(notice);
        renderMarketStock();
        return;
      }
      if(dom.stashSubtitle){
        dom.stashSubtitle.innerHTML=`Vault Inventory <span class="small" id="stashCount"></span>`;
        dom.stashCount=document.getElementById('stashCount');
      }
      if(dom.stashCount){
        dom.stashCount.textContent=`(${getStashUsage()}/${state.stashLimit})`;
      }
      const items=state.stash.items;
      if(!items.length){
        const empty=document.createElement('div');
        empty.className='muted-box';
        empty.textContent='Stash is empty. Move loot here for long-term storage.';
        dom.stash.appendChild(empty);
      }else{
        const grid=document.createElement('div');
        grid.className='icon-grid';
        const grouped=groupItems(items);
        const {entries,page,totalPages}=paginateEntries(grouped,'stashPage',GRID_PAGE_SIZE);
        entries.forEach(({id,count,data})=>{
          grid.appendChild(buildItemTile({id,count,data,source:'stash'}));
        });
        dom.stash.appendChild(grid);
        const pager=renderPager({
          page,
          totalPages,
          label:'items',
          onPrev:()=>{state.stashPage=Math.max(0,page-1); renderStash();},
          onNext:()=>{state.stashPage=Math.min(totalPages-1,page+1); renderStash();}
        });
        if(pager) dom.stash.appendChild(pager);
      }
      if(!vaultAccess){
        const blocked=document.createElement('div');
        blocked.className='muted-box';
        blocked.textContent=vaultBlockedMessage;
        dom.stashActions.appendChild(blocked);
        return;
      }
      const upgradesHeading=document.createElement('div');
      upgradesHeading.className='command-title';
      upgradesHeading.textContent='Safehouse upgrades';
      dom.stashActions.appendChild(upgradesHeading);
      const upgradesHint=document.createElement('div');
      upgradesHint.className='small';
      upgradesHint.textContent='Invest scrap and credits to expand storage capacity.';
      dom.stashActions.appendChild(upgradesHint);
      const upgradeCost=getStashUpgradeCost();
      const upgradeCard=document.createElement('div');
      upgradeCard.className='op-card';
      const upgradeTitle=document.createElement('div');
      upgradeTitle.innerHTML='<b>Safehouse storage</b>';
      const upgradeMeta=document.createElement('div');
      upgradeMeta.className='op-meta';
      upgradeMeta.textContent=`Increase vault capacity by ${STASH_UPGRADE_STEP} slots.`;
      const upgradeCostLine=document.createElement('div');
      upgradeCostLine.className='op-meta';
      upgradeCostLine.textContent=`Cost: ${formatCost(upgradeCost)} · Current capacity ${state.stashLimit}.`;
      const upgradeActions=document.createElement('div');
      upgradeActions.className='op-actions';
      const upgradeBtn=document.createElement('button');
      upgradeBtn.textContent=`Upgrade storage (+${STASH_UPGRADE_STEP})`;
      upgradeBtn.onclick=upgradeStash;
      if(!vaultAccess){
        upgradeBtn.disabled=true;
        upgradeBtn.title=vaultBlockedMessage;
      }else if(!canAfford(upgradeCost)){
        upgradeBtn.disabled=true;
        upgradeBtn.title='Need more credits or scrap.';
      }
      upgradeActions.appendChild(upgradeBtn);
      upgradeCard.appendChild(upgradeTitle);
      upgradeCard.appendChild(upgradeMeta);
      upgradeCard.appendChild(upgradeCostLine);
      upgradeCard.appendChild(upgradeActions);
      dom.stashActions.appendChild(upgradeCard);
      const bulk=document.createElement('div');
      bulk.className='inventory inline-actions';
      const sellAll=document.createElement('button');
      sellAll.textContent='Sell all stash';
      sellAll.onclick=bulkSellStash;
      if(!vaultAccess){
        sellAll.disabled=true;
        sellAll.title=vaultBlockedMessage;
      }else if(!canAccessMarket()){
        sellAll.disabled=true;
        sellAll.title='Visit a shop to sell.';
      }
      const scrapAll=document.createElement('button');
      scrapAll.textContent='Break down all stash';
      scrapAll.onclick=bulkScrapStash;
      if(!vaultAccess){
        scrapAll.disabled=true;
        scrapAll.title=vaultBlockedMessage;
      }
      bulk.appendChild(sellAll);
      bulk.appendChild(scrapAll);
      dom.stashActions.appendChild(bulk);
      renderMarketStock();
    }

    /* ================= GAMEPLAY ================= */
    function computeFailChance(risk){
      const base=riskTable[risk] ?? 0.12;
      const gearMods=getGearMods();
      const radsPenalty=Math.min(0.08,state.rads*0.004);
      const hungerPenalty=state.hunger>70?0.05:0;
      const thirstPenalty=state.thirst>70?0.05:0;
      const fatiguePenalty=state.stamina<30?0.04:0;
      const energyPenalty=state.energy<25?0.06:0;
      const tempPenalty=state.bodyTemp<94?0.07:(state.bodyTemp>102?0.05:0);
      const total=base + hungerPenalty + thirstPenalty + fatiguePenalty + energyPenalty + radsPenalty + tempPenalty - (gearMods.riskMod||0);
      return clamp(total,0.05,0.75);
    }

    function tickTime(minutes){
      const total=state.timeMinutes+formatDisplayMinutes(minutes);
      if(total>=24*60){
        state.timeMinutes=total%(24*60);
        advanceDay();
      }else{
        state.timeMinutes=total;
      }
      updateRadShield();
    }

    function advanceDay(){
      state.day++;
      state.timeMinutes=6*60;
    }

    function rollComplication(source){
      const tension=computeFailChance(state.zone.risk) * 0.55;
      if(Math.random()>tension) return;
      const complications=[
        {desc:'A cold gust slips through your seals.',effects:'temp-2,stamina-2'},
        {desc:'An unseen stalker snatches some scrap.',effects:'scrap-2,temp-1'},
        {desc:'Hunger cramps slow you down.',effects:'stamina-6,hp-3'},
        {desc:'Static surge fries a component.',effects:'credits-6,temp-1'}
      ];
      if(state.rads>RAD_DANGER_THRESHOLD){
        complications.push({desc:'Radiation spike makes your skin crawl.',effects:'rads+1,hp-2'});
      }
      const hit=complications[Math.floor(Math.random()*complications.length)];
      applyEffects(hit.effects,'fail',{damageSource:hit.desc});
      logMsg(`Complication (${source}): ${hit.desc}`);
    }

    function handlePlayerCollapse(){
      logMsg('Emergency evac: you collapse and lose momentum.');
      const creditLoss=Math.ceil(state.credits*0.1);
      if(creditLoss>0){
        state.credits=Math.max(0,state.credits-creditLoss);
        logMsg(`Emergency evac fee deducted: ${creditLoss} credits.`);
      }
      state.hp=clamp(Math.round(state.maxHp*0.6),1,state.maxHp);
      state.hunger=clamp(0,0,state.maxHunger);
      state.thirst=clamp(0,0,state.maxThirst);
      const nowMinutes=getTotalMinutes();
      state.lastHungerDamageAt=nowMinutes;
      state.lastThirstDamageAt=nowMinutes;
      resetMissionState();
      state.travel={active:false,endsAt:null,target:null};
      clearMarketAccess();
      state.zone=getMainHubZone();
      state.selected={source:null,item:null};
      setActiveTab('hub');
      state.screen='main';
    }

    function applyEffects(effectStr,outcome,options={}){
      if(!effectStr) return;
      updateRadShield();
      const deferItemsTo=Array.isArray(options.deferItemsTo) ? options.deferItemsTo : null;
      let hpLoss=0;
      let sawLog=false;
      effectStr.split(',').forEach(token=>{
        token=token.trim(); if(!token) return;
        if(token.startsWith('item:')){
          const item=token.slice(5).trim();
          if(deferItemsTo){
            deferItemsTo.push(item);
          }else{
            const routed=routeItemGain(item);
            if(routed==='lost'){
              logMsg(`${item} lost: no storage space available.`);
            }
          }
          return;
        }
        if(token.startsWith('flag:')){
          const flag=token.slice(5);
          state.flags.add(flag);
          if(flag==='ganglands-telecom'){
            syncIdleSlots();
          }
          return;
        }
        if(token.startsWith('note:')){ setCodex(token.slice(5)); return; }
        if(token.startsWith('log:')){ sawLog=true; logMsg(token.slice(4)); return; }
        const radPercentMatch=token.match(/^rads([+-]\d+)%$/i);
        if(radPercentMatch){
          const percent=Number(radPercentMatch[1]);
          const delta=Math.round(state.rads*(percent/100));
          state.rads=Math.max(0,state.rads+delta);
          return;
        }
        const radShieldMatch=token.match(/^radshield([+-]\d+)/i);
        if(radShieldMatch){
          const percent=Number(radShieldMatch[1]);
          state.radShield=clamp(percent/100,0,0.75);
          state.radShieldUntil=getTotalMinutes()+RAD_SHIELD_DURATION_MINUTES;
          return;
        }
        const match=token.match(/([a-zA-Z]+)([+-]\d+)/);
        if(match){
          const stat=match[1]; const delta=Number(match[2]);
          if(stat==='hp'){
            if(delta<0) hpLoss+=delta;
            state.hp=clamp(state.hp+delta,0,state.maxHp);
          }
          else if(stat==='stamina') state.stamina=clamp(state.stamina+delta,0,state.maxStamina);
          else if(stat==='morale') state.morale=clamp(state.morale+delta,0,state.maxMorale);
          else if(stat==='hunger') state.hunger=clamp(state.hunger+delta,0,state.maxHunger);
          else if(stat==='thirst') state.thirst=clamp(state.thirst+delta,0,state.maxThirst);
          else if(stat==='rads'){
            const shield=delta>0 ? updateRadShield() : 0;
            const adjusted=delta>0 ? Math.max(0,Math.round(delta*(1-shield))) : delta;
            state.rads=Math.max(0,state.rads+adjusted);
          }
          else if(stat==='credits') state.credits=Math.max(0,state.credits+delta);
          else if(stat==='scrap') state.scrap=Math.max(0,state.scrap+delta);
          else if(stat==='energy') state.energy=clamp(state.energy+delta,0,state.maxEnergy);
          else if(stat==='keys') state.keys=Math.max(0,state.keys+delta);
          else if(stat==='temp') state.bodyTemp=clamp(state.bodyTemp+delta,BODY_TEMP_MIN,BODY_TEMP_MAX);
          else if(stat==='backpack') state.backpackLimit=Math.max(0,state.backpackLimit+delta);
        }
      });
      if(hpLoss<0 && !sawLog){
        const reason=options.damageSource ? options.damageSource : 'Damage taken';
        logMsg(`Signal log: ${reason} (-${Math.abs(hpLoss)} HP).`);
      }
      if(outcome==='fail' && state.hp<=0){
        handlePlayerCollapse();
      }
    }
    function runRaidInstant(raid,location,options={}){
      tickTime(raid.time);
      const gearMods=getGearMods();
      state.hunger=clamp(state.hunger+2,0,state.maxHunger);
      state.thirst=clamp(state.thirst+2,0,state.maxThirst);
      state.stamina=clamp(state.stamina-6+(gearMods.staminaBonus||0),0,state.maxStamina);
      const deferItemsTo=Array.isArray(options.deferItemsTo) ? options.deferItemsTo : null;
      const rewards=[];

      const locationRisk=location?.risk || state.zone.risk;
      const effectiveRisk=(riskRank[raid.risk] >= riskRank[locationRisk]) ? raid.risk : locationRisk;
      const failChance=computeFailChance(effectiveRisk);
      const roll=Math.random();
      const success=roll>failChance;
      state.bodyTemp=clamp(state.bodyTemp-1.1,BODY_TEMP_MIN,BODY_TEMP_MAX);
      if(success){
        const lootBonus=gearMods.lootBonus || 0;
        const pulls=Math.max(1,raid.loot+(Math.random()<0.35?1:0));
        for(let i=0;i<pulls;i++){
          const drop=rollLootDrop(effectiveRisk,lootBonus);
          addItemCopies(rewards,drop.id,drop.count);
        }
        if(location?.id==='abandoned_mall' && state.flags.has('mall-power')){
          const bonusFood=['ration bar','field rations','ember ration','water canister'];
          const bonus=bonusFood[Math.floor(Math.random()*bonusFood.length)];
          addItemCopies(rewards,bonus,1);
        }
        if(deferItemsTo){
          deferItemsTo.push(...rewards);
        }else{
          rewards.forEach(item=>{
            const routed=routeItemGain(item);
            if(routed==='lost'){
              logMsg(`${item} lost: no storage space available.`);
            }
          });
        }
        logMsg(`✓ ${raid.label} succeeded. Rewards secured.`);
      }else{
        applyEffects('hp-6,morale-4,temp-2','fail',{damageSource:`${raid.label} setback`});
        rollComplication('raid');
        logMsg(`✖ ${raid.label} failed. You limp back empty-handed.`);
      }
      return {success,rewards,effectiveRisk};
    }

    const getRiskIndex=(risk)=>riskRank[risk] || riskRank.low;
    const MIN_MISSION_SECONDS=4;
    const MAX_MISSION_SECONDS=30;
    const computeMissionDurationSeconds=({risk='low',time=8,loot=0}={})=>{
      const riskIdx=getRiskIndex(risk);
      const timeWeight=Math.max(1,time*0.45);
      const lootWeight=loot ? loot*1.4 : 0;
      const base=4+((riskIdx-1)*4)+timeWeight+lootWeight;
      return clamp(Math.round(base),MIN_MISSION_SECONDS,MAX_MISSION_SECONDS);
    };
    const computeMissionDurationMs=(params)=>computeMissionDurationSeconds(params)*1000;
    const computeMissionXp=(risk,time)=>{
      const riskIdx=getRiskIndex(risk);
      return Math.max(12,Math.round(18+(riskIdx*12)+(time*1.6)));
    };
    const computeCombatChance=(risk)=>{
      const riskIdx=getRiskIndex(risk);
      return clamp(0.12+(riskIdx*0.08),0.12,0.55);
    };
    function getCombatProfile(risk){
      const riskIdx=getRiskIndex(risk);
      return {
        id:`combat-${Date.now()}`,
        label:`Hostile contact (${risk})`,
        risk,
        time:Math.max(6,8+riskIdx*2),
        enemyName:['Scavenger pack','Rogue drone','Ambush crew','Rad-stalker'][riskIdx-1] || 'Hostiles',
        difficulty:1+(riskIdx*0.55)
      };
    }
    function shouldTriggerCombat(risk){
      const chance=computeCombatChance(risk);
      return Math.random()<chance;
    }
    function preparePendingResolution(pending,rewards){
      const pendingRewards=rewards || [];
      state.mission.pendingResolution={...pending,rewards:pendingRewards};
    }
    function launchCombatFromPending(pending){
      const combatProfile=getCombatProfile(pending.risk);
      const combatState=initCombatState(combatProfile);
      const now=Date.now();
      const estimatedMs=clamp(combatState.expectedRounds*COMBAT_ROUND_MS,MIN_MISSION_SECONDS*1000,MAX_MISSION_SECONDS*1000);
      state.mission={
        ...state.mission,
        type:'combat',
        raid:combatProfile,
        startedAt:now,
        endsAt:now+estimatedMs,
        completed:false,
        success:null,
        summary:`Combat engaged: ${combatProfile.enemyName}. ${describeCombatState(combatState)}`,
        rewards:[],
        statusMessage:`Combat engaged: ${combatProfile.enemyName}. ${describeCombatState(combatState)}`,
        fleeing:false,
        fleeEndsAt:null,
        xpReward:computeMissionXp(combatProfile.risk,combatProfile.time),
        rewardEffects:{success:'',fail:''},
        combat:combatState,
        sceneTarget:null
      };
      setCodex('Hostile contact! Hold out or flee.');
      logMsg(`Combat encounter triggered by ${pending.label}. ${describeCombatState(combatState)}`);
      setScreen('mission');
      normalizeMissionTiming(Date.now());
      renderAll();
    }
    function resolvePendingMission(outcomeOverride){
      const pending=state.mission.pendingResolution;
      if(!pending) return;
      const rewards=pending.rewards || [];
      const outcome=outcomeOverride || (pending.success ? 'success' : 'fail');
      const effects=outcome==='success' ? pending.successEffects : pending.failEffects;
      if(effects){
        if(outcome==='success') applyEffects(effects,outcome,{deferItemsTo:rewards});
        else applyEffects(effects,outcome);
      }
      if(outcome==='success' && pending.xpReward){
        awardXp(pending.xpReward,pending.label);
      }
      if(outcome==='success' && pending.flag && pending.once){
        state.flags.add(pending.flag);
        if(pending.flag==='ganglands-telecom'){
          syncIdleSlots();
        }
      }
      state.mission.completed=true;
      state.mission.success=outcome==='success';
      state.mission.rewards=rewards;
      state.mission.summary=outcome==='success'
        ? 'Extraction secured. Review rewards before closing the mission.'
        : 'Extraction rough. Patch up before you re-deploy.';
      state.mission.statusMessage=outcome==='success'
        ? `Mission complete: ${pending.label}. Rewards ready.`
        : `Mission failed: ${pending.label}.`;
      state.mission.pendingResolution=null;
      setCodex(outcome==='success' ? 'Mission complete. Rewards ready to review.' : 'Mission failed. Recover and try again.');
      if(outcome==='success' && pending.sourceId===ELDER_MISSION_ID){
        const reward=grantElderAdvice();
        if(reward?.advice){
          setCodex(`Elder advice: ${reward.advice}`);
        }
        if(reward?.exhausted){
          setCodex("You're very wise, young one.");
        }
      }
      setActiveTab('hub');
      state.screen='mission';
      state.selected={source:null,item:null};
      renderAll();
    }
    const COMBAT_ROUND_MS=1200;
    const COMBAT_CONSUME_MS=3000;
    const combatVariance=(base,spread)=>Math.max(1,Math.round(base*(1-spread)+(Math.random()*base*spread*2)));
    const describeCombatState=(combat)=>`Enemy HP ${Math.max(0,Math.round(combat.enemyHp))}/${Math.round(combat.enemyMaxHp)} · Enemies left ${combat.enemiesRemaining}/${combat.totalEnemies}`;
    function initCombatState(profile){
      const gearMods=getGearMods();
      const riskIdx=getRiskIndex(profile.risk);
      const totalEnemies=Math.max(1,1+Math.max(0,riskIdx-1));
      const playerDamage=Math.max(6,Math.round(8+(state.level*1.8)+((gearMods.combatBonus||0)*1.4)+((gearMods.staminaBonus||0)*0.6)));
      const enemyDamage=Math.max(2,Math.round((3+(riskIdx*2.6))-(playerDamage*0.12)-((gearMods.riskMod||0)*18)));
      const enemyMaxHp=Math.max(28,Math.round(26+(riskIdx*12)+(profile.difficulty*8)));
      const totalEnemyHp=enemyMaxHp*totalEnemies;
      const expectedRounds=Math.max(4,Math.ceil(totalEnemyHp/Math.max(8,playerDamage*0.9)));
      return {
        riskIdx,
        enemyMaxHp,
        enemyHp:enemyMaxHp,
        totalEnemies,
        enemiesRemaining:totalEnemies,
        playerDamage,
        enemyDamage,
        round:0,
        totalDamageTaken:0,
        totalDamageDealt:0,
        nextTickAt:Date.now()+COMBAT_ROUND_MS,
        consumable:null,
        expectedRounds
      };
    }
    function runCombatEncounter(profile,{success,fleeing=false}={}){
      const gearMods=getGearMods();
      const combat=state.mission.combat || initCombatState(profile);
      const rewards=[];
      let credited=0;
      if(success){
        const lootPulls=2+Math.floor(profile.difficulty);
        for(let i=0;i<lootPulls;i++){
          const drop=rollLootDrop(profile.risk,gearMods.lootBonus||0);
          addItemCopies(rewards,drop.id,drop.count);
        }
        credited=Math.max(6,Math.round((profile.difficulty*12)+(Math.random()*10)));
        state.credits+=credited;
        const xpBase=computeMissionXp(profile.risk,profile.time);
        awardXp(xpBase,profile.enemyName);
      }
      const summary=success
        ? `Hostiles down. You dealt ${Math.round(combat.totalDamageDealt)} and took ${Math.round(combat.totalDamageTaken)} damage. ${credited} credits recovered.`
        : fleeing
          ? `You flee under fire after taking ${Math.round(combat.totalDamageTaken)} damage. No rewards recovered.`
          : `You are overrun after taking ${Math.round(combat.totalDamageTaken)} damage and pull back to survive. No rewards recovered.`;
      return {success,rewards,summary};
    }
    function applyCombatConsumable(item){
      if(!state.mission.active || state.mission.type!=='combat' || state.mission.completed) return;
      const combat=state.mission.combat;
      if(!combat) return;
      if(combat.consumable){
        setCodex(`Already applying ${combat.consumable.item}.`);
        return;
      }
      if(!state.inventory.includes(item)){
        setCodex('Consumable not found in backpack.');
        return;
      }
      const data=getItem(item);
      if(data.type!=='consumable'){
        setCodex('Only consumables can be used mid-combat.');
        return;
      }
      combat.consumable={item,readyAt:Date.now()+COMBAT_CONSUME_MS};
      state.mission.statusMessage=`Applying ${item}… 3s channel.`;
      renderMissionStatus();
    }
    function resolveCombatRound(){
      const combat=state.mission.combat;
      if(!combat) return;
      combat.round+=1;
      let roundLog='';
      if(!state.mission.fleeing){
        const dealt=combatVariance(combat.playerDamage,0.22);
        combat.enemyHp-=dealt;
        combat.totalDamageDealt+=dealt;
        roundLog=`You hit for ${dealt}.`;
        if(combat.enemyHp<=0){
          combat.enemiesRemaining-=1;
          roundLog+=` Target down.`;
          if(combat.enemiesRemaining>0){
            const nextHp=Math.round(combat.enemyMaxHp*(1+combat.riskIdx*0.04));
            combat.enemyMaxHp=nextHp;
            combat.enemyHp=nextHp;
            roundLog+=` ${combat.enemiesRemaining} hostiles remain.`;
          }
        }
      }else{
        roundLog='You focus on disengaging.';
      }
      const incoming=combatVariance(combat.enemyDamage,0.18);
      combat.totalDamageTaken+=incoming;
      state.hp=clamp(state.hp-incoming,0,state.maxHp);
      const staminaHit=Math.max(2,Math.round(incoming*0.6));
      state.stamina=clamp(state.stamina-staminaHit,0,state.maxStamina);
      roundLog+=` Incoming fire deals ${incoming}.`;
      const moraleHit=Math.max(1,Math.round(incoming*0.18));
      state.morale=clamp(state.morale-moraleHit,0,state.maxMorale);
      state.mission.statusMessage=`${roundLog} ${describeCombatState(combat)}`;
      logMsg(state.mission.statusMessage);
    }
    function combatTick(now){
      if(!state.mission.active || state.mission.type!=='combat' || state.mission.completed) return;
      const combat=state.mission.combat;
      if(!combat) return;
      if(combat.consumable && now>=combat.consumable.readyAt){
        const {item}=combat.consumable;
        const data=getItem(item);
        if(data.effect) applyEffects(data.effect,'success');
        removeItem(state.inventory,item);
        combat.consumable=null;
        state.selected={source:null,item:null};
        state.mission.statusMessage=`${item} applied. ${describeCombatState(combat)}`;
        logMsg(state.mission.statusMessage);
      }
      if(now<combat.nextTickAt) return;
      combat.nextTickAt=now+COMBAT_ROUND_MS;
      resolveCombatRound();
      if(combat.enemiesRemaining<=0){
        state.mission.endsAt=now;
        completeMission({combatResolved:true});
      }else if(state.hp<=0){
        state.mission.endsAt=now;
        completeMission({combatResolved:true,forcedFail:true});
      }
    }

    function attemptFlee(){
      if(!state.mission.active || state.mission.type!=='combat' || state.mission.completed) return;
      if(state.mission.fleeing) return;
      state.mission.fleeing=true;
      state.mission.fleeEndsAt=Date.now()+5000;
      state.mission.endsAt=state.mission.fleeEndsAt;
      state.mission.statusMessage=`Attempting to flee… hold for 5 seconds. ${describeCombatState(state.mission.combat)}`;
      logMsg('Escape attempt initiated. Incoming fire continues during the retreat.');
      renderMissionStatus();
    }
    function startCombatMission(){
      if(state.mission.active){
        setCodex('Mission already underway.');
        return;
      }
      if(state.travel.active){
        setCodex('Finish travel before engaging hostiles.');
        return;
      }
      if(isHubZone(state.zone)){
        setCodex('Hub zones are secure. Travel to a field site to engage hostiles.');
        return;
      }
      startLoops();
      const profile=getCombatProfile(state.zone.risk);
      const cost={energy:10};
      if(!canAfford(cost)){
        setCodex('Not enough energy to pick a fight.');
        return;
      }
      applyCost(cost);
      const combatState=initCombatState(profile);
      const now=Date.now();
      const estimatedMs=clamp(combatState.expectedRounds*COMBAT_ROUND_MS,MIN_MISSION_SECONDS*1000,MAX_MISSION_SECONDS*1000);
      state.mission={
        active:true,
        type:'combat',
        raid:profile,
        startedAt:now,
        endsAt:now+estimatedMs,
        completed:false,
        success:null,
        summary:`Combat engaged: ${profile.enemyName}. ${describeCombatState(combatState)}`,
        rewards:[],
        statusMessage:`Combat engaged: ${profile.enemyName}. ${describeCombatState(combatState)}`,
        location:{...state.zone},
        fleeing:false,
        fleeEndsAt:null,
        pendingResolution:null,
        xpReward:computeMissionXp(profile.risk,profile.time),
        rewardEffects:{success:'',fail:''},
        questMeta:null,
        combat:combatState,
        sceneTarget:null
      };
      setCodex('You move to engage hostile contacts.');
      logMsg(`Combat sortie launched against ${profile.enemyName}. ${describeCombatState(combatState)}`);
      setActiveTab('hub');
      setScreen('mission');
      normalizeMissionTiming(Date.now());
      renderAll();
    }
    function runQuest(quest){
      if(state.mission.active || state.travel.active){
        setCodex('Finish current operations before starting a contract.');
        return;
      }
      const questFlag=quest.flag || quest.id;
      if(quest.once && questFlag && state.flags.has(questFlag)){
        setCodex('That contract has already been completed.');
        return;
      }
      const energyCost=quest.energy ?? 12;
      const raidLike={
        id:quest.id,
        label:quest.title || 'Special contract',
        desc:quest.desc,
        time:quest.time || 10,
        energy:energyCost,
        loot:Math.max(2,Math.round((quest.time||10)/5)),
        risk:quest.risk || state.zone.risk,
        key:quest.key||0
      };
      const cost={energy:raidLike.energy,keys:raidLike.key||0};
      if(!canAfford(cost)){
        setCodex('Not enough resources for that contract.');
        return;
      }
      startLoops();
      applyCost(cost);
      const now=Date.now();
      const durationMs=computeMissionDurationMs({risk:raidLike.risk,time:raidLike.time,loot:raidLike.loot});
      state.mission={
        active:true,
        type:'contract',
        raid:raidLike,
        startedAt:now,
        endsAt:now+durationMs,
        completed:false,
        success:null,
        summary:'',
        rewards:[],
        statusMessage:`Contract launched: ${raidLike.label}.`,
        location:{...state.zone},
        fleeing:false,
        fleeEndsAt:null,
        pendingResolution:null,
        xpReward:computeMissionXp(raidLike.risk,raidLike.time),
        rewardEffects:{success:quest.success||'',fail:quest.fail||''},
        questMeta:{flag:questFlag,once:quest.once,forceCombat:quest.combat,combatChance:quest.combatChance},
        combat:null,
        sceneTarget:null
      };
      setCodex(`Contract launched: ${raidLike.label}.`);
      logMsg(`Contract deployed: ${raidLike.label} (${formatDisplayMinutes(raidLike.time)} min op).`);
      setActiveTab('hub');
      setScreen('mission');
      normalizeMissionTiming(Date.now());
      renderAll();
    }

    function resetMissionState(){
      state.mission={active:false,type:null,raid:null,startedAt:null,endsAt:null,completed:false,success:null,summary:'',rewards:[],statusMessage:'',location:null,fleeing:false,fleeEndsAt:null,pendingResolution:null,xpReward:0,rewardEffects:{success:'',fail:''},questMeta:null,combat:null,sceneTarget:null};
    }
    function closeMission({auto=false}={}){
      const lastLocation=state.mission.location ? {...state.mission.location} : null;
      const shouldRestoreLocation=lastLocation && lastLocation.id !== state.zone.id;
      resetMissionState();
      state.selected={source:null,item:null};
      if(shouldRestoreLocation){
        state.zone=lastLocation;
        clearMarketAccess();
      }
      setCodex(auto ? 'All rewards routed. Returning to the locations hub.' : 'Mission closed. Returning to the locations hub.');
      setActiveTab('hub');
      if(lastLocation){
        setScreen('locations');
      }else{
        setScreen('main');
      }
    }

    function applyCombatFailurePenalty(){
      state.hp=clamp(50,0,state.maxHp);
      state.hunger=clamp(15,0,state.maxHunger);
      state.thirst=clamp(15,0,state.maxThirst);
      state.credits=Math.max(0,Math.round(state.credits*0.9));
    }

    function failCombatMission(){
      const lastLocation=state.mission.location ? {...state.mission.location} : null;
      const shouldRestoreLocation=lastLocation && lastLocation.id !== state.zone.id;
      resetMissionState();
      state.selected={source:null,item:null};
      if(shouldRestoreLocation){
        state.zone=lastLocation;
        clearMarketAccess();
      }
      setCodex('Combat failed. Mission aborted. Returning to the locations hub.');
      setActiveTab('hub');
      if(lastLocation){
        setScreen('locations');
      }else{
        setScreen('main');
      }
    }

    function startMission(raid){
      const cost={energy:raid.energy,keys:raid.key||0};
      if(state.mission.active){
        setCodex('Mission already underway.');
        return;
      }
      if(state.travel.active){
        setCodex('Finish travel before launching a mission.');
        return;
      }
      if(isHubZone(state.zone) && !isHubMission(raid)){
        setCodex('Cannot launch raids from a hub zone. Travel to a field site.');
        return;
      }
      if(isElderAdviceMission(raid) && isElderAdviceExhausted()){
        setCodex("You're very wise, young one.");
        return;
      }
      if(!canAfford(cost)){
        setCodex('Not enough resources for that raid.');
        return;
      }
      startLoops();
      applyCost(cost);
      const now=Date.now();
      const durationMs=computeMissionDurationMs({risk:raid.risk,time:raid.time,loot:raid.loot});
      state.mission={
        active:true,
        type:'raid',
        raid,
        startedAt:now,
        endsAt:now+durationMs,
        completed:false,
        success:null,
        summary:'',
        rewards:[],
        statusMessage:`Mission launched: ${raid.label}.`,
        location:{...state.zone},
        fleeing:false,
        fleeEndsAt:null,
        pendingResolution:null,
        xpReward:computeMissionXp(raid.risk,raid.time),
        rewardEffects:{success:'',fail:''},
        questMeta:null,
        combat:null,
        sceneTarget:null
      };
      setCodex(`Mission launched: ${raid.label}.`);
      logMsg(`Mission launched: ${raid.label} (${formatDisplayMinutes(raid.time)} min op).`);
      setActiveTab('hub');
      setScreen('mission');
      normalizeMissionTiming(Date.now());
      renderAll();
    }

    function completeMission({combatResolved=false,forcedFail=false}={}){
      if(!state.mission.active || state.mission.completed) return;
      const missionType=state.mission.type;
      const raid=state.mission.raid;
      if(missionType==='combat'){
        const combat=state.mission.combat;
        if(combat && !combatResolved && !state.mission.fleeing && state.hp>0 && combat.enemiesRemaining>0){
          combat.nextTickAt=Date.now();
          combatTick(Date.now());
          if(!state.mission.completed) return;
        }
        const defeated=!state.mission.fleeing && state.hp>0 && (combat?.enemiesRemaining||0)<=0;
        const success=forcedFail && !defeated ? false : defeated;
        const result=runCombatEncounter(raid,{success,fleeing:state.mission.fleeing});
        state.mission.completed=true;
        state.mission.success=result.success;
        state.mission.rewards=result.rewards;
        state.mission.summary=result.summary;
        state.mission.statusMessage=result.summary;
        if(!result.success || state.hp<=0){
          state.mission.success=false;
          state.mission.rewards=[];
          state.mission.summary='Combat failed. Mission aborted.';
          state.mission.statusMessage=state.mission.summary;
          if(state.mission.pendingResolution){
            state.mission.pendingResolution.rewards=[];
            resolvePendingMission('fail');
          }
          applyCombatFailurePenalty();
          failCombatMission();
          return;
        }
        if(state.mission.pendingResolution){
          const pendingRewards=state.mission.pendingResolution.rewards || [];
          pendingRewards.push(...result.rewards);
          state.mission.pendingResolution.rewards=pendingRewards;
          logMsg('Combat rewards secured. Continuing mission extraction.');
          resolvePendingMission('success');
          return;
        }
        setCodex('Combat resolved. Rewards ready to review.');
        setActiveTab('hub');
        state.screen='mission';
        renderAll();
        return;
      }

      if(missionType==='scene'){
        const rewards=[];
        const effectiveRisk=raid.risk || state.zone.risk;
        const failChance=computeFailChance(effectiveRisk);
        const success=Math.random()>failChance;
        const pending={
          label:raid.label,
          success,
          risk:effectiveRisk,
          xpReward:state.mission.xpReward,
          successEffects:state.mission.rewardEffects.success,
          failEffects:state.mission.rewardEffects.fail,
          flag:null,
          once:false
        };
        preparePendingResolution(pending,rewards);
        if(state.mission.sceneTarget){
          state.zone.sceneId=state.mission.sceneTarget;
        }
        resolvePendingMission(success ? 'success' : 'fail');
        return;
      }

      const rewards=[];
      const raidResult=runRaidInstant(raid,state.mission.location,{deferItemsTo:rewards});
      const success=raidResult.success;
      const effectiveRisk=raidResult.effectiveRisk || raid.risk;
      const pending={
        sourceId:raid.id,
        label:raid.label,
        success,
        risk:effectiveRisk,
        xpReward:state.mission.xpReward,
        successEffects:missionType==='contract' ? state.mission.rewardEffects.success : '',
        failEffects:missionType==='contract' ? state.mission.rewardEffects.fail : '',
        flag:missionType==='contract' ? state.mission.questMeta?.flag : null,
        once:missionType==='contract' ? state.mission.questMeta?.once : false
      };
      preparePendingResolution(pending,rewards);
      const combatChanceOverride=missionType==='contract'
        ? state.mission.questMeta?.combatChance
        : state.mission.raid?.combatChance;
      if(missionType==='contract' && state.mission.questMeta?.forceCombat){
        launchCombatFromPending(pending);
        return;
      }
      if(typeof combatChanceOverride==='number' && combatChanceOverride>=0){
        if(Math.random()<combatChanceOverride){
          launchCombatFromPending(pending);
          return;
        }
        resolvePendingMission(success ? 'success' : 'fail');
        return;
      }
      if(shouldTriggerCombat(effectiveRisk)){
        launchCombatFromPending(pending);
        return;
      }
      resolvePendingMission(success ? 'success' : 'fail');
    }

    function sellStashItem(item){
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      if(!canAccessMarket()){
        setCodex('Visit a shop to sell items.');
        return;
      }
      const data=getItem(item);
      removeItem(state.stash.items,item);
      state.credits+=data.value || 1;
      state.selected={source:null,item:null};
      renderAll();
    }
    function sellStashItemStack(item,count){
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      if(!canAccessMarket()){
        setCodex('Visit a shop to sell items.');
        return;
      }
      const available=getItemCount(state.stash.items,item);
      const sellCount=Math.min(count,available);
      if(sellCount<=0) return;
      const data=getItem(item);
      removeItems(state.stash.items,item,sellCount);
      state.credits+=(data.value || 1) * sellCount;
      state.selected={source:null,item:null};
      renderAll();
    }

    function scrapStashItem(item){
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      removeItem(state.stash.items,item);
      const breakdown=getBreakdownOutputs(item);
      applyBreakdownOutputs(breakdown,{preferred:'stash'});
      state.selected={source:null,item:null};
      renderAll();
    }

    function bulkSellStash(){
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      if(!canAccessMarket()){
        setCodex('Visit a shop to sell items.');
        return;
      }
      state.stash.items.forEach(item=>{
        const data=getItem(item);
        state.credits+=data.value || 1;
      });
      state.stash.items=[];
      state.selected={source:null,item:null};
      renderAll();
    }

    function bulkScrapStash(){
      if(!canAccessVault()){
        setCodex(vaultBlockedMessage);
        return;
      }
      const itemsToScrap=[...state.stash.items];
      state.stash.items=[];
      itemsToScrap.forEach(item=>{
        const breakdown=getBreakdownOutputs(item);
        applyBreakdownOutputs(breakdown,{preferred:'stash'});
      });
      state.selected={source:null,item:null};
      renderAll();
    }

    function runCamp(){
      tickTime(ACTION_TIMES.camp);
      const gearMods=getGearMods();
      state.stamina=clamp(state.stamina+14,0,state.maxStamina);
      state.hp=clamp(state.hp+4,0,state.maxHp);
      state.morale=clamp(state.morale+4+(gearMods.moraleBonus||0),0,state.maxMorale);
      state.energy=clamp(state.energy+18+(gearMods.energyRegen||0),0,state.maxEnergy);
      state.hunger=clamp(state.hunger+3,0,state.maxHunger);
      state.thirst=clamp(state.thirst+3,0,state.maxThirst);
      state.bodyTemp=moveToward(state.bodyTemp,NORMAL_BODY_TEMP,4);
      logMsg('You bunker down, warm up, and recover energy.');
      rollComplication('camp');
      renderAll();
    }

    /* ================= EXPANSION LOADING ================= */
    function ensureExpansionsLoaded(){
      const needsReload=expansionsAttempted===0 || (expansionsLoaded===0 && expansionsAttempted>=expansionsExpected);
      if(Object.keys(expansions).length>0 && !needsReload){
        renderDoors();
        return;
      }
      if(dom.doors) dom.doors.innerHTML='';
      loadGames();
    }

    async function loadGames(){
      let manifest=EXPANSION_MANIFEST;
      try{
        const res=await fetch('games.json',{cache:'no-store'});
        if(res.ok){
          const data=await res.json();
          if(Array.isArray(data.expansions) && data.expansions.length){
            manifest=data.expansions;
          }
        }
      }catch(err){
        console.warn('games.json unavailable, falling back to embedded manifest.',err);
      }
      expansionsExpected=manifest.length;
      expansionsLoaded=0;
      expansionsAttempted=0;
      if(dom.doors) dom.doors.innerHTML='';
      dom.doorsHint.textContent=manifest.length ? 'Loading expansions…' : 'No expansions configured.';
      manifest.forEach(meta=>loadExpansion(meta));
    }

    async function loadExpansion(meta){
      const embedded=EMBEDDED_EXPANSIONS[meta.id];
      try{
        const res=await fetch(meta.file,{cache:'no-store'});
        if(!res.ok){
          throw new Error(`Expansion fetch failed: ${meta.file}`);
        }
        const raw=await res.text();
        const expansion=parseExpansion(raw);
        expansion.meta.id=meta.id || expansion.meta.id;
        expansion.meta.name=meta.name || expansion.meta.name || meta.id;
        expansions[expansion.meta.id]=expansion;
        addDoor(expansion);
        expansionsLoaded+=1;
        dom.doorsHint.textContent='';
        logMsg(`Door bolted on: ${expansion.meta.name}`);
      }catch(err){
        if(embedded){
          const expansion=parseExpansion(embedded);
          expansion.meta.id=meta.id || expansion.meta.id;
          expansion.meta.name=meta.name || expansion.meta.name || meta.id;
          expansions[expansion.meta.id]=expansion;
          addDoor(expansion);
          expansionsLoaded+=1;
          dom.doorsHint.textContent='';
          logMsg(`Door bolted on: ${expansion.meta.name}`);
        }else{
          logMsg(`Failed to load ${meta.id}`);
          console.error(err);
        }
      }finally{
        expansionsAttempted+=1;
        if(expansionsLoaded===0 && expansionsAttempted>=expansionsExpected){
          dom.doorsHint.textContent='Unable to load expansions.';
        }
      }
    }

    function createDoorCard(exp){
      const card=document.createElement('div');
      const info=document.createElement('div');
      const actions=document.createElement('div');
      const travelBtn=document.createElement('button');
      const minLevel=Number(exp.meta?.minLevel || exp.meta?.minlevel || 0);
      const unlockCost=Number(exp.meta?.unlockCost || exp.meta?.unlockcost || 0);
      const unlockFlag=`unlock-${exp.meta.id}`;
      let isUnlocked=!unlockCost || state.flags.has(unlockFlag);
      const zoneRisk=getZoneRiskForExp(exp,exp.door?.risk || 'low');

      card.className='door-card';
      applyRiskClasses(card,zoneRisk);
      info.className='door-info';
      actions.className='door-actions';
      travelBtn.textContent='Set course';
      travelBtn.dataset.action='travel';

      const getHintText=()=>{
        if(minLevel && state.level<minLevel){
          return `Requires level ${minLevel}`;
        }
        return exp.door?.hint || 'Unknown contact';
      };
      const setDoorLabel=()=>{
        info.innerHTML=`
          <div class="door-title">${exp.door?.label || exp.meta.name}</div>
          <div class="door-meta">${getHintText()}</div>
        `;
      };

      const refreshLockState=()=>{
        const levelLocked=minLevel && state.level<minLevel;
        const locked=unlockCost && !isUnlocked;
        card.classList.toggle('locked',locked);
        travelBtn.dataset.locked=(locked || levelLocked) ? 'true' : 'false';
        travelBtn.disabled=locked || levelLocked;
        travelBtn.title=locked
          ? 'Unlock required'
          : levelLocked
            ? `Requires level ${minLevel}`
            : 'Plot a route to this location';
      };

      const unlockBtn=document.createElement('button');
      if(unlockCost && !isUnlocked){
        unlockBtn.textContent=`Unlock (${unlockCost} credits)`;
        unlockBtn.dataset.action='unlock';
        unlockBtn.onclick=()=>{
          if(state.credits<unlockCost){
            setCodex(`Need ${unlockCost} credits to unlock ${exp.meta.name}.`);
            return;
          }
          state.credits-=unlockCost;
          state.flags.add(unlockFlag);
          isUnlocked=true;
          logMsg(`${exp.meta.name} unlocked for ${unlockCost} credits.`);
          setCodex(`${exp.meta.name} unlocked. Transit cleared.`);
          if(unlockBtn.parentElement) unlockBtn.parentElement.removeChild(unlockBtn);
          refreshLockState();
          renderAll();
        };
        actions.appendChild(unlockBtn);
      }

      travelBtn.onclick=()=>{
        if(isMissionBlockingTravel()){
          setCodex('Mission in progress. Cannot change locations.');
          return;
        }
        if(isRewardBlockingTravel()){
          setCodex('Resolve mission rewards before changing locations.');
          return;
        }
        if(state.travel.active){
          setCodex('Already rerouting. Stand by.');
          return;
        }
        if(minLevel && state.level<minLevel){
          setCodex(`Access denied. Reach level ${minLevel} to enter ${exp.meta.name}.`);
          return;
        }
        if(unlockCost && !isUnlocked){
          setCodex(`Unlock ${exp.meta.name} to travel.`);
          return;
        }
        const targetScene=exp.door?.target || Object.keys(exp.scenes || {})[0] || null;
        const target={
          id:exp.meta.id,
          name:exp.meta.name,
          risk:zoneRisk,
          desc:exp.door?.desc || exp.door?.hint || 'Salvage zone marked by strange chatter.',
          sceneId:targetScene
        };
        state.travel={
          active:true,
          endsAt:Date.now(),
          target
        };
        state.doorsCollapsed=true;
        logMsg(`Routing to ${target.name}… hold tight.`);
        if(exp.door?.note) setCodex(exp.door.note);
        renderAll();
      };

      setDoorLabel();
      refreshLockState();
      actions.appendChild(travelBtn);
      card.appendChild(info);
      card.appendChild(actions);
      return card;
    }

    function renderDoorCurrent(){
      if(!dom.doorsCurrent) return;
      const exp=expansions[state.zone.id];
      const name=exp?.meta?.name || state.zone.name;
      const desc=exp?.door?.hint || exp?.meta?.summary || state.zone.desc;
      const risk=getZoneRiskForExp(exp || {},state.zone.risk);
      dom.doorsCurrent.innerHTML='';
      const card=document.createElement('div');
      const info=document.createElement('div');
      const tag=document.createElement('div');
      card.className='door-card door-current-card';
      applyRiskClasses(card,risk);
      info.className='door-info';
      info.innerHTML=`
        <div class="door-title">${name}</div>
        <div class="door-meta">${desc}</div>
      `;
      tag.className='door-current-tag';
      tag.textContent='Current location';
      card.appendChild(info);
      card.appendChild(tag);
      dom.doorsCurrent.appendChild(card);
    }

    function renderDoors(){
      if(!dom.doors) return;
      const list=getSortedDoors();
      const totalPages=Math.max(1,Math.ceil(list.length/DOORS_PAGE_SIZE));
      state.doorsPage=clamp(state.doorsPage,0,totalPages-1);
      const start=state.doorsPage*DOORS_PAGE_SIZE;
      const pageItems=list.slice(start,start+DOORS_PAGE_SIZE);
      dom.doors.innerHTML='';
      pageItems.forEach(exp=>dom.doors.appendChild(createDoorCard(exp)));

      if(dom.doorsPagination){
        dom.doorsPagination.innerHTML='';
        if(list.length>0 && totalPages>1){
          const prev=document.createElement('button');
          prev.textContent='Prev';
          prev.disabled=state.doorsPage===0;
          prev.onclick=()=>{
            state.doorsPage=clamp(state.doorsPage-1,0,totalPages-1);
            renderDoors();
          };
          const next=document.createElement('button');
          next.textContent='Next';
          next.disabled=state.doorsPage>=totalPages-1;
          next.onclick=()=>{
            state.doorsPage=clamp(state.doorsPage+1,0,totalPages-1);
            renderDoors();
          };
          const label=document.createElement('span');
          label.textContent=`Page ${state.doorsPage+1} / ${totalPages}`;
          dom.doorsPagination.appendChild(prev);
          dom.doorsPagination.appendChild(label);
          dom.doorsPagination.appendChild(next);
        }
      }

      if(dom.doorsHint){
        if(expansionsLoaded<expansionsExpected){
          dom.doorsHint.textContent='Loading expansions…';
        }else{
          dom.doorsHint.textContent=list.length ? '' : 'No expansions configured.';
        }
      }
      if(dom.doorsPanel){
        dom.doorsPanel.classList.toggle('is-collapsed',state.doorsCollapsed);
      }
      if(dom.doorsToggle){
        dom.doorsToggle.setAttribute('aria-expanded',state.doorsCollapsed ? 'false' : 'true');
      }
    }

    function addDoor(){
      renderDoors();
    }

    function parseOption(str){
      // Format: Label => target | risk:low | time:10 | success:hp+5,credits+10 | fail:hp-5 | rad:1 | temp:1
      const segments=str.split('|').map(s=>s.trim()).filter(Boolean);
      const [labelPart,...rest]=segments;
      const [label,target]=labelPart.split('=>').map(s=>s&&s.trim());
      const opt={label:label||'Action',target:target||null,risk:'low',time:8,success:'',fail:'',rad:0,temp:0,loot:0,lootType:'',reward:'',once:false,flag:''};
      rest.forEach(seg=>{
        const [k,vRaw]=seg.split(':');
        const v=vRaw?.trim();
        if(!k) return;
        const key=k.trim().toLowerCase();
        if(key==='risk') opt.risk=v;
        else if(key==='time') opt.time=Number(v||8);
        else if(key==='success') opt.success=v;
        else if(key==='fail') opt.fail=v;
        else if(key==='rad') opt.rad=Number(v||0);
        else if(key==='temp') opt.temp=Number(v||0);
        else if(key==='loot') opt.loot=Number(v||0);
        else if(key==='loottype') opt.lootType=v;
        else if(key==='reward') opt.reward=v;
        else if(key==='once') opt.once=v !== 'false';
        else if(key==='flag') opt.flag=v;
      });
      return opt;
    }

    function parseExpansion(raw){
      const exp={meta:{},door:{},scenes:{},quests:[],missions:[]};
      let scope='meta';
      let currentScene=null;
      let currentQuest=null;
      let currentMission=null;
      raw.split(/\r?\n/).forEach(line=>{
        line=line.trim();
        if(!line || line.startsWith('#')) return;
        if(line.startsWith('@expansion')){scope='meta';currentScene=null;currentQuest=null;currentMission=null;return;}
        if(line.startsWith('@door')){scope='door';currentScene=null;currentQuest=null;currentMission=null;return;}
        if(line.startsWith('@scene')){
          scope='scene';
          currentQuest=null;
          currentMission=null;
          const id=line.split(/\s+/)[1] || `scene-${Object.keys(exp.scenes).length+1}`;
          currentScene={id,title:'',desc:'',tags:'',options:[]};
          exp.scenes[id]=currentScene;return;
        }
        if(line.startsWith('@mission')){
          scope='mission';
          currentScene=null;
          currentQuest=null;
          currentMission={
            id:`mission-${exp.missions.length+1}`,
            label:'Field operation',
            desc:'',
            risk:'medium',
            time:10,
            energy:12,
            loot:2,
            key:0,
            lootType:'',
            reward:''
          };
          exp.missions.push(currentMission);
          return;
        }
        if(line.startsWith('@quest')){
          scope='quest';
          currentScene=null;
          currentMission=null;
          currentQuest={
            id:`quest-${exp.quests.length+1}`,
            title:'Special contract',
            desc:'',
            risk:'medium',
            time:10,
            success:'',
            fail:'',
            once:true,
            flag:''
          };
          exp.quests.push(currentQuest);
          return;
        }
        const [key,...rest]=line.split(':');
        const value=rest.join(':').trim();
        if(scope==='meta') exp.meta[key]=value;
        else if(scope==='door') exp.door[key]=value;
        else if(scope==='scene' && currentScene){
          if(key==='option') currentScene.options.push(parseOption(value));
          else if(key==='desc') currentScene.desc += (currentScene.desc?' ':'') + value;
          else currentScene[key]=value;
        }else if(scope==='quest' && currentQuest){
          if(key==='desc') currentQuest.desc += (currentQuest.desc?' ':'') + value;
          else if(['time','energy','loot','key'].includes(key)) currentQuest[key]=Number(value || 0);
          else if(key==='once') currentQuest.once=value !== 'false';
          else if(key==='combat') currentQuest.combat=value !== 'false';
          else if(key.toLowerCase()==='combatchance') currentQuest.combatChance=Number(value || 0);
          else if(key==='requires') currentQuest.requires=value;
          else currentQuest[key]=value;
        }else if(scope==='mission' && currentMission){
          if(key==='desc') currentMission.desc += (currentMission.desc?' ':'') + value;
          else if(['time','energy','loot','key'].includes(key)) currentMission[key]=Number(value || 0);
          else if(key.toLowerCase()==='combatchance') currentMission.combatChance=Number(value || 0);
          else currentMission[key]=value;
        }
      });
      return exp;
    }

    function renderAll(){
      renderPauseToggle();
      renderBars();
      renderInventory();
      renderCrafting();
      renderTravelStatus();
      renderMissionStatus();
      renderIdleOps();
      renderZone();
      renderDoorCurrent();
      renderDoors();
      renderRaidActions();
      renderStash();
      renderItemDetails();
      setInventoryScreen(state.inventoryScreen);
      setStashScreen(state.stashScreen);
      renderScreens();
      syncTabs();
      queueSave();
    }

    function hideIntroModal(){
      if(!dom.introModal) return;
      dom.introModal.classList.add('hidden');
    }

    function showIntroModal({returning=false}={}){
      if(!dom.introModal || !dom.introActions || !dom.introMessage || !dom.introTitle) return;
      dom.introActions.innerHTML='';
      if(returning){
        dom.introTitle.textContent='Welcome back, runner';
        dom.introMessage.textContent='Your autosave is ready. Continue from your last loop or start fresh.';
        const continueBtn=document.createElement('button');
        continueBtn.textContent='Continue autosave';
        continueBtn.onclick=()=>{
          const latestState=loadSavedState();
          if(latestState) state=latestState;
          allowAutosave=true;
          hideIntroModal();
          renderAll();
          queueSave({force:true});
        };
        const restartBtn=document.createElement('button');
        restartBtn.textContent='Start fresh';
        restartBtn.classList.add('danger');
        restartBtn.onclick=()=>{
          localStorage.removeItem(SAVE_KEY);
          state=createDefaultState();
          allowAutosave=true;
          renderAll();
          queueSave({force:true});
          hideIntroModal();
        };
        dom.introActions.appendChild(continueBtn);
        dom.introActions.appendChild(restartBtn);
      }else{
        dom.introTitle.textContent='Fight, loot, survive.';
        dom.introMessage.textContent='Start a fresh loop or purge storage to reset everything.';
        const startBtn=document.createElement('button');
        startBtn.textContent='Start fresh';
        startBtn.onclick=()=>{
          allowAutosave=true;
          queueSave({force:true});
          hideIntroModal();
        };
        const resetBtn=document.createElement('button');
        resetBtn.textContent='Clear saves';
        resetBtn.classList.add('danger');
        resetBtn.onclick=()=>{
          localStorage.removeItem(SAVE_KEY);
          state=createDefaultState();
          allowAutosave=true;
          renderAll();
          queueSave({force:true});
          hideIntroModal();
        };
        dom.introActions.appendChild(startBtn);
        dom.introActions.appendChild(resetBtn);
      }
      dom.introModal.classList.remove('hidden');
    }

    /* ================= INIT ================= */
    let loopsStarted=false;
    function startLoops(){
      if(loopsStarted) return;
      loopsStarted=true;
      setInterval(ambientTick,6500);
      setInterval(updateTimers,250);
      setInterval(saveGame,60000);
      window.addEventListener('beforeunload',saveGame);
    }

    function initGame(){
      renderAll();
      loadGames();
      showIntroModal({returning:Boolean(savedState)});
      startLoops();
    }

    if(document.readyState==='loading'){
      document.addEventListener('DOMContentLoaded',initGame);
    }else{
      initGame();
    }

    function normalizeMissionTiming(now){
      if(!state.mission.active || state.mission.completed) return;
      const startedAt=Number.isFinite(state.mission.startedAt) ? state.mission.startedAt : now;
      const fallbackDuration=computeMissionDurationMs({
        risk:state.mission.raid?.risk,
        time:state.mission.raid?.time,
        loot:state.mission.raid?.loot
      });
      const durationMs=Number.isFinite(fallbackDuration) ? fallbackDuration : (MIN_MISSION_SECONDS*1000);
      if(!Number.isFinite(state.mission.endsAt) || state.mission.endsAt<=startedAt){
        state.mission.startedAt=startedAt;
        state.mission.endsAt=startedAt+durationMs;
      }
      const maxDuration=MAX_MISSION_SECONDS*1000*MISSION_OVERRUN_MULTIPLIER;
      if(now-startedAt>maxDuration){
        state.mission.endsAt=now;
      }
    }

    function normalizeIdleTiming(now){
      syncIdleSlots();
      state.idleOps.forEach(slot=>{
        if(!slot.active) return;
        const startedAt=Number.isFinite(slot.startedAt) ? slot.startedAt : null;
        if(!Number.isFinite(startedAt)){
          slot.startedAt=now;
        }
        const durationMs=Number(slot.durationMs);
        if(!Number.isFinite(durationMs) || durationMs<=0){
          const op=idleOperations.find(entry=>entry.id===slot.id);
          if(op){
            const duration=getIdleDurationMinutes(op,getGearMods());
            slot.durationMs=duration*60000;
          }
        }
      });
    }

    function adjustTimersForPause(deltaMs){
      if(!Number.isFinite(deltaMs) || deltaMs<=0) return;
      if(state.mission.active && !state.mission.completed){
        if(Number.isFinite(state.mission.startedAt)) state.mission.startedAt+=deltaMs;
        if(Number.isFinite(state.mission.endsAt)) state.mission.endsAt+=deltaMs;
        if(Number.isFinite(state.mission.fleeEndsAt)) state.mission.fleeEndsAt+=deltaMs;
        const combat=state.mission.combat;
        if(combat){
          if(Number.isFinite(combat.nextTickAt)) combat.nextTickAt+=deltaMs;
          if(combat.consumable?.readyAt) combat.consumable.readyAt+=deltaMs;
        }
      }
      if(state.travel.active && Number.isFinite(state.travel.endsAt)) state.travel.endsAt+=deltaMs;
      state.idleOps.forEach(slot=>{
        if(slot.active && Number.isFinite(slot.startedAt)) slot.startedAt+=deltaMs;
      });
      if(Number.isFinite(state.radShieldUntil)) state.radShieldUntil+=deltaMs;
      if(Number.isFinite(state.lastHungerDamageAt)) state.lastHungerDamageAt+=deltaMs;
      if(Number.isFinite(state.lastThirstDamageAt)) state.lastThirstDamageAt+=deltaMs;
    }

    function updateTimers(){
      if(state.paused) return;
      if(resolveTravelIfComplete()){
        renderAll();
      }
      if(state.mission.active && !state.mission.completed){
        const now=Date.now();
        normalizeMissionTiming(now);
        if(state.mission.type==='combat'){
          combatTick(now);
          if(state.mission.fleeing && now>=state.mission.endsAt){
            completeMission({combatResolved:true});
          }else if(!state.mission.completed && !state.mission.fleeing && now>=state.mission.endsAt){
            completeMission({combatResolved:true,forcedFail:true});
          }
        }else if(now>=state.mission.endsAt){
          completeMission();
        }
      }
      if(state.mission.active && !state.mission.completed){
        renderMissionStatus();
      }
      if(state.travel.active){
        renderTravelStatus();
      }
      const hasActiveIdle=state.idleOps.some(slot=>slot.active);
      if(hasActiveIdle){
        const now=Date.now();
        normalizeIdleTiming(now);
        state.idleOps.forEach(slot=>{
          if(!slot.active) return;
          const elapsed=now-(slot.startedAt || now);
          if(elapsed>=slot.durationMs){
            completeIdleOp(slot);
          }
        });
        renderIdleOps();
      }
    }

    function ambientTick(){
      if(state.paused) return;
      tickTime(4);
      const idleNow=Date.now();
      if(state.idleOps.some(slot=>slot.active)){
        state.idleOps.forEach(slot=>{
          if(!slot.active) return;
          const elapsed=idleNow-(slot.startedAt || idleNow);
          if(elapsed>=slot.durationMs){
            completeIdleOp(slot);
          }
        });
      }
      const gearMods=getGearMods();
      state.energy=clamp(state.energy+4+(gearMods.energyRegen||0),0,state.maxEnergy);
      state.hunger=clamp(state.hunger+1,0,state.maxHunger);
      state.thirst=clamp(state.thirst+1,0,state.maxThirst);
      const inHub=state.screen==='main' || state.screen==='locations';
      if(inHub){
        state.bodyTemp=moveToward(state.bodyTemp,NORMAL_BODY_TEMP,1.6);
      }else{
        const insulation=gearMods.insulation || 0;
        const loss=Math.max(0.4,1.3-insulation);
        state.bodyTemp=clamp(state.bodyTemp-loss,BODY_TEMP_MIN,BODY_TEMP_MAX);
      }
      const nowMinutes=getTotalMinutes();
      const hungerDamageReady=state.hunger>NEED_DAMAGE_THRESHOLD
        && (!Number.isFinite(state.lastHungerDamageAt) || nowMinutes-state.lastHungerDamageAt>=NEED_DAMAGE_INTERVAL_MINUTES);
      if(hungerDamageReady){
        state.lastHungerDamageAt=nowMinutes;
        applyEffects('hp-2,morale-1','fail',{damageSource:'Hunger pangs'});
        logMsg('Hunger pangs slow you down.');
      }
      const thirstDamageReady=state.thirst>NEED_DAMAGE_THRESHOLD
        && (!Number.isFinite(state.lastThirstDamageAt) || nowMinutes-state.lastThirstDamageAt>=NEED_DAMAGE_INTERVAL_MINUTES);
      if(thirstDamageReady){
        state.lastThirstDamageAt=nowMinutes;
        applyEffects('hp-3,stamina-2','fail',{damageSource:'Dehydration strain'});
        logMsg('Dehydration blurs your vision.');
      }
      if(state.bodyTemp<=92){
        applyEffects('hp-2,stamina-3','fail',{damageSource:'Cold exposure'});
        if(state.timeMinutes%60===0){
          logMsg('Cold seeps into your limbs. Find shelter or warm up soon.');
        }
      }
      if(state.bodyTemp>=103){
        applyEffects('hp-2,morale-2','fail',{damageSource:'Heat exhaustion'});
        if(state.timeMinutes%60===0){
          logMsg('Heat haze clouds your focus. Cool down before it worsens.');
        }
      }
      rollComplication('idle time');
      renderAll();
    }

  </script>
</body>
</html>
