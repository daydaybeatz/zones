<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Zero Lux - Salvage Loop</title>
  <style>
    :root{
      color-scheme: dark;
      --bg:#0c0c0f;
      --panel:#121219;
      --panel-2:#191925;
      --accent:#5bd1ff;
      --accent-2:#8fffa3;
      --danger:#ff6b6b;
      --muted:#a7b0c0;
      --border:#202232;
      --shadow:0 10px 40px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box;}
    body{
      margin:0;min-height:100vh;background:radial-gradient(circle at 20% 20%, rgba(70,120,255,.08), transparent 35%),
      radial-gradient(circle at 80% 0%, rgba(80,255,200,.06), transparent 30%),
      var(--bg);
      color:#e8edf7;font-family:"Inter",system-ui,-apple-system,sans-serif;
      line-height:1.45;
      padding:12px;
    }
    #app{max-width:1200px;margin:auto;display:flex;flex-direction:column;gap:12px;}
    header{display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between;padding:14px 16px;background:var(--panel);border:1px solid var(--border);border-radius:12px;box-shadow:var(--shadow);position:sticky;top:0;z-index:3;backdrop-filter:blur(6px);}
    .title{font-size:20px;font-weight:700;letter-spacing:0.5px;display:flex;align-items:center;gap:8px;}
    .tagline{font-size:13px;color:var(--muted);}
    .pill{border:1px solid var(--border);border-radius:999px;padding:6px 10px;font-size:12px;color:var(--muted);background:rgba(255,255,255,0.02);}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:14px 16px;box-shadow:var(--shadow);}
    .panel h3{margin:0 0 6px;font-size:15px;letter-spacing:0.4px;}
    .grid-two{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:10px;}
    .statline{display:grid;grid-template-columns:110px 1fr 60px;align-items:center;font-size:13px;gap:8px;padding:6px 0;border-bottom:1px solid rgba(255,255,255,0.03);}    
    .bar{height:8px;background:#0f111a;border-radius:999px;overflow:hidden;border:1px solid #16182a;}
    .bar span{display:block;height:100%;border-radius:999px;}
    .bar.hp span{background:linear-gradient(90deg,#ff7a7a,#ffb36b);}    
    .bar.stamina span{background:linear-gradient(90deg,#71d2ff,#82ffa4);}    
    .bar.morale span{background:linear-gradient(90deg,#8aa9ff,#c3a1ff);}    
    .bar.rads span{background:linear-gradient(90deg,#80ffd3,#fffd8a);}    
    .bar.hunger span{background:linear-gradient(90deg,#ffc46a,#ff8c8c);}    
    .bar.thirst span{background:linear-gradient(90deg,#6ad8ff,#7f9cff);}    
    .bar.temp span{background:linear-gradient(90deg,#8fffa3,#5bd1ff);}    
    .rows{display:flex;flex-direction:column;gap:8px;}
    .meta{color:var(--muted);font-size:13px;display:flex;flex-wrap:wrap;gap:10px;}
    .meta b{color:#e8edf7;margin-right:4px;}
    .pill-inline{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;border:1px solid var(--border);background:rgba(255,255,255,0.03);font-size:12px;color:var(--muted);}    
    button{appearance:none;border:1px solid var(--border);background:var(--panel-2);color:#f6f7ff;border-radius:10px;padding:10px 12px;font-size:14px;text-align:left;cursor:pointer;transition:transform .05s ease, border .15s ease;display:flex;justify-content:space-between;align-items:center;gap:6px;min-height:46px;}
    button:hover{transform:translateY(-1px);border-color:var(--accent);}    
    button:active{transform:translateY(0);}
    .btn-secondary{background:#0f111a;}
    .danger{border-color:rgba(255,107,107,.6);color:#ffc2c2;}
    #doors,#raidActions{display:flex;flex-direction:column;gap:8px;}
    .log{white-space:pre-wrap;font-size:13px;color:#d8e1ff;line-height:1.35;max-height:320px;overflow:auto;padding:10px;background:#0f111a;border:1px solid var(--border);border-radius:12px;box-shadow:inset 0 0 0 1px rgba(255,255,255,0.02);}
    .small{font-size:12px;color:var(--muted);}
    .scene-title{font-size:17px;margin:0;color:#e8f1ff;}
    .scene-desc{margin:6px 0 10px;color:#cfd8ec;font-size:14px;}
    .badge{font-size:12px;border-radius:8px;padding:2px 8px;background:rgba(91,209,255,.08);border:1px solid rgba(91,209,255,.45);color:var(--accent-2);display:inline-flex;gap:6px;align-items:center;}
    .inline{display:flex;flex-wrap:wrap;gap:8px;align-items:center;}
    .inventory{display:flex;flex-wrap:wrap;gap:6px;margin-bottom:8px;}
    .inventory button{border:1px solid var(--border);padding:8px 10px;border-radius:10px;background:rgba(255,255,255,0.02);font-size:13px;cursor:pointer;}
    .inventory button:hover{border-color:var(--accent);}
    .inventory h4{margin:4px 0;font-size:13px;color:#cfd8ec;width:100%;}
    .inventory .pill-inline{margin-top:4px;}
    .inventory .inline-actions{width:100%;display:flex;flex-wrap:wrap;gap:6px;align-items:center;}
    .two-col{display:grid;grid-template-columns:1.1fr 1fr;gap:12px;}
    .tabs{background:var(--panel);border:1px solid var(--border);border-radius:12px;box-shadow:var(--shadow);}
    .tab-buttons{display:flex;gap:8px;padding:10px 12px;border-bottom:1px solid var(--border);flex-wrap:wrap;background:rgba(255,255,255,0.02);border-radius:12px 12px 0 0;}
    .tab-buttons button{flex:1 1 120px;text-align:center;justify-content:center;border-radius:10px;padding:10px 12px;border:1px solid var(--border);background:#0f111a;color:#e8edf7;min-height:40px;}
    .tab-buttons button.active{border-color:var(--accent);background:rgba(91,209,255,0.08);}
    .tab-buttons button:disabled{opacity:0.35;cursor:not-allowed;border-style:dashed;}
    .tab-content{display:none;padding:12px;}
    .tab-content.active{display:block;}
    .muted-box{padding:14px 16px;border-radius:10px;border:1px dashed var(--border);color:var(--muted);background:rgba(255,255,255,0.03);}
    .stack{display:flex;flex-direction:column;gap:12px;}
    .excursion-status{font-size:13px;color:var(--muted);display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
    .excursion-status b{color:#e8edf7;}
    .progress{height:10px;border-radius:999px;background:#0f111a;border:1px solid #1c1f32;overflow:hidden;}
    .progress span{display:block;height:100%;background:linear-gradient(90deg,#5bd1ff,#8fffa3);border-radius:999px;transition:width .2s ease;}
    .op-card{border:1px solid var(--border);border-radius:12px;padding:12px;background:rgba(255,255,255,0.02);display:flex;flex-direction:column;gap:8px;}
    .op-meta{display:flex;flex-wrap:wrap;gap:8px;color:var(--muted);font-size:12px;}
    .op-actions{display:flex;gap:8px;flex-wrap:wrap;}
    .screen-nav{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px;}
    .screen{display:none;flex-direction:column;gap:12px;}
    .screen.active{display:flex;}
    .spinner{width:18px;height:18px;border-radius:999px;border:2px solid rgba(255,255,255,0.2);border-top-color:var(--accent);animation:spin 0.8s linear infinite;}
    .spin-row{display:flex;align-items:center;gap:8px;font-size:13px;color:var(--muted);}
    .mission-card{display:flex;flex-direction:column;gap:10px;}
    .mission-title{font-size:16px;font-weight:600;}
    .mission-meta{font-size:13px;color:var(--muted);}
    .mission-actions{display:flex;gap:8px;flex-wrap:wrap;}
    @keyframes spin{to{transform:rotate(360deg);}}
    .item-grid{display:flex;flex-direction:column;gap:10px;}
    .item-row{display:flex;flex-wrap:wrap;align-items:center;gap:8px;padding:10px;border:1px solid var(--border);border-radius:10px;background:rgba(255,255,255,0.02);}
    .item-row.selectable{cursor:pointer;transition:border .15s ease,transform .05s ease;}
    .item-row.selectable:hover{border-color:var(--accent);transform:translateY(-1px);}
    .item-row.selected{border-color:var(--accent);box-shadow:0 0 0 1px rgba(91,209,255,0.3);}
    .item-name{font-weight:600;}
    .item-meta{font-size:12px;color:var(--muted);}
    .item-actions{display:flex;flex-wrap:wrap;gap:6px;margin-left:auto;}
    .chip{border:1px solid var(--border);border-radius:999px;padding:2px 8px;font-size:11px;color:var(--muted);}
    .chip.common{color:#cfd8ec;}
    .chip.uncommon{color:#8fffa3;}
    .chip.rare{color:#5bd1ff;}
    .chip.epic{color:#c3a1ff;}
    .chip.legendary{color:#ffcf6a;}
    .inventory-layout{display:grid;grid-template-columns:minmax(0,1.1fr) minmax(0,0.9fr);gap:12px;align-items:start;}
    .subtabs{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px;}
    .subtabs button{flex:1 1 120px;justify-content:center;text-align:center;min-height:38px;padding:8px 10px;background:#0f111a;}
    .subtabs button.active{border-color:var(--accent);background:rgba(91,209,255,0.08);}
    .subscreen{display:none;}
    .subscreen.active{display:block;}
    .command-card{border:1px solid var(--border);border-radius:12px;padding:12px;background:rgba(255,255,255,0.02);display:flex;flex-direction:column;gap:10px;}
    .command-title{font-size:15px;font-weight:600;}
    .stat-list{display:grid;grid-template-columns:120px 1fr;gap:6px;font-size:13px;color:var(--muted);}
    .stat-list span{color:#e8edf7;}
    .action-grid{display:flex;flex-wrap:wrap;gap:8px;}
    .command-hint{font-size:12px;color:var(--muted);}
    .status-toggle{display:flex;align-items:center;gap:10px;font-size:13px;color:var(--muted);}
    .status-toggle button{min-height:36px;padding:6px 10px;}
    @media(max-width:900px){header{position:static;} .two-col{grid-template-columns:1fr;} .tab-buttons button{flex:1 1 100%;}}
    @media(max-width:900px){.inventory-layout{grid-template-columns:1fr;}}
  </style>
</head>
<body>
  <div id="app">
    <header>
      <div>
        <div class="title">Zero Lux Salvage Loop <span class="pill">inventory / looter / idle</span></div>
        <div class="tagline">Pick zones, run salvage loops, and sort haul into gear, stash, or scrap.</div>
      </div>
      <div class="pill">Build #: 0.2b — inventory-focused loop</div>
    </header>

    <section class="panel">
      <div class="two-col">
        <div>
          <h3>Status Board</h3>
          <div id="stats"></div>
          <div class="meta" id="meta"></div>
        </div>
        <div class="rows">
          <div class="excursion-status" id="excursionStatus"></div>
          <div class="muted-box" id="tempoHint"></div>
        </div>
      </div>
    </section>

    <div class="tabs">
      <div class="tab-buttons">
        <button data-tab="hub" class="active">Operations</button>
        <button data-tab="inventory">Backpack</button>
        <button data-tab="field">Stash</button>
        <button data-tab="log">Ops Log</button>
      </div>
      <div id="tab-hub" class="tab-content active">
        <div class="stack">
          <div class="screen-nav" id="screenNav">
            <button data-screen="main" class="active">Main Hub</button>
            <button data-screen="locations">Locations Hub</button>
            <button data-screen="mission">In Mission</button>
          </div>
          <div id="screen-main" class="screen active">
            <section class="panel">
              <h3>Main Hub Deck</h3>
              <div class="rows">
                <div class="inline" style="justify-content:space-between;align-items:center;">
                  <div>
                    <p class="scene-title">Zero Lux Command Deck</p>
                    <p class="scene-desc">Synchronize with the field grid, then step into the locations hub to launch a raid.</p>
                  </div>
                  <span class="badge">Hub secure</span>
                </div>
                <div id="hubLock" class="muted-box"></div>
                <button id="enterLocations">Enter locations hub</button>
              </div>
            </section>
            <section class="panel">
              <h3>Incoming Haul</h3>
              <div class="inventory-layout">
                <div id="haul"></div>
                <div class="command-card">
                  <div class="command-title">Haul Command Card</div>
                  <div id="haulDetail" class="command-hint">Select loot to route it into your rig.</div>
                  <div class="action-grid" id="haulActions"></div>
                </div>
              </div>
            </section>
            <section class="panel">
              <h3>Idle Operations</h3>
              <div id="idleOps"></div>
            </section>
          </div>
          <div id="screen-locations" class="screen">
            <section class="panel">
              <h3>Transit Console</h3>
              <div class="spin-row" id="travelStatus"></div>
              <button class="btn-secondary" id="returnMain">Return to main hub</button>
            </section>
            <section class="panel">
              <h3>Zone Gates</h3>
              <div id="doors"></div>
              <div class="small" id="doorsHint">Loading expansions…</div>
            </section>
            <section class="panel">
              <div class="inline" style="justify-content:space-between;align-items:center;">
                <div>
                  <p class="scene-title" id="zoneTitle">Drift Yard</p>
                  <p class="scene-desc" id="zoneDesc">Low-risk salvage corridor. Ideal for stocking up on scrap and common gear.</p>
                </div>
                <span class="badge" id="zoneBadge">Low risk</span>
              </div>
              <div id="raidActions"></div>
            </section>
            <section class="panel">
              <h3>Special Contracts</h3>
              <div id="questBoard" class="item-grid"></div>
            </section>
          </div>
          <div id="screen-mission" class="screen">
            <section class="panel">
              <h3>Mission Feed</h3>
              <div class="mission-card">
                <div class="mission-title" id="missionTitle">No mission active.</div>
                <div class="mission-meta" id="missionMeta"></div>
                <div class="progress" id="missionProgress"><span style="width:0%;"></span></div>
                <div class="small" id="missionLog"></div>
                <div class="mission-actions" id="missionActions"></div>
              </div>
            </section>
          </div>
        </div>
      </div>
      <div id="tab-inventory" class="tab-content">
        <section class="panel">
          <h3>Backpack & Loadout</h3>
          <div class="subtabs" id="inventoryNav">
            <button data-inv-screen="backpack" class="active">Backpack</button>
            <button data-inv-screen="loadout">Loadout</button>
          </div>
          <div class="inventory-layout">
            <div>
              <div id="inventoryBackpack" class="subscreen active">
                <h4>Backpack Contents <span class="small" id="backpackCount"></span></h4>
                <div class="item-grid" id="inventory"></div>
              </div>
              <div id="inventoryLoadout" class="subscreen">
                <h4>Equipped Loadout <span class="small" id="loadoutCount"></span></h4>
                <div class="item-grid" id="equipment"></div>
              </div>
            </div>
            <div class="command-card">
              <div class="command-title">Loadout Command Card</div>
              <div id="itemDetail" class="command-hint">Select gear to view stats, uses, and actions.</div>
              <div class="action-grid" id="itemActions"></div>
            </div>
          </div>
          <div class="small" id="codex"></div>
        </section>
      </div>
      <div id="tab-field" class="tab-content">
        <section class="panel">
          <h3>Stash Vault</h3>
          <div class="subtabs" id="stashNav">
            <button data-stash-screen="vault" class="active">Vault</button>
            <button data-stash-screen="market">Market Dock</button>
          </div>
          <div class="inventory-layout">
            <div>
              <div id="stashVault" class="subscreen active">
                <h4>Vault Inventory <span class="small" id="stashCount"></span></h4>
                <div id="stash"></div>
              </div>
              <div id="stashMarket" class="subscreen">
                <div class="command-card">
                  <div class="command-title">Market Dock Status</div>
                  <div class="status-toggle">
                    <span id="shopStatus">Docked: No</span>
                    <button id="toggleShop" class="btn-secondary">Request docking clearance</button>
                  </div>
                  <div class="command-hint">Docking grants sell access. Scrap processing is always available.</div>
                  <div id="stashActions"></div>
                </div>
              </div>
            </div>
            <div class="command-card">
              <div class="command-title">Vault Command Card</div>
              <div id="stashDetail" class="command-hint">Select stash items to transfer, scrap, or sell.</div>
              <div class="action-grid" id="stashItemActions"></div>
            </div>
          </div>
          <p class="small">Move loot from the haul into long-term storage, or liquidate overflow for credits.</p>
        </section>
      </div>
      <div id="tab-log" class="tab-content">
        <section class="panel">
          <h3>Ops Log</h3>
          <div id="log" class="log"></div>
        </section>
      </div>
    </div>
  </div>

  <script>
    /* ================= STATE & CONSTANTS ================= */
    const state={
      hp:92,maxHp:100,
      stamina:90,maxStamina:100,
      morale:62,maxMorale:100,
      hunger:15,maxHunger:100,
      thirst:20,maxThirst:100,
      energy:72,maxEnergy:100,
      rads:0,
      bodyTemp:98,maxBodyTemp:104,
      scrap:6,
      credits:50,
      fuel:4,
      keys:1,
      day:1,timeMinutes:6*60,
      backpackLimit:12,
      stashLimit:40,
      stashUpgradeLevel:0,
      inventory:["rusty flashlight","ration bar","scrap wiring"],
      equipped:[],
      codex:["Hub online. Haul bays clear."],
      stash:{name:'Vault Stash',items:[]},
      lootQueue:[],
      autoSalvage:false,
      idleOps:{active:false,id:null,startedAt:null,durationMs:0,etaMinutes:0},
      flags:new Set(),
      log:["Systems cold-started. Zones awaiting tether…"],
      zone:{id:'drift-yard',name:'Drift Yard',risk:'low',desc:'Low-risk salvage corridor. Ideal for stocking up on scrap and common gear.'},
      screen:'main',
      travel:{active:false,endsAt:null,target:null},
      mission:{active:false,raid:null,startedAt:null,endsAt:null,completed:false,success:null,summary:''},
      inventoryScreen:'backpack',
      stashScreen:'vault',
      selected:{source:null,item:null},
      atShop:false
    };

    const ITEM_CATALOG={
      'rusty flashlight':{type:'tool',rarity:'common',value:6,mods:{riskMod:-0.02}},
      'cargo pants':{type:'armor',rarity:'common',value:7,mods:{carryBonus:2,insulation:0.4}},
      'field backpack':{type:'armor',rarity:'uncommon',value:14,mods:{carryBonus:4,insulation:0.2}},
      'flare':{type:'tool',rarity:'uncommon',value:10,mods:{lootBonus:0.04}},
      'patch kit':{type:'tool',rarity:'uncommon',value:12,mods:{riskMod:-0.04}},
      'utility coat':{type:'armor',rarity:'uncommon',value:12,mods:{carryBonus:3,staminaBonus:1,insulation:0.8}},
      'microcell':{type:'tool',rarity:'rare',value:22,mods:{idleSpeed:0.15,energyRegen:1,staminaBonus:2}},
      'rigged backpack':{type:'armor',rarity:'rare',value:24,mods:{carryBonus:6,insulation:0.3}},
      'bandage':{type:'consumable',rarity:'common',value:4,effect:'hp+8'},
      'ration bar':{type:'consumable',rarity:'common',value:3,effect:'hunger-12,morale+2'},
      'water flask':{type:'consumable',rarity:'common',value:4,effect:'thirst-12'},
      'spark tonic':{type:'consumable',rarity:'uncommon',value:8,effect:'energy+18,stamina+6'},
      'scrap wiring':{type:'junk',rarity:'common',value:2,salvage:2},
      'old coin':{type:'junk',rarity:'uncommon',value:6,salvage:1},
      'lockbox key':{type:'key',rarity:'rare',value:18},
      'echo prism':{type:'junk',rarity:'rare',value:20,salvage:6},
      'drone core':{type:'tool',rarity:'epic',value:32,mods:{lootBonus:0.08,energyRegen:2}},
      'relic shard':{type:'junk',rarity:'legendary',value:60,salvage:12},
      'rust town crown':{type:'armor',rarity:'legendary',value:85,mods:{moraleBonus:4,insulation:0.6}},
      'safehouse warden coat':{type:'armor',rarity:'legendary',value:90,mods:{staminaBonus:4,insulation:1}},
      'forest monolith sigil':{type:'tool',rarity:'legendary',value:95,mods:{lootBonus:0.12,energyRegen:2}},
      'neon riot jacket':{type:'armor',rarity:'legendary',value:88,mods:{carryBonus:3,insulation:0.9,moraleBonus:2}}
    };

    const LOOT_BY_RARITY={
      common:['bandage','ration bar','water flask','scrap wiring','rusty flashlight','cargo pants'],
      uncommon:['flare','patch kit','old coin','spark tonic','utility coat','field backpack'],
      rare:['microcell','lockbox key','echo prism','rigged backpack'],
      epic:['drone core'],
      legendary:['relic shard']
    };

    const RAID_TEMPLATES=[
      {id:'quick',label:'Quick Grab',desc:'Fast sweep for low-tier gear.',time:6,energy:8,loot:2,risk:'low'},
      {id:'deep',label:'Deep Sweep',desc:'Longer push with higher-value crates.',time:12,energy:14,loot:3,risk:'medium'},
      {id:'hazard',label:'Hazard Drift',desc:'Pressurized route for rare tech.',time:16,energy:18,loot:4,risk:'high'},
      {id:'vault',label:'Lockbox Crack',desc:'Spend a key to crack sealed cache.',time:10,energy:10,loot:3,risk:'high',key:1}
    ];

    const ACTION_TIMES={camp:10};
    const riskTable={low:0.08,medium:0.2,high:0.32,deadly:0.45};
    const riskRank={low:1,medium:2,high:3,deadly:4};
    const expansions={};
    const idleOperations=[
      {id:'salvage',label:'Drone salvage',desc:'Remote drones bring back scrap and junk.',duration:7,cost:{credits:8},reward:'scrap+3,item:scrap wiring'},
      {id:'survey',label:'Cartography sweep',desc:'Low-risk sweep for new routes and caches.',duration:5,cost:{credits:5},reward:'credits+4,item:old coin'},
      {id:'resupply',label:'Supply errand',desc:'Courier route for field medicine.',duration:9,cost:{credits:10,scrap:1},reward:'item:bandage,item:water flask'}
    ];

    const dom={
      stats:document.getElementById('stats'),
      meta:document.getElementById('meta'),
      excursionStatus:document.getElementById('excursionStatus'),
      tempoHint:document.getElementById('tempoHint'),
      doors:document.getElementById('doors'),
      doorsHint:document.getElementById('doorsHint'),
      zoneTitle:document.getElementById('zoneTitle'),
      zoneDesc:document.getElementById('zoneDesc'),
      zoneBadge:document.getElementById('zoneBadge'),
      raidActions:document.getElementById('raidActions'),
      questBoard:document.getElementById('questBoard'),
      haul:document.getElementById('haul'),
      haulDetail:document.getElementById('haulDetail'),
      haulActions:document.getElementById('haulActions'),
      inventory:document.getElementById('inventory'),
      equipment:document.getElementById('equipment'),
      backpackCount:document.getElementById('backpackCount'),
      loadoutCount:document.getElementById('loadoutCount'),
      codex:document.getElementById('codex'),
      log:document.getElementById('log'),
      idleOps:document.getElementById('idleOps'),
      hubLock:document.getElementById('hubLock'),
      screenNav:document.getElementById('screenNav'),
      screens:{
        main:document.getElementById('screen-main'),
        locations:document.getElementById('screen-locations'),
        mission:document.getElementById('screen-mission')
      },
      screenButtons:Array.from(document.querySelectorAll('#screenNav button')),
      enterLocations:document.getElementById('enterLocations'),
      returnMain:document.getElementById('returnMain'),
      travelStatus:document.getElementById('travelStatus'),
      missionTitle:document.getElementById('missionTitle'),
      missionMeta:document.getElementById('missionMeta'),
      missionProgress:document.getElementById('missionProgress'),
      missionLog:document.getElementById('missionLog'),
      missionActions:document.getElementById('missionActions'),
      stash:document.getElementById('stash'),
      stashActions:document.getElementById('stashActions'),
      stashDetail:document.getElementById('stashDetail'),
      stashItemActions:document.getElementById('stashItemActions'),
      stashCount:document.getElementById('stashCount'),
      itemDetail:document.getElementById('itemDetail'),
      itemActions:document.getElementById('itemActions'),
      inventoryNav:Array.from(document.querySelectorAll('#inventoryNav button')),
      inventoryScreens:{
        backpack:document.getElementById('inventoryBackpack'),
        loadout:document.getElementById('inventoryLoadout')
      },
      stashNav:Array.from(document.querySelectorAll('#stashNav button')),
      stashScreens:{
        vault:document.getElementById('stashVault'),
        market:document.getElementById('stashMarket')
      },
      shopStatus:document.getElementById('shopStatus'),
      toggleShop:document.getElementById('toggleShop'),
      tabs:document.querySelector('.tabs'),
      tabButtons:Array.from(document.querySelectorAll('.tab-buttons button')),
      tabContents:{
        hub:document.getElementById('tab-hub'),
        inventory:document.getElementById('tab-inventory'),
        field:document.getElementById('tab-field'),
        log:document.getElementById('tab-log')
      }
    };

    let activeTab='hub';

    /* ================= UTILITIES ================= */
    const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
    const pct=(v,max)=>Math.round((v/max)*100);
    const NORMAL_BODY_TEMP=98;
    const BODY_TEMP_MIN=70;
    const BODY_TEMP_MAX=104;
    const moveToward=(value,target,amount)=>{
      if(value<target) return Math.min(target,value+amount);
      if(value>target) return Math.max(target,value-amount);
      return value;
    };
    const fmtTime=(mins)=>{
      const m=mins%60;const h=Math.floor(mins/60)%24;const suffix=h>=12?"PM":"AM";
      const hour=((h+11)%12+1);return `${hour}:${m.toString().padStart(2,'0')} ${suffix}`;
    }
    const setCodex=(msg)=>{ state.codex=[msg]; };
    const logMsg=(msg)=>{
      const stamp=`[Day ${state.day} // ${fmtTime(state.timeMinutes)}] ${msg}`;
      state.log.unshift(stamp);
      state.log=state.log.slice(0,14);
      renderLog();
    }

    const removeItem=(arr,item)=>{const idx=arr.indexOf(item); if(idx>=0) arr.splice(idx,1);};
    const getItem=(id)=>ITEM_CATALOG[id] || {type:'junk',rarity:'common',value:1};
    const formatMods=(mods)=>{
      if(!mods) return [];
      return Object.entries(mods).map(([key,val])=>{
        const label=key.replace(/([A-Z])/g,' $1').toLowerCase();
        const sign=val>0?'+':'';
        return `${label} ${sign}${val}`;
      });
    };
    const formatEffects=(effect)=>{
      if(!effect) return [];
      const labels={temp:'body temp'};
      return effect.split(',').map(token=>token.trim()).filter(Boolean).map(token=>{
        if(token.startsWith('item:')) return `Adds item: ${token.slice(5).trim()}`;
        if(token.startsWith('note:')) return token.slice(5).trim();
        if(token.startsWith('log:')) return token.slice(4).trim();
        if(token.startsWith('flag:')) return `Flags ${token.slice(5).trim()}`;
        const match=token.match(/([a-zA-Z]+)([+-]\d+)/);
        if(match){
          const stat=match[1];
          const delta=match[2];
          const label=labels[stat] || stat;
          return `${label} ${delta}`;
        }
        return token;
      });
    };
    const groupItems=(items)=>{
      const tally=items.reduce((acc,item)=>{
        acc[item]=(acc[item]||0)+1;
        return acc;
      },{});
      return Object.entries(tally).map(([id,count])=>({id,count,data:getItem(id)}));
    };
    const rollLootItem=(risk,bonus=0)=>{
      const roll=Math.random();
      const bias={
        low:{common:0.7,uncommon:0.22,rare:0.07,epic:0.009,legendary:0.001},
        medium:{common:0.55,uncommon:0.28,rare:0.13,epic:0.035,legendary:0.005},
        high:{common:0.4,uncommon:0.3,rare:0.18,epic:0.09,legendary:0.03},
        deadly:{common:0.3,uncommon:0.28,rare:0.2,epic:0.14,legendary:0.08}
      };
      const dist=bias[risk] || bias.low;
      const adjusted={
        common:Math.max(0.05,dist.common-(bonus*0.5)),
        uncommon:dist.uncommon+(bonus*0.2),
        rare:dist.rare+(bonus*0.2),
        epic:dist.epic+(bonus*0.08),
        legendary:dist.legendary+(bonus*0.02)
      };
      const rollTable=[
        ['common',adjusted.common],
        ['uncommon',adjusted.uncommon],
        ['rare',adjusted.rare],
        ['epic',adjusted.epic],
        ['legendary',adjusted.legendary]
      ];
      let cursor=0;
      for(const [rarity,weight] of rollTable){
        cursor+=weight;
        if(roll<=cursor){
          const pool=LOOT_BY_RARITY[rarity];
          return pool[Math.floor(Math.random()*pool.length)];
        }
      }
      return 'scrap wiring';
    };
    const getGearMods=(excludeItem)=>{
      return state.equipped.reduce((acc,item)=>{
        if(excludeItem && item===excludeItem) return acc;
        const mod=getItem(item).mods;
        if(!mod) return acc;
        Object.entries(mod).forEach(([key,val])=>{
          acc[key]=(acc[key]||0)+val;
        });
        return acc;
      },{});
    };
    const getBackpackLimit=(excludeItem)=>state.backpackLimit+(getGearMods(excludeItem).carryBonus||0);
    const canUnequipItem=(item)=>state.inventory.length<getBackpackLimit(item);
    const STASH_UPGRADE_STEP=6;
    const STASH_UPGRADE_BASE_COST={credits:32,scrap:4};
    const STASH_UPGRADE_GROWTH={credits:24,scrap:3};
    const getStashUpgradeCost=()=>{
      const level=state.stashUpgradeLevel;
      return {
        credits:STASH_UPGRADE_BASE_COST.credits+(STASH_UPGRADE_GROWTH.credits*level),
        scrap:STASH_UPGRADE_BASE_COST.scrap+(STASH_UPGRADE_GROWTH.scrap*level)
      };
    };
    const upgradeStash=()=>{
      const cost=getStashUpgradeCost();
      if(!canAfford(cost)){
        setCodex('Not enough resources to expand the stash.');
        return;
      }
      applyCost(cost);
      state.stashLimit+=STASH_UPGRADE_STEP;
      state.stashUpgradeLevel+=1;
      setCodex(`Vault expanded by ${STASH_UPGRADE_STEP} slots.`);
      logMsg(`Vault expansion complete. Capacity now ${state.stashLimit}.`);
      renderAll();
    };
    const formatCost=(cost)=>Object.entries(cost).map(([k,v])=>`${v} ${k}`).join(' · ');
    const canAfford=(cost)=>Object.entries(cost).every(([k,v])=>state[k]>=v);
    const applyCost=(cost)=>{
      Object.entries(cost).forEach(([k,v])=>{
        state[k]=Math.max(0,state[k]-v);
      });
    };
    const addToArray=(arr,item)=>{arr.push(item);};
    const equipmentLimit=4;

    function equipItem(item){
      if(state.equipped.includes(item)) return;
      if(state.equipped.length>=equipmentLimit){
        setCodex('Loadout full. Unequip something first.');
        return;
      }
      const data=getItem(item);
      if(!['tool','armor'].includes(data.type)){
        setCodex('Only tools or armor can be equipped.');
        return;
      }
      removeItem(state.inventory,item);
      state.equipped.push(item);
      state.selected={source:'equipped',item};
      setCodex(`${item} equipped.`);
      logMsg(`Equipped ${item}.`);
      renderAll();
    }
    function unequipItem(item){
      if(!canUnequipItem(item)){
        setCodex('Backpack full. Make space before unequipping.');
        return;
      }
      removeItem(state.equipped,item);
      state.inventory.push(item);
      state.selected={source:'inventory',item};
      setCodex(`${item} stowed.`);
      logMsg(`Unequipped ${item}.`);
      renderAll();
    }
    function consumeItem(item){
      const data=getItem(item);
      if(data.effect){
        applyEffects(data.effect,'success');
      }
      removeItem(state.inventory,item);
      state.selected={source:null,item:null};
      logMsg(`Consumed ${item}.`);
      setCodex(`${item} used.`);
      renderAll();
    }
    function stashItem(item){
      if(state.stash.items.length>=state.stashLimit){
        setCodex('Stash is full.');
        return;
      }
      removeItem(state.inventory,item);
      state.stash.items.push(item);
      state.selected={source:'stash',item};
      setCodex(`${item} stored in ${state.stash.name}.`);
      logMsg(`Stored ${item} in ${state.stash.name}.`);
      renderAll();
    }
    function unstashItem(item){
      if(state.inventory.length>=getBackpackLimit()){
        setCodex('Backpack full.');
        return;
      }
      removeItem(state.stash.items,item);
      state.inventory.push(item);
      state.selected={source:'inventory',item};
      setCodex(`${item} withdrawn from ${state.stash.name}.`);
      logMsg(`Retrieved ${item} from ${state.stash.name}.`);
      renderAll();
    }
    function sellItem(item){
      if(!state.atShop){
        setCodex('Dock at the market to sell items.');
        return;
      }
      const data=getItem(item);
      removeItem(state.inventory,item);
      state.credits+=data.value || 1;
      state.selected={source:null,item:null};
      logMsg(`Sold ${item} for ${data.value || 1} credits.`);
      renderAll();
    }
    function dismantleItem(item){
      const data=getItem(item);
      removeItem(state.inventory,item);
      const salvage=data.salvage || Math.max(1,Math.floor((data.value || 1)/2));
      state.scrap+=salvage;
      state.selected={source:null,item:null};
      logMsg(`Dismantled ${item} for ${salvage} scrap.`);
      renderAll();
    }

    function startIdleOp(opId){
      if(state.idleOps.active){
        setCodex('An idle operation is already underway.');
        return;
      }
      const op=idleOperations.find(entry=>entry.id===opId);
      if(!op) return;
      if(!canAfford(op.cost)){
        setCodex('Insufficient resources for this operation.');
        return;
      }
      applyCost(op.cost);
      const gearMods=getGearMods();
      const speedMod=gearMods.idleSpeed || 0;
      const duration=Math.max(3,op.duration*(1-speedMod));
      state.idleOps={
        active:true,
        id:opId,
        startedAt:Date.now(),
        durationMs:duration*60000,
        etaMinutes:duration
      };
      logMsg(`Idle op launched: ${op.label}. ETA ${duration.toFixed(1)} mins.`);
      renderAll();
    }

    function completeIdleOp(){
      const op=idleOperations.find(entry=>entry.id===state.idleOps.id);
      if(!op) return;
      applyEffects(op.reward,'success');
      state.idleOps={active:false,id:null,startedAt:null,durationMs:0,etaMinutes:0};
      logMsg(`Idle op complete: ${op.label}.`);
      setCodex(`Idle op returned with results: ${op.reward}.`);
      renderAll();
    }

    /* ================= RENDERING ================= */
    function renderBars(){
      const rows=[
        ['HP','hp','maxHp','hp'],
        ['Stamina','stamina','maxStamina','stamina'],
        ['Morale','morale','maxMorale','morale'],
        ['Energy','energy','maxEnergy','stamina'],
        ['Hunger','hunger','maxHunger','hunger'],
        ['Hydration','thirst','maxThirst','thirst'],
        ['Radiation','rads',100,'rads'],
        ['Body Temp','bodyTemp','maxBodyTemp','temp']
      ];
      dom.stats.innerHTML=rows.map(([label,key,maxKey,cls])=>{
        const val=state[key];const max=(typeof maxKey==='string')?state[maxKey]:maxKey;
        const percent=clamp(pct(val,max),0,200);
        return `<div class="statline"><div>${label}</div><div class="bar ${cls}"><span style="width:${percent}%;"></span></div><div>${Math.round(val)}/${max}</div></div>`;
      }).join('');
      dom.meta.innerHTML=`<span class="pill-inline"><b>Credits</b>${state.credits}</span>`+
        `<span class="pill-inline"><b>Scrap</b>${state.scrap}</span>`+
        `<span class="pill-inline"><b>Fuel</b>${state.fuel}</span>`+
        `<span class="pill-inline"><b>Keys</b>${state.keys}</span>`+
        `<span class="pill-inline"><b>Time</b>${fmtTime(state.timeMinutes)}</span>`+
        `<span class="pill-inline"><b>Day</b>${state.day}</span>`;
    }

    function buildItemRow({id,count,data,source}){
      const row=document.createElement('div');
      row.className='item-row selectable';
      if(state.selected.source===source && state.selected.item===id){
        row.classList.add('selected');
      }
      row.onclick=()=>selectItem(source,id);
      const name=document.createElement('div');
      name.className='item-name';
      name.textContent=`${id} ×${count}`;
      const meta=document.createElement('div');
      meta.className='item-meta';
      meta.textContent=`${data.type} · ${data.value || 1} cr`;
      const chip=document.createElement('span');
      chip.className=`chip ${data.rarity}`;
      chip.textContent=data.rarity;
      row.appendChild(name);
      row.appendChild(chip);
      row.appendChild(meta);
      return row;
    }

    function renderItemDetails(){
      let {source,item}=state.selected;
      const sourceHasItem=()=>{
        if(!source || !item) return false;
        if(source==='inventory') return state.inventory.includes(item);
        if(source==='equipped') return state.equipped.includes(item);
        if(source==='stash') return state.stash.items.includes(item);
        if(source==='haul') return state.lootQueue.includes(item);
        return false;
      };
      if(source && item && !sourceHasItem()){
        state.selected={source:null,item:null};
        source=null;
        item=null;
      }
      const data=item?getItem(item):null;
      const targets=[
        {detail:dom.itemDetail,actions:dom.itemActions,default:'Select gear to view stats, uses, and actions.'},
        {detail:dom.stashDetail,actions:dom.stashItemActions,default:'Select stash items to transfer, scrap, or sell.'},
        {detail:dom.haulDetail,actions:dom.haulActions,default:'Select loot to route it into your rig.'}
      ];
      targets.forEach(target=>{
        if(!target.detail || !target.actions) return;
        if(!item || !data){
          target.detail.innerHTML=`<div class="command-hint">${target.default}</div>`;
        }else{
          const mods=formatMods(data.mods);
          const effects=formatEffects(data.effect);
          const uses=[];
          if(data.type==='consumable') uses.push('Consume for field boost.');
          if(['tool','armor'].includes(data.type)) uses.push('Equip to gain passive bonuses.');
          if(data.type==='junk') uses.push('Break down for scrap.');
          if(data.type==='key') uses.push('Unlocks lockbox raids.');
          target.detail.innerHTML=`
            <div class="command-title">${item}</div>
            <div class="stat-list">
              <div>Type</div><span>${data.type}</span>
              <div>Rarity</div><span>${data.rarity}</span>
              <div>Value</div><span>${data.value || 1} credits</span>
              ${data.salvage ? `<div>Salvage</div><span>${data.salvage} scrap</span>` : ''}
            </div>
            ${uses.length ? `<div class="small">${uses.join(' ')}</div>` : ''}
            ${effects.length ? `<div class="small"><b>Effects:</b> ${effects.join(' · ')}</div>` : ''}
            ${mods.length ? `<div class="small"><b>Mods:</b> ${mods.join(' · ')}</div>` : ''}
          `;
        }
        target.actions.innerHTML='';
      });
      if(!item || !data) return;

      const actionConfigs=[];
      if(source==='inventory'){
        if(['tool','armor'].includes(data.type)){
          actionConfigs.push({label:'Deploy to loadout',action:()=>equipItem(item),disabled:state.equipped.length>=equipmentLimit});
        }
        if(data.type==='consumable'){
          actionConfigs.push({label:'Use item',action:()=>consumeItem(item)});
        }
        actionConfigs.push({label:'Route to vault',action:()=>stashItem(item),disabled:state.stash.items.length>=state.stashLimit});
        actionConfigs.push({label:'Break down for scrap',action:()=>dismantleItem(item)});
        actionConfigs.push({label:'Sell to market',action:()=>sellItem(item),disabled:!state.atShop,blockedHint:'Dock at market to sell.'});
      }else if(source==='equipped'){
        actionConfigs.push({label:'Return to backpack',action:()=>unequipItem(item),disabled:!canUnequipItem(item)});
      }else if(source==='stash'){
        actionConfigs.push({label:'Withdraw to backpack',action:()=>unstashItem(item),disabled:state.inventory.length>=getBackpackLimit()});
        actionConfigs.push({label:'Break down for scrap',action:()=>scrapStashItem(item)});
        actionConfigs.push({label:'Sell to market',action:()=>sellStashItem(item),disabled:!state.atShop,blockedHint:'Dock at market to sell.'});
      }else if(source==='haul'){
        actionConfigs.push({label:'Pack into backpack',action:()=>moveLootItem(item,'inventory'),disabled:state.inventory.length>=getBackpackLimit()});
        actionConfigs.push({label:'Store in vault',action:()=>moveLootItem(item,'stash'),disabled:state.stash.items.length>=state.stashLimit});
        actionConfigs.push({label:'Break down for scrap',action:()=>scrapLootItem(item)});
        actionConfigs.push({label:'Sell to market',action:()=>sellLootItem(item),disabled:!state.atShop,blockedHint:'Dock at market to sell.'});
      }
      targets.forEach(target=>{
        if(!target.actions) return;
        actionConfigs.forEach(cfg=>{
          const btn=document.createElement('button');
          btn.textContent=cfg.label;
          if(cfg.disabled){
            btn.disabled=true;
            if(cfg.blockedHint){
              btn.title=cfg.blockedHint;
            }
          }
          btn.onclick=cfg.action;
          target.actions.appendChild(btn);
        });
        if(!actionConfigs.length){
          const msg=document.createElement('div');
          msg.className='command-hint';
          msg.textContent='No actions available.';
          target.actions.appendChild(msg);
        }
      });
    }

    function renderInventory(){
      dom.inventory.innerHTML='';
      dom.equipment.innerHTML='';
      if(!state.inventory.length){
        const empty=document.createElement('div');
        empty.className='muted-box';
        empty.textContent='Backpack empty. Run raids to pull more loot.';
        dom.inventory.appendChild(empty);
      }else{
        groupItems(state.inventory).forEach(({id,count,data})=>{
          dom.inventory.appendChild(buildItemRow({id,count,data,source:'inventory'}));
        });
      }
      if(!state.equipped.length){
        const empty=document.createElement('div');
        empty.className='muted-box';
        empty.textContent='Loadout slots open. Equip tools or armor.';
        dom.equipment.appendChild(empty);
      }else{
        groupItems(state.equipped).forEach(({id,count,data})=>{
          dom.equipment.appendChild(buildItemRow({id,count,data,source:'equipped'}));
        });
      }
      if(dom.backpackCount){
        dom.backpackCount.textContent=`(${state.inventory.length}/${getBackpackLimit()})`;
      }
      if(dom.loadoutCount){
        dom.loadoutCount.textContent=`(${state.equipped.length}/${equipmentLimit})`;
      }
      dom.codex.textContent = state.codex[state.codex.length-1] || '';
    }

    function renderLog(){
      dom.log.textContent=state.log.join('\n');
    }

    function renderIdleOps(){
      dom.idleOps.innerHTML='';
      const gearMods=getGearMods();
      if(state.idleOps.active){
        const op=idleOperations.find(entry=>entry.id===state.idleOps.id);
        const elapsed=Math.max(0,(Date.now()-state.idleOps.startedAt)/1000);
        const total=state.idleOps.durationMs/1000;
        const pctDone=clamp((elapsed/total)*100,0,100);
        const card=document.createElement('div');
        card.className='op-card';
        const title=document.createElement('div');
        title.innerHTML=`<b>${op.label}</b> · in progress`;
        const progress=document.createElement('div');
        progress.className='progress';
        progress.innerHTML=`<span style="width:${pctDone}%;"></span>`;
        const meta=document.createElement('div');
        meta.className='op-meta';
        const remaining=Math.max(0,Math.ceil((total-elapsed)/60));
        meta.textContent=`ETA ${remaining} min · ${op.desc}`;
        card.appendChild(title);
        card.appendChild(progress);
        card.appendChild(meta);
        dom.idleOps.appendChild(card);
        return;
      }
      idleOperations.forEach(op=>{
        const card=document.createElement('div');
        card.className='op-card';
        const title=document.createElement('div');
        title.innerHTML=`<b>${op.label}</b>`;
        const meta=document.createElement('div');
        meta.className='op-meta';
        const duration=Math.max(3,op.duration*(1-(gearMods.idleSpeed||0)));
        meta.textContent=`${op.desc} · ${duration.toFixed(1)} min`;
        const cost=document.createElement('div');
        cost.className='op-meta';
        cost.textContent=`Cost: ${formatCost(op.cost)} · Reward: ${op.reward}`;
        const actions=document.createElement('div');
        actions.className='op-actions';
        const btn=document.createElement('button');
        btn.textContent='Dispatch';
        btn.onclick=()=>startIdleOp(op.id);
        if(!canAfford(op.cost)) btn.disabled=true;
        actions.appendChild(btn);
        card.appendChild(title);
        card.appendChild(meta);
        card.appendChild(cost);
        card.appendChild(actions);
        dom.idleOps.appendChild(card);
      });
    }

    function setActiveTab(tab){
      activeTab=tab;
      syncTabs();
    }

    function syncTabs(){
      dom.tabButtons.forEach(btn=>{
        const target=btn.dataset.tab;
        btn.classList.toggle('active',target===activeTab);
        btn.disabled=false;
      });
      if(state.mission.active){
        const stashBtn=dom.tabButtons.find(btn=>btn.dataset.tab==='field');
        if(stashBtn) stashBtn.disabled=true;
      }
      Object.entries(dom.tabContents).forEach(([id,el])=>{
        el.classList.toggle('active',id===activeTab);
      });
    }

    dom.tabButtons.forEach(btn=>{
      btn.onclick=()=>{ activeTab=btn.dataset.tab; syncTabs(); };
    });

    function setInventoryScreen(screen){
      state.inventoryScreen=screen;
      dom.inventoryNav.forEach(btn=>{
        btn.classList.toggle('active',btn.dataset.invScreen===screen);
      });
      Object.entries(dom.inventoryScreens).forEach(([id,el])=>{
        el.classList.toggle('active',id===screen);
      });
    }

    function setStashScreen(screen){
      state.stashScreen=screen;
      dom.stashNav.forEach(btn=>{
        btn.classList.toggle('active',btn.dataset.stashScreen===screen);
      });
      Object.entries(dom.stashScreens).forEach(([id,el])=>{
        el.classList.toggle('active',id===screen);
      });
    }

    dom.inventoryNav.forEach(btn=>{
      btn.onclick=()=>setInventoryScreen(btn.dataset.invScreen);
    });

    dom.stashNav.forEach(btn=>{
      btn.onclick=()=>setStashScreen(btn.dataset.stashScreen);
    });

    if(dom.toggleShop){
      dom.toggleShop.onclick=()=>{
        state.atShop=!state.atShop;
        logMsg(state.atShop ? 'Docked at the market. Vendors ready.' : 'Undocked from the market. Vendors offline.');
        renderAll();
      };
    }

    function selectItem(source,item){
      state.selected={source,item};
      renderItemDetails();
      renderInventory();
      renderStash();
      renderHaul();
    }

    function setScreen(screen){
      if(screen==='locations' && state.mission.active){
        setCodex('Mission in progress. Locations hub locked.');
        return;
      }
      if(screen==='main' && state.mission.active){
        setCodex('Mission in progress. Stay on the raid feed.');
        return;
      }
      if(screen==='mission' && !state.mission.active){
        setCodex('No mission active.');
        return;
      }
      state.screen=screen;
      renderScreens();
    }

    function renderScreens(){
      dom.screenButtons.forEach(btn=>{
        const target=btn.dataset.screen;
        const isLocked=target==='mission' && !state.mission.active;
        const isLocationsLocked=target==='locations' && state.mission.active;
        const isMainLocked=target==='main' && state.mission.active;
        btn.classList.toggle('active',target===state.screen);
        btn.disabled=isLocked || isLocationsLocked || isMainLocked;
      });
      if(dom.enterLocations){
        dom.enterLocations.disabled=state.mission.active;
      }
      Object.entries(dom.screens).forEach(([id,el])=>{
        el.classList.toggle('active',id===state.screen);
      });
    }

    dom.screenButtons.forEach(btn=>{
      btn.onclick=()=>setScreen(btn.dataset.screen);
    });
    dom.enterLocations.onclick=()=>setScreen('locations');
    dom.returnMain.onclick=()=>setScreen('main');

    function renderExcursionStatus(){
      dom.excursionStatus.innerHTML=`<b>Loop status:</b> Energy ${state.energy}/${state.maxEnergy} · Backpack ${state.inventory.length}/${getBackpackLimit()} · Haul ${state.lootQueue.length} · Stash ${state.stash.items.length}/${state.stashLimit}.`;
      dom.tempoHint.textContent=state.autoSalvage
        ? 'Auto-salvage running. Energy drains into quick grabs every few ticks.'
        : 'Spend energy on raids, then sort the incoming haul into backpack or stash.';
    }

    function renderHubAccess(){
      dom.hubLock.textContent=state.mission.active
        ? 'Mission underway. Await extraction clearance before entering locations hub.'
        : 'Ops bay is live. Step into the locations hub to pick a gate and launch a raid.';
    }

    function renderZone(){
      dom.zoneTitle.textContent=state.zone.name;
      dom.zoneDesc.textContent=state.zone.desc;
      dom.zoneBadge.textContent=`${state.zone.risk} risk`;
    }

    function renderRaidActions(){
      dom.raidActions.innerHTML='';
      RAID_TEMPLATES.forEach(raid=>{
        const btn=document.createElement('button');
        const costParts=[`${raid.energy} energy`];
        if(raid.key) costParts.push(`${raid.key} key`);
        btn.innerHTML=`<span>${raid.label}</span><span class="small">${raid.risk} · ${raid.time} min · ${costParts.join(' · ')}</span>`;
        btn.onclick=()=>startMission(raid);
        if(state.mission.active || state.travel.active || !canAfford({energy:raid.energy,keys:raid.key||0})) btn.disabled=true;
        if(raid.risk==='high') btn.classList.add('danger');
        dom.raidActions.appendChild(btn);
      });
      const rest=document.createElement('button');
      rest.innerHTML=`<span>Make camp</span><span class="small">recover · ${ACTION_TIMES.camp} min</span>`;
      rest.onclick=runCamp;
      if(state.mission.active || state.travel.active) rest.disabled=true;
      dom.raidActions.appendChild(rest);
      const fuel=document.createElement('button');
      fuel.innerHTML='<span>Burn fuel cell</span><span class="small">boost · instant</span>';
      fuel.onclick=burnFuel;
      if(state.fuel<=0 || state.mission.active || state.travel.active) fuel.disabled=true;
      dom.raidActions.appendChild(fuel);
      const auto=document.createElement('button');
      auto.textContent=state.autoSalvage?'Disable auto-salvage':'Enable auto-salvage';
      auto.onclick=()=>{
        state.autoSalvage=!state.autoSalvage;
        logMsg(state.autoSalvage?'Auto-salvage engaged.':'Auto-salvage disabled.');
        renderAll();
      };
      if(state.mission.active || state.travel.active) auto.disabled=true;
      dom.raidActions.appendChild(auto);
    }

    function renderQuestBoard(){
      if(!dom.questBoard) return;
      dom.questBoard.innerHTML='';
      const exp=expansions[state.zone.id];
      if(!exp || !exp.quests || !exp.quests.length){
        dom.questBoard.innerHTML='<div class="muted-box">No special contracts in this zone.</div>';
        return;
      }
      exp.quests.forEach(quest=>{
        const card=document.createElement('div');
        card.className='op-card';
        const title=document.createElement('div');
        title.className='mission-title';
        title.textContent=quest.title || 'Special contract';
        const meta=document.createElement('div');
        meta.className='op-meta';
        meta.textContent=`${quest.risk} risk · ${quest.time} min`;
        const desc=document.createElement('div');
        desc.className='small';
        desc.textContent=quest.desc || 'A one-shot opportunity for a legendary reward.';
        const actions=document.createElement('div');
        actions.className='op-actions';
        const btn=document.createElement('button');
        const questFlag=quest.flag || quest.id;
        const completed=quest.once && questFlag && state.flags.has(questFlag);
        btn.textContent=completed ? 'Contract complete' : 'Deploy';
        btn.onclick=()=>runQuest(quest);
        btn.disabled=completed || state.mission.active || state.travel.active;
        actions.appendChild(btn);
        card.appendChild(title);
        card.appendChild(meta);
        card.appendChild(desc);
        card.appendChild(actions);
        dom.questBoard.appendChild(card);
      });
    }

    function renderTravelStatus(){
      const doorButtons=dom.doors.querySelectorAll('button');
      doorButtons.forEach(btn=>{
        btn.disabled=state.mission.active || state.travel.active;
      });
      if(state.travel.active){
        dom.travelStatus.innerHTML=`<span class="spinner"></span><span>Routing to ${state.travel.target.name}… hold tight.</span>`;
      }else{
        dom.travelStatus.textContent='Transit clear. Select a zone gate to jump.';
      }
    }

    function renderMissionStatus(){
      if(!state.mission.active){
        dom.missionTitle.textContent='No mission active.';
        dom.missionMeta.textContent='Launch a raid from the locations hub to enter the field.';
        dom.missionProgress.querySelector('span').style.width='0%';
        dom.missionLog.textContent='';
        dom.missionActions.innerHTML='';
        return;
      }
      const raid=state.mission.raid;
      const remainingMs=Math.max(0,state.mission.endsAt-Date.now());
      const totalMs=Math.max(1,state.mission.endsAt-state.mission.startedAt);
      const percent=clamp(((totalMs-remainingMs)/totalMs)*100,0,100);
      dom.missionProgress.querySelector('span').style.width=`${percent}%`;
      const remainingSec=Math.ceil(remainingMs/1000);
      dom.missionTitle.textContent=state.mission.completed
        ? `Mission complete: ${raid.label}`
        : `In raid: ${raid.label}`;
      dom.missionMeta.textContent=`${raid.risk} risk · ${raid.time} min op · ${state.mission.location?.name || state.zone.name} · ${state.mission.completed ? 'Extraction window open' : `ETA ${remainingSec}s`}`;
      dom.missionLog.textContent=state.mission.summary || 'Stay sharp. Watch the feed for extraction clearance.';
      dom.missionActions.innerHTML='';
      const exitBtn=document.createElement('button');
      exitBtn.textContent='Return to locations hub';
      exitBtn.onclick=()=>{
        state.mission={active:false,raid:null,startedAt:null,endsAt:null,completed:false,success:null,summary:''};
        setScreen('locations');
        renderAll();
      };
      exitBtn.disabled=!state.mission.completed;
      dom.missionActions.appendChild(exitBtn);
    }

    function renderHaul(){
      dom.haul.innerHTML='';
      if(!state.lootQueue.length){
        dom.haul.innerHTML='<div class="muted-box">No loot waiting. Run a raid to generate a haul.</div>';
        return;
      }
      const grid=document.createElement('div');
      grid.className='item-grid';
      groupItems(state.lootQueue).forEach(({id,count,data})=>{
        grid.appendChild(buildItemRow({id,count,data,source:'haul'}));
      });
      dom.haul.appendChild(grid);
      const bulk=document.createElement('div');
      bulk.className='inventory inline-actions';
      const packAll=document.createElement('button');
      packAll.textContent='Pack all';
      packAll.onclick=()=>bulkMoveLoot('inventory');
      const stashAll=document.createElement('button');
      stashAll.textContent='Stash all';
      stashAll.onclick=()=>bulkMoveLoot('stash');
      const sellAll=document.createElement('button');
      sellAll.textContent='Sell all';
      sellAll.onclick=bulkSellLoot;
      if(!state.atShop) sellAll.disabled=true;
      const scrapAll=document.createElement('button');
      scrapAll.textContent='Scrap all';
      scrapAll.onclick=bulkScrapLoot;
      bulk.appendChild(packAll);
      bulk.appendChild(stashAll);
      bulk.appendChild(sellAll);
      bulk.appendChild(scrapAll);
      dom.haul.appendChild(bulk);
    }

    function renderStash(){
      dom.stash.innerHTML='';
      dom.stashActions.innerHTML='';
      if(dom.shopStatus){
        dom.shopStatus.textContent=`Docked: ${state.atShop ? 'Yes' : 'No'}`;
      }
      if(dom.toggleShop){
        dom.toggleShop.textContent=state.atShop ? 'Undock from market' : 'Request docking clearance';
      }
      const wrap=document.createElement('div');
      wrap.className='item-grid';
      const items=state.stash.items;
      if(dom.stashCount){
        dom.stashCount.textContent=`(${items.length}/${state.stashLimit})`;
      }
      if(!items.length){
        wrap.innerHTML='<div class="muted-box">Stash is empty. Move loot here for long-term storage.</div>';
      }else{
        groupItems(items).forEach(({id,count,data})=>{
          wrap.appendChild(buildItemRow({id,count,data,source:'stash'}));
        });
      }
      dom.stash.appendChild(wrap);
      const upgradeCost=getStashUpgradeCost();
      const upgradeCard=document.createElement('div');
      upgradeCard.className='op-card';
      const upgradeTitle=document.createElement('div');
      upgradeTitle.innerHTML='<b>Vault expansion</b>';
      const upgradeMeta=document.createElement('div');
      upgradeMeta.className='op-meta';
      upgradeMeta.textContent=`Increase vault capacity by ${STASH_UPGRADE_STEP} slots.`;
      const upgradeCostLine=document.createElement('div');
      upgradeCostLine.className='op-meta';
      upgradeCostLine.textContent=`Cost: ${formatCost(upgradeCost)} · Current capacity ${state.stashLimit}.`;
      const upgradeActions=document.createElement('div');
      upgradeActions.className='op-actions';
      const upgradeBtn=document.createElement('button');
      upgradeBtn.textContent=`Upgrade stash (+${STASH_UPGRADE_STEP})`;
      upgradeBtn.onclick=upgradeStash;
      if(!canAfford(upgradeCost)){
        upgradeBtn.disabled=true;
        upgradeBtn.title='Need more credits or scrap.';
      }
      upgradeActions.appendChild(upgradeBtn);
      upgradeCard.appendChild(upgradeTitle);
      upgradeCard.appendChild(upgradeMeta);
      upgradeCard.appendChild(upgradeCostLine);
      upgradeCard.appendChild(upgradeActions);
      dom.stashActions.appendChild(upgradeCard);
      const bulk=document.createElement('div');
      bulk.className='inventory inline-actions';
      const sellAll=document.createElement('button');
      sellAll.textContent='Sell all stash';
      sellAll.onclick=bulkSellStash;
      if(!state.atShop) sellAll.disabled=true;
      const scrapAll=document.createElement('button');
      scrapAll.textContent='Scrap all stash';
      scrapAll.onclick=bulkScrapStash;
      bulk.appendChild(sellAll);
      bulk.appendChild(scrapAll);
      dom.stashActions.appendChild(bulk);
    }

    /* ================= GAMEPLAY ================= */
    function computeFailChance(risk){
      const base=riskTable[risk] ?? 0.12;
      const gearMods=getGearMods();
      const radsPenalty=Math.min(0.08,state.rads*0.004);
      const hungerPenalty=state.hunger>70?0.05:0;
      const thirstPenalty=state.thirst>70?0.05:0;
      const fatiguePenalty=state.stamina<30?0.04:0;
      const energyPenalty=state.energy<25?0.06:0;
      const tempPenalty=state.bodyTemp<94?0.07:(state.bodyTemp>102?0.05:0);
      const total=base + hungerPenalty + thirstPenalty + fatiguePenalty + energyPenalty + radsPenalty + tempPenalty - (gearMods.riskMod||0);
      return clamp(total,0.05,0.75);
    }

    function tickTime(minutes){
      const total=state.timeMinutes+minutes;
      if(total>=24*60){
        state.timeMinutes=total%(24*60);
        advanceDay();
      }else{
        state.timeMinutes=total;
      }
    }

    function advanceDay(){
      state.day++;
      state.timeMinutes=6*60;
    }

    function rollComplication(source){
      const tension=computeFailChance(state.zone.risk) * 0.55;
      if(Math.random()>tension) return;
      const complications=[
        {desc:'A cold gust slips through your seals.',effects:'temp-2,stamina-2'},
        {desc:'An unseen stalker snatches some scrap.',effects:'scrap-2,temp-1'},
        {desc:'Hunger cramps slow you down.',effects:'stamina-6,hp-3'},
        {desc:'Static surge fries a component.',effects:'credits-6,temp-1'},
        {desc:'Radiation spike makes your skin crawl.',effects:'rads+2,hp-4'}
      ];
      const hit=complications[Math.floor(Math.random()*complications.length)];
      applyEffects(hit.effects,'fail');
      logMsg(`Complication (${source}): ${hit.desc}`);
    }

    function applyEffects(effectStr,outcome){
      if(!effectStr) return;
      effectStr.split(',').forEach(token=>{
        token=token.trim(); if(!token) return;
        if(token.startsWith('item:')){
          const item=token.slice(5).trim();
          if(state.inventory.length<getBackpackLimit()) state.inventory.push(item);
          else state.lootQueue.push(item);
          return;
        }
        if(token.startsWith('flag:')){ state.flags.add(token.slice(5)); return; }
        if(token.startsWith('note:')){ setCodex(token.slice(5)); return; }
        if(token.startsWith('log:')){ logMsg(token.slice(4)); return; }
        const match=token.match(/([a-zA-Z]+)([+-]\d+)/);
        if(match){
          const stat=match[1]; const delta=Number(match[2]);
          if(stat==='hp') state.hp=clamp(state.hp+delta,0,state.maxHp);
          else if(stat==='stamina') state.stamina=clamp(state.stamina+delta,0,state.maxStamina);
          else if(stat==='morale') state.morale=clamp(state.morale+delta,0,state.maxMorale);
          else if(stat==='hunger') state.hunger=clamp(state.hunger+delta,0,state.maxHunger);
          else if(stat==='thirst') state.thirst=clamp(state.thirst+delta,0,state.maxThirst);
          else if(stat==='rads') state.rads=Math.max(0,state.rads+delta);
          else if(stat==='credits') state.credits=Math.max(0,state.credits+delta);
          else if(stat==='scrap') state.scrap=Math.max(0,state.scrap+delta);
          else if(stat==='energy') state.energy=clamp(state.energy+delta,0,state.maxEnergy);
          else if(stat==='fuel') state.fuel=Math.max(0,state.fuel+delta);
          else if(stat==='keys') state.keys=Math.max(0,state.keys+delta);
          else if(stat==='temp') state.bodyTemp=clamp(state.bodyTemp+delta,BODY_TEMP_MIN,BODY_TEMP_MAX);
        }
      });
      if(outcome==='fail' && state.hp<=0){
        logMsg('Emergency evac: you collapse and lose momentum.');
        state.hp=clamp(40,1,state.maxHp);
        state.morale=clamp(state.morale-12,0,state.maxMorale);
        state.energy=clamp(state.energy-20,0,state.maxEnergy);
      }
    }
    function runRaidInstant(raid,location){
      tickTime(raid.time);
      const gearMods=getGearMods();
      state.hunger=clamp(state.hunger+2,0,state.maxHunger);
      state.thirst=clamp(state.thirst+2,0,state.maxThirst);
      state.stamina=clamp(state.stamina-6+(gearMods.staminaBonus||0),0,state.maxStamina);

      const locationRisk=location?.risk || state.zone.risk;
      const effectiveRisk=(riskRank[raid.risk] >= riskRank[locationRisk]) ? raid.risk : locationRisk;
      const failChance=computeFailChance(effectiveRisk);
      const roll=Math.random();
      const success=roll>failChance;
      state.bodyTemp=clamp(state.bodyTemp-1.1,BODY_TEMP_MIN,BODY_TEMP_MAX);
      if(success){
        const lootBonus=gearMods.lootBonus || 0;
        const pulls=Math.max(1,raid.loot+(Math.random()<0.35?1:0));
        for(let i=0;i<pulls;i++){
          state.lootQueue.push(rollLootItem(effectiveRisk,lootBonus));
        }
        logMsg(`✓ ${raid.label} succeeded. Haul inbound.`);
      }else{
        applyEffects('hp-6,morale-4,temp-2','fail');
        rollComplication('raid');
        logMsg(`✖ ${raid.label} failed. You limp back empty-handed.`);
      }
      return success;
    }

    function runQuest(quest){
      if(state.mission.active || state.travel.active){
        setCodex('Finish current operations before starting a contract.');
        return;
      }
      const questFlag=quest.flag || quest.id;
      if(quest.once && questFlag && state.flags.has(questFlag)){
        setCodex('That contract has already been completed.');
        return;
      }
      tickTime(quest.time);
      const failChance=computeFailChance(quest.risk || state.zone.risk);
      const success=Math.random()>failChance;
      if(success){
        applyEffects(quest.success,'success');
        if(questFlag) state.flags.add(questFlag);
        logMsg(`✓ Contract complete: ${quest.title}.`);
        setCodex('Legendary cache secured. Return to hub.');
      }else{
        applyEffects(quest.fail,'fail');
        logMsg(`✖ Contract failed: ${quest.title}.`);
      }
      renderAll();
    }

    function startMission(raid){
      const cost={energy:raid.energy,keys:raid.key||0};
      if(state.mission.active){
        setCodex('Mission already underway.');
        return;
      }
      if(state.travel.active){
        setCodex('Finish travel before launching a mission.');
        return;
      }
      if(!canAfford(cost)){
        setCodex('Not enough resources for that raid.');
        return;
      }
      applyCost(cost);
      const now=Date.now();
      state.mission={
        active:true,
        raid,
        startedAt:now,
        endsAt:now+(raid.time*1000),
        completed:false,
        success:null,
        summary:'',
        location:{...state.zone}
      };
      setCodex(`Mission launched: ${raid.label}.`);
      logMsg(`Mission launched: ${raid.label} (${raid.time} min op).`);
      setActiveTab('hub');
      setScreen('mission');
      renderAll();
    }

    function completeMission(){
      if(!state.mission.active || state.mission.completed) return;
      const raid=state.mission.raid;
      const success=runRaidInstant(raid,state.mission.location);
      state.mission.completed=true;
      state.mission.success=success;
      state.mission.summary=success
        ? 'Extraction secured. Haul loaded and sealed.'
        : 'Extraction rough. Patch up before you re-deploy.';
      setCodex('Extraction window open. Return to locations hub.');
      renderAll();
    }

    function moveLootItem(item,target){
      removeItem(state.lootQueue,item);
      if(target==='inventory'){
        if(state.inventory.length>=getBackpackLimit()){
          setCodex('Backpack full. Make room first.');
          state.lootQueue.push(item);
          return;
        }
        state.inventory.push(item);
        state.selected={source:'inventory',item};
      }else if(target==='stash'){
        if(state.stash.items.length>=state.stashLimit){
          setCodex('Stash full. Sell or scrap to clear space.');
          state.lootQueue.push(item);
          return;
        }
        state.stash.items.push(item);
        state.selected={source:'stash',item};
      }
      renderAll();
    }

    function bulkMoveLoot(target){
      const items=[...state.lootQueue];
      state.lootQueue=[];
      items.forEach(item=>{
        if(target==='inventory' && state.inventory.length<getBackpackLimit()){
          state.inventory.push(item);
          state.selected={source:'inventory',item};
        }else if(target==='stash' && state.stash.items.length<state.stashLimit){
          state.stash.items.push(item);
          state.selected={source:'stash',item};
        }else{
          state.lootQueue.push(item);
        }
      });
      if(state.lootQueue.length){
        setCodex('Some loot could not be moved due to capacity.');
      }
      renderAll();
    }

    function sellLootItem(item){
      if(!state.atShop){
        setCodex('Dock at the market to sell items.');
        return;
      }
      const data=getItem(item);
      removeItem(state.lootQueue,item);
      state.credits+=data.value || 1;
      state.selected={source:null,item:null};
      renderAll();
    }

    function scrapLootItem(item){
      const data=getItem(item);
      removeItem(state.lootQueue,item);
      const salvage=data.salvage || Math.max(1,Math.floor((data.value || 1)/2));
      state.scrap+=salvage;
      state.selected={source:null,item:null};
      renderAll();
    }

    function bulkSellLoot(){
      if(!state.atShop){
        setCodex('Dock at the market to sell items.');
        return;
      }
      state.lootQueue.forEach(item=>{
        const data=getItem(item);
        state.credits+=data.value || 1;
      });
      state.lootQueue=[];
      state.selected={source:null,item:null};
      renderAll();
    }

    function bulkScrapLoot(){
      state.lootQueue.forEach(item=>{
        const data=getItem(item);
        const salvage=data.salvage || Math.max(1,Math.floor((data.value || 1)/2));
        state.scrap+=salvage;
      });
      state.lootQueue=[];
      state.selected={source:null,item:null};
      renderAll();
    }

    function sellStashItem(item){
      if(!state.atShop){
        setCodex('Dock at the market to sell items.');
        return;
      }
      const data=getItem(item);
      removeItem(state.stash.items,item);
      state.credits+=data.value || 1;
      state.selected={source:null,item:null};
      renderAll();
    }

    function scrapStashItem(item){
      const data=getItem(item);
      removeItem(state.stash.items,item);
      const salvage=data.salvage || Math.max(1,Math.floor((data.value || 1)/2));
      state.scrap+=salvage;
      state.selected={source:null,item:null};
      renderAll();
    }

    function bulkSellStash(){
      if(!state.atShop){
        setCodex('Dock at the market to sell items.');
        return;
      }
      state.stash.items.forEach(item=>{
        const data=getItem(item);
        state.credits+=data.value || 1;
      });
      state.stash.items=[];
      state.selected={source:null,item:null};
      renderAll();
    }

    function bulkScrapStash(){
      state.stash.items.forEach(item=>{
        const data=getItem(item);
        const salvage=data.salvage || Math.max(1,Math.floor((data.value || 1)/2));
        state.scrap+=salvage;
      });
      state.stash.items=[];
      state.selected={source:null,item:null};
      renderAll();
    }

    function runCamp(){
      tickTime(ACTION_TIMES.camp);
      const gearMods=getGearMods();
      state.stamina=clamp(state.stamina+14,0,state.maxStamina);
      state.hp=clamp(state.hp+4,0,state.maxHp);
      state.morale=clamp(state.morale+4+(gearMods.moraleBonus||0),0,state.maxMorale);
      state.energy=clamp(state.energy+18+(gearMods.energyRegen||0),0,state.maxEnergy);
      state.hunger=clamp(state.hunger+3,0,state.maxHunger);
      state.thirst=clamp(state.thirst+3,0,state.maxThirst);
      state.bodyTemp=moveToward(state.bodyTemp,NORMAL_BODY_TEMP,4);
      logMsg('You bunker down, warm up, and recover energy.');
      rollComplication('camp');
      renderAll();
    }

    function burnFuel(){
      if(state.fuel<=0){
        setCodex('No fuel cells left.');
        return;
      }
      state.fuel=Math.max(0,state.fuel-1);
      state.energy=clamp(state.energy+25,0,state.maxEnergy);
      state.stamina=clamp(state.stamina+6,0,state.maxStamina);
      logMsg('Fuel cell burned for a quick energy surge.');
      renderAll();
    }

    /* ================= EXPANSION LOADING ================= */
    async function loadGames(){
      try{
        const res=await fetch('games.json');
        const data=await res.json();
        dom.doorsHint.textContent='';
        data.expansions.forEach(meta=>loadExpansion(meta));
      }catch(err){
        dom.doorsHint.textContent='Unable to load games.json';
        console.error(err);
      }
    }

    async function loadExpansion(meta){
      try{
        const res=await fetch(meta.file);
        const raw=await res.text();
        const expansion=parseExpansion(raw);
        expansion.meta.id=meta.id || expansion.meta.id;
        expansion.meta.name=meta.name || expansion.meta.name || meta.id;
        expansions[expansion.meta.id]=expansion;
        addDoor(expansion);
        logMsg(`Door bolted on: ${expansion.meta.name}`);
      }catch(err){
        logMsg(`Failed to load ${meta.id}`);
        console.error(err);
      }
    }

    function addDoor(exp){
      const btn=document.createElement('button');
      btn.innerHTML=`<span>${exp.door?.label||exp.meta.name}</span><span class="small">${exp.door?.hint||'Unknown contact'}</span>`;
      btn.onclick=()=>{
        if(state.mission.active){
          setCodex('Mission in progress. Cannot change locations.');
          return;
        }
        if(state.travel.active){
          setCodex('Already rerouting. Stand by.');
          return;
        }
        const target={
          id:exp.meta.id,
          name:exp.meta.name,
          risk:exp.door?.risk || 'low',
          desc:exp.door?.desc || exp.door?.hint || 'Salvage zone marked by strange chatter.'
        };
        state.travel={
          active:true,
          endsAt:Date.now()+1000,
          target
        };
        if(exp.door?.note) setCodex(exp.door.note);
        renderAll();
      };
      dom.doors.appendChild(btn);
    }

    function parseOption(str){
      // Format: Label => target | risk:low | time:10 | success:hp+5,credits+10 | fail:hp-5 | rad:1 | temp:1
      const segments=str.split('|').map(s=>s.trim()).filter(Boolean);
      const [labelPart,...rest]=segments;
      const [label,target]=labelPart.split('=>').map(s=>s&&s.trim());
      const opt={label:label||'Action',target:target||null,risk:'low',time:8,success:'',fail:'',rad:0,temp:0};
      rest.forEach(seg=>{
        const [k,vRaw]=seg.split(':');
        const v=vRaw?.trim();
        if(!k) return;
        const key=k.trim().toLowerCase();
        if(key==='risk') opt.risk=v;
        else if(key==='time') opt.time=Number(v||8);
        else if(key==='success') opt.success=v;
        else if(key==='fail') opt.fail=v;
        else if(key==='rad') opt.rad=Number(v||0);
        else if(key==='temp') opt.temp=Number(v||0);
      });
      return opt;
    }

    function parseExpansion(raw){
      const exp={meta:{},door:{},scenes:{},quests:[]};
      let scope='meta';
      let currentScene=null;
      let currentQuest=null;
      raw.split(/\r?\n/).forEach(line=>{
        line=line.trim();
        if(!line || line.startsWith('#')) return;
        if(line.startsWith('@expansion')){scope='meta';currentScene=null;currentQuest=null;return;}
        if(line.startsWith('@door')){scope='door';currentScene=null;currentQuest=null;return;}
        if(line.startsWith('@scene')){
          scope='scene';
          currentQuest=null;
          const id=line.split(/\s+/)[1] || `scene-${Object.keys(exp.scenes).length+1}`;
          currentScene={id,title:'',desc:'',tags:'',options:[]};
          exp.scenes[id]=currentScene;return;
        }
        if(line.startsWith('@quest')){
          scope='quest';
          currentScene=null;
          currentQuest={
            id:`quest-${exp.quests.length+1}`,
            title:'Special contract',
            desc:'',
            risk:'medium',
            time:10,
            success:'',
            fail:'',
            once:true,
            flag:''
          };
          exp.quests.push(currentQuest);
          return;
        }
        const [key,...rest]=line.split(':');
        const value=rest.join(':').trim();
        if(scope==='meta') exp.meta[key]=value;
        else if(scope==='door') exp.door[key]=value;
        else if(scope==='scene' && currentScene){
          if(key==='option') currentScene.options.push(parseOption(value));
          else if(key==='desc') currentScene.desc += (currentScene.desc?' ':'') + value;
          else currentScene[key]=value;
        }else if(scope==='quest' && currentQuest){
          if(key==='desc') currentQuest.desc += (currentQuest.desc?' ':'') + value;
          else if(key==='time') currentQuest.time=Number(value || 10);
          else if(key==='once') currentQuest.once=value !== 'false';
          else currentQuest[key]=value;
        }
      });
      return exp;
    }

    function renderAll(){
      renderBars();
      renderInventory();
      renderLog();
      renderExcursionStatus();
      renderHubAccess();
      renderTravelStatus();
      renderMissionStatus();
      renderIdleOps();
      renderZone();
      renderRaidActions();
      renderQuestBoard();
      renderHaul();
      renderStash();
      renderItemDetails();
      setInventoryScreen(state.inventoryScreen);
      setStashScreen(state.stashScreen);
      renderScreens();
      syncTabs();
    }

    /* ================= INIT ================= */
    renderAll();
    loadGames();

    function updateTimers(){
      if(state.travel.active && Date.now()>=state.travel.endsAt){
        state.zone=state.travel.target;
        state.travel={active:false,endsAt:null,target:null};
        setCodex(`Arrived at ${state.zone.name}.`);
        logMsg(`Transit complete: ${state.zone.name}.`);
        renderAll();
      }
      if(state.mission.active && !state.mission.completed && Date.now()>=state.mission.endsAt){
        completeMission();
      }
      if(state.mission.active){
        renderMissionStatus();
      }
      if(state.travel.active){
        renderTravelStatus();
      }
    }

    function ambientTick(){
      tickTime(4);
      if(state.idleOps.active){
        const elapsed=Date.now()-state.idleOps.startedAt;
        if(elapsed>=state.idleOps.durationMs){
          completeIdleOp();
          return;
        }
      }
      const gearMods=getGearMods();
      state.energy=clamp(state.energy+4+(gearMods.energyRegen||0),0,state.maxEnergy);
      state.hunger=clamp(state.hunger+1,0,state.maxHunger);
      state.thirst=clamp(state.thirst+1,0,state.maxThirst);
      const inHub=state.screen==='main' || state.screen==='locations';
      if(inHub){
        state.bodyTemp=moveToward(state.bodyTemp,NORMAL_BODY_TEMP,1.6);
      }else{
        const insulation=gearMods.insulation || 0;
        const loss=Math.max(0.4,1.3-insulation);
        state.bodyTemp=clamp(state.bodyTemp-loss,BODY_TEMP_MIN,BODY_TEMP_MAX);
      }
      if(state.autoSalvage && state.energy>=12 && state.lootQueue.length<16){
        if(!state.mission.active && !state.travel.active){
          applyCost({energy:RAID_TEMPLATES[0].energy,keys:0});
          runRaidInstant(RAID_TEMPLATES[0],state.zone);
        }
      }
      if(state.hunger>=90){
        applyEffects('hp-3,morale-2','fail');
        logMsg('Starvation gnaws at you while you hesitate.');
      }
      if(state.thirst>=90){
        applyEffects('hp-4,stamina-5','fail');
        logMsg('Dehydration blurs your vision.');
      }
      if(state.bodyTemp<=92){
        applyEffects('hp-2,stamina-3','fail');
        if(state.timeMinutes%60===0){
          logMsg('Cold seeps into your limbs. Find shelter or warm up soon.');
        }
      }
      if(state.bodyTemp>=103){
        applyEffects('hp-2,morale-2','fail');
        if(state.timeMinutes%60===0){
          logMsg('Heat haze clouds your focus. Cool down before it worsens.');
        }
      }
      rollComplication('idle time');
      renderAll();
    }

    setInterval(ambientTick,6500);
    setInterval(updateTimers,250);
  </script>
</body>
</html>
